commit_id,cvs_id,bug_id,committer,commit_msg,commit_time,diff_content
10926efedaf3d6588f83a6dd3fbf8c41cda12131,31318,490790,Jonas Sicking,"Fix bug 490790. r=dveditz
",1267558814,"""diff --git a/content/base/public/nsContentUtils.h b/content/base/public/nsContentUtils.h
index 4d974fa..823166c 100644
--- a/content/base/public/nsContentUtils.h
+++ b/content/base/public/nsContentUtils.h
@@ -1257,6 +1257,11 @@ public:
                                           nsISupports* aExtra = nsnull);
 
   /**
+   * Returns true if aPrincipal is the system principal.
+   */
+  static PRBool IsSystemPrincipal(nsIPrincipal* aPrincipal);
+
+  /**
    * Trigger a link with uri aLinkURI. If aClick is false, this triggers a
    * mouseover on the link, otherwise it triggers a load after doing a
    * security check using aContent's principal.
diff --git a/content/base/public/nsIContentPolicy.idl b/content/base/public/nsIContentPolicy.idl
index 06268da..8ef1afc 100644
--- a/content/base/public/nsIContentPolicy.idl
+++ b/content/base/public/nsIContentPolicy.idl
@@ -112,7 +112,7 @@ interface nsIContentPolicy : nsISupports
   const unsigned long TYPE_PING        = 10;
 
   /**
-   * Indicates an XMLHttpRequest.
+   * Indicates an XMLHttpRequest. Also used for document.load.
    */
   const unsigned long TYPE_XMLHTTPREQUEST = 11;
 
diff --git a/content/base/src/nsContentUtils.cpp b/content/base/src/nsContentUtils.cpp
index 46f30d2..544b489 100644
--- a/content/base/src/nsContentUtils.cpp
+++ b/content/base/src/nsContentUtils.cpp
@@ -4251,6 +4251,14 @@ nsContentUtils::CheckSecurityBeforeLoad(nsIURI* aURIToLoad,
   return aLoadingPrincipal->CheckMayLoad(aURIToLoad, PR_TRUE);
 }
 
+PRBool
+nsContentUtils::IsSystemPrincipal(nsIPrincipal* aPrincipal)
+{
+  PRBool isSystem;
+  nsresult rv = sSecurityManager->IsSystemPrincipal(aPrincipal, &isSystem);
+  return NS_SUCCEEDED(rv) && isSystem;
+}
+
 /* static */
 void
 nsContentUtils::TriggerLink(nsIContent *aContent, nsPresContext *aPresContext,
diff --git a/content/xml/document/src/nsXMLDocument.cpp b/content/xml/document/src/nsXMLDocument.cpp
index bf4f758..9b79edd 100644
--- a/content/xml/document/src/nsXMLDocument.cpp
+++ b/content/xml/document/src/nsXMLDocument.cpp
@@ -85,6 +85,8 @@
 #include """"nsIScriptGlobalObjectOwner.h""""
 #include """"nsIJSContextStack.h""""
 #include """"nsContentCreatorFunctions.h""""
+#include """"nsContentPolicyUtils.h""""
+#include """"nsContentErrors.h""""
 #include """"nsIDOMUserDataHandler.h""""
 #include """"nsEventDispatcher.h""""
 #include """"nsNodeUtils.h""""
@@ -335,10 +337,6 @@ nsXMLDocument::Load(const nsAString& aUrl, PRBool *aReturn)
     return rv;
   }
 
-  nsCOMPtr<nsIPrincipal> principal = NodePrincipal();
-  nsCOMPtr<nsIURI> codebase;
-  principal->GetURI(getter_AddRefs(codebase));
-
   // Check to see whether the current document is allowed to load this URI.
   // It's important to use the current document's principal for this check so
   // that we don't end up in a case where code with elevated privileges is
@@ -347,9 +345,26 @@ nsXMLDocument::Load(const nsAString& aUrl, PRBool *aReturn)
   // Enforce same-origin even for chrome loaders to avoid someone accidentally
   // using a document that content has a reference to and turn that into a
   // chrome document.
-  if (codebase) {
+  nsCOMPtr<nsIPrincipal> principal = NodePrincipal();
+  if (!nsContentUtils::IsSystemPrincipal(principal)) {
     rv = principal->CheckMayLoad(uri, PR_FALSE);
     NS_ENSURE_SUCCESS(rv, rv);
+
+    PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
+    rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_XMLHTTPREQUEST,
+                                   uri,
+                                   principal,
+                                   callingDoc ? callingDoc.get() :
+                                     static_cast<nsIDocument*>(this),
+                                   NS_LITERAL_CSTRING(""""application/xml""""),
+                                   nsnull,
+                                   &shouldLoad,
+                                   nsContentUtils::GetContentPolicy(),
+                                   nsContentUtils::GetSecurityManager());
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (NS_CP_REJECTED(shouldLoad)) {
+      return NS_ERROR_CONTENT_BLOCKED;
+    }
   } else {
     // We're called from chrome, check to make sure the URI we're
     // about to load is also chrome."""
30339cb0b363e67944898ef38d06b50584b27c5f,34426,471962,Justin Wood,"Backout disabling of browser_bug471962.js since Bug 565199 is actually fixed. rs+=gavin

--HG--
extra : rebase_source : f6ba751ca296c934758931e85c3cd1a938c9513a
",1276131306,"""diff --git a/toolkit/content/tests/browser/browser_bug471962.js b/toolkit/content/tests/browser/browser_bug471962.js
index 25b74ad..18d74a3 100644
--- a/toolkit/content/tests/browser/browser_bug471962.js
+++ b/toolkit/content/tests/browser/browser_bug471962.js
@@ -40,7 +40,7 @@
  * sent to the address of the inner page.
  */
 function test() {
-  /*
+
   // --- Testing support library ---
 
   // Import the toolkit test support library in the scope of the current test.
@@ -55,20 +55,14 @@ function test() {
   const kBaseUrl =
         """"http://mochi.test:8888/browser/toolkit/content/tests/browser/data/"""";
 
-  function pageShown(event)
-  {
-    if (event.target.location != """"about:blank"""")
-      testRunner.continueTest();
-  }
-
   function FramePostData_TestGenerator() {
     // Display the outer page, and wait for it to be loaded. Loading the URI
     // doesn't generally raise any exception, but if an error page is
     // displayed, an exception will occur later during the test.
-    gBrowser.addEventListener(""""pageshow"""", pageShown, false);
+    gBrowser.addEventListener(""""pageshow"""", testRunner.continueTest, false);
     gBrowser.loadURI(kBaseUrl + """"post_form_outer.sjs"""");
     yield;
-    gBrowser.removeEventListener(""""pageshow"""", pageShown, false);
+    gBrowser.removeEventListener(""""pageshow"""", testRunner.continueTest, false);
 
     try {
       // Submit the form in the outer page, then wait for both the outer
@@ -146,9 +140,5 @@ function test() {
 
   // --- Run the test ---
 
- testRunner.runTest(FramePostData_TestGenerator);
-*/
-  // Disable this generator-using test until bug 565199 is fixed.
-  ok(true, true);
-    
+  testRunner.runTest(FramePostData_TestGenerator);
 }"""
a5787051f358aa0d43d240b49dbe8a189c0e92d3,35747,455472,Boris Zbarsky,"Bug 455472.  Be a little more careful with our handling of application/octet-stream.  r=jst
",1259816219,"""diff --git a/content/base/src/nsObjectLoadingContent.cpp b/content/base/src/nsObjectLoadingContent.cpp
index 8ab742a..da9f98e 100644
--- a/content/base/src/nsObjectLoadingContent.cpp
+++ b/content/base/src/nsObjectLoadingContent.cpp
@@ -414,11 +414,15 @@ nsObjectLoadingContent::OnStartRequest(nsIRequest *aRequest,
   // true:
   //
   // 1) The channel type is application/octet-stream and we have a
-  //    type hint
+  //    type hint and the type hint is not a document type.
   // 2) Our type hint is a type that we support with a plugin.
 
   if ((channelType.EqualsASCII(APPLICATION_OCTET_STREAM) && 
-       !mContentType.IsEmpty()) ||
+       !mContentType.IsEmpty() &&
+       GetTypeOfContent(mContentType) != eType_Document) ||
+      // Need to check IsSupportedPlugin() in addition to GetTypeOfContent()
+      // because otherwise the default plug-in's catch-all behavior would
+      // confuse things.
       (IsSupportedPlugin(mContentType) && 
        GetTypeOfContent(mContentType) == eType_Plugin)) {
     // Set the type we'll use for dispatch on the channel.  Otherwise we could
diff --git a/content/base/test/Makefile.in b/content/base/test/Makefile.in
index 404a05c..9e92c76 100644
--- a/content/base/test/Makefile.in
+++ b/content/base/test/Makefile.in
@@ -299,6 +299,7 @@ _TEST_FILES = 	test_bug5141.html \
 		test_bug444322.html \
 		bug444322.txt \
 		bug444322.js \
+		test_bug455472.html \
 		test_bug455629.html \
 		bug455629-helper.svg \
 		test_bug473162-1.html \
diff --git a/content/base/test/test_bug455472.html b/content/base/test/test_bug455472.html
new file mode 100644
index 0000000..fddbd28
--- /dev/null
+++ b/content/base/test/test_bug455472.html
@@ -0,0 +1,42 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=455472
+-->
+<head>
+  <title>Test for Bug 455472</title>
+  <script type=""""application/javascript"""" src=""""/MochiKit/packed.js""""></script>
+  <script type=""""application/javascript"""" src=""""/tests/SimpleTest/SimpleTest.js""""></script>
+  <link rel=""""stylesheet"""" type=""""text/css"""" href=""""/tests/SimpleTest/test.css""""/>
+</head>
+<body>
+<a target=""""_blank"""" href=""""https://bugzilla.mozilla.org/show_bug.cgi?id=455472"""">Mozilla Bug 455472</a>
+<p id=""""display""""></p>
+<script>
+  var ran = [ false, false, false, false, false ];
+</script>
+<div id=""""content"""" style=""""display: none"""">
+  <iframe src=""""data:text/html,<script>parent.ran[0]=true</script>""""></iframe>
+  <object type=""""text/html"""" data=""""data:text/html,<script>parent.ran[1]=true</script>""""></object>
+  <embed type=""""image/svg+xml"""" src=""""data:image/svg+xml,<svg%20xmlns='http://www.w3.org/2000/svg'%20onload='parent.ran[2]=true'/>"""">
+  <object type=""""text/html"""" data=""""data:application/octet-stream,<script>parent.ran[3]=true</script>""""></object>
+  <embed type=""""image/svg+xml"""" src=""""data:application/octet-stream,<svg%20xmlns='http://www.w3.org/2000/svg'%20onload='parent.ran[4]=true'/>"""">
+</div>
+<pre id=""""test"""">
+<script type=""""application/javascript"""">
+
+/** Test for Bug 455472 **/
+SimpleTest.waitForExplicitFinish();
+addLoadEvent(function() {
+  var expected = [ true, true, true, false, false ];
+  is (expected.length, ran.length, """"Length mismatch"""");
+  for (var i = 0; i < expected.length; ++i) {
+    is(ran[i], expected[i],
+       """"Unexpected behavior in object """" + i + """" (0-based)"""");
+  }
+  SimpleTest.finish();
+});
+</script>
+</pre>
+</body>
+</html>"""
814622b432fb1075f494f7c3b7c678dc256a3255,37013,487872,Jim Mathies,"Bug 487872 - nsAuthSSPI patch. r=wtc, sr=bz.
",1257372744,"""diff --git a/extensions/auth/nsAuthSSPI.cpp b/extensions/auth/nsAuthSSPI.cpp
index 2933f10..306353b 100644
--- a/extensions/auth/nsAuthSSPI.cpp
+++ b/extensions/auth/nsAuthSSPI.cpp
@@ -233,8 +233,8 @@ nsAuthSSPI::Init(const char *serviceName,
 
     // if we're configured for SPNEGO (Negotiate) or Kerberos, then it's critical 
     // that the caller supply a service name to be used.
-    if (mPackage != PACKAGE_TYPE_NTLM)
-        NS_ENSURE_TRUE(serviceName && *serviceName, NS_ERROR_INVALID_ARG);
+    // For NTLM, the service principal name can no longer be null. (Bug 487872)
+    NS_ENSURE_TRUE(serviceName && *serviceName, NS_ERROR_INVALID_ARG);
 
     nsresult rv;
 
@@ -247,13 +247,11 @@ nsAuthSSPI::Init(const char *serviceName,
     SEC_WCHAR *package;
 
     package = (SEC_WCHAR *) pTypeName[(int)mPackage];
-    if (mPackage != PACKAGE_TYPE_NTLM)
-    {
-        rv = MakeSN(serviceName, mServiceName);
-        if (NS_FAILED(rv))
-            return rv;
-        mServiceFlags = serviceFlags;
-    }
+    rv = MakeSN(serviceName, mServiceName);
+    if (NS_FAILED(rv))
+        return rv;
+
+    mServiceFlags = serviceFlags;
 
     SECURITY_STATUS rc;
 
@@ -338,11 +336,7 @@ nsAuthSSPI::GetNextToken(const void *inToken,
     memset(ob.pvBuffer, 0, ob.cbBuffer);
 
     NS_ConvertUTF8toUTF16 wSN(mServiceName);
-    SEC_WCHAR *sn;
-    if (mPackage == PACKAGE_TYPE_NTLM)
-        sn = NULL;
-    else
-        sn = (SEC_WCHAR *) wSN.get();
+    SEC_WCHAR *sn = (SEC_WCHAR *) wSN.get();
 
     rc = (sspi->InitializeSecurityContextW)(&mCred,
                                             ctxIn,
diff --git a/netwerk/protocol/http/src/nsHttpNTLMAuth.cpp b/netwerk/protocol/http/src/nsHttpNTLMAuth.cpp
index b95255c..7416940 100644
--- a/netwerk/protocol/http/src/nsHttpNTLMAuth.cpp
+++ b/netwerk/protocol/http/src/nsHttpNTLMAuth.cpp
@@ -304,8 +304,19 @@ nsHttpNTLMAuth::GenerateCredentials(nsIHttpChannel  *httpChannel,
 
     // initial challenge
     if (PL_strcasecmp(challenge, """"NTLM"""") == 0) {
+        // NTLM service name format is 'HTTP@host' for both http and https
+        nsCOMPtr<nsIURI> uri;
+        rv = httpChannel->GetURI(getter_AddRefs(uri));
+        if (NS_FAILED(rv))
+            return rv;
+        nsCAutoString serviceName, host;
+        rv = uri->GetAsciiHost(host);
+        if (NS_FAILED(rv))
+            return rv;
+        serviceName.AppendLiteral(""""HTTP@"""");
+        serviceName.Append(host);
         // initialize auth module
-        rv = module->Init(nsnull, nsIAuthModule::REQ_DEFAULT, domain, user, pass);
+        rv = module->Init(serviceName.get(), nsIAuthModule::REQ_DEFAULT, domain, user, pass);
         if (NS_FAILED(rv))
             return rv;
 """
73753d27c4ea287d70059f6c9264fa4c0c977bce,39642,452093,Brandon Sterne,"Bug 452093 - [r=bzbarsky r=joe]
",1265925540,"""diff --git a/modules/libpr0n/src/imgRequest.cpp b/modules/libpr0n/src/imgRequest.cpp
index 02de187..a1df946 100644
--- a/modules/libpr0n/src/imgRequest.cpp
+++ b/modules/libpr0n/src/imgRequest.cpp
@@ -68,6 +68,8 @@
 #include """"nsString.h""""
 #include """"nsXPIDLString.h""""
 #include """"plstr.h"""" // PL_strcasestr(...)
+#include """"nsNetUtil.h""""
+#include """"nsIProtocolHandler.h""""
 
 static PRBool gDecodeOnDraw = PR_FALSE;
 static PRBool gDiscardable = PR_FALSE;
@@ -1197,6 +1199,18 @@ imgRequest::OnChannelRedirect(nsIChannel *oldChannel, nsIChannel *newChannel, PR
     mKeyURI->GetSpec(oldspec);
   LOG_MSG_WITH_PARAM(gImgLog, """"imgRequest::OnChannelRedirect"""", """"old"""", oldspec.get());
 
+  // make sure we have a protocol that returns data rather than opens
+  // an external application, e.g. mailto:
+  nsCOMPtr<nsIURI> uri;
+  newChannel->GetURI(getter_AddRefs(uri));
+  PRBool doesNotReturnData = PR_FALSE;
+  rv = NS_URIChainHasFlags(uri, nsIProtocolHandler::URI_DOES_NOT_RETURN_DATA,
+                           &doesNotReturnData);
+  if (NS_FAILED(rv))
+    return rv;
+  if (doesNotReturnData)
+    return NS_ERROR_ABORT;
+
   nsCOMPtr<nsIURI> newURI;
   newChannel->GetOriginalURI(getter_AddRefs(newURI));
   nsCAutoString newspec;"""
23a6265aa2dc76cfa9c113db2023df2fac261415,39928,474536,Boris Zbarsky,"Backed out changeset 6ee269c6c118 (test for bug 474536) because it hangs on Tinderbox

--HG--
extra : rebase_source : 4a94234dc481caff6e147082e0f1c5a13602e84b
",1251912858,"""diff --git a/netwerk/test/unit/data/bug474536/foo.jar b/netwerk/test/unit/data/bug474536/foo.jar
deleted file mode 100644
index de20c50..0000000
Binary files a/netwerk/test/unit/data/bug474536/foo.jar and /dev/null differ
diff --git a/netwerk/test/unit/data/bug474536/foo.jar^headers^ b/netwerk/test/unit/data/bug474536/foo.jar^headers^
deleted file mode 100644
index f7ae703..0000000
--- a/netwerk/test/unit/data/bug474536/foo.jar^headers^
+++ /dev/null
@@ -1,2 +0,0 @@
-Content-type: application/java-archive
-Content-Disposition: attachment; filename=foo.jar
diff --git a/netwerk/test/unit/test_bug474536.js b/netwerk/test/unit/test_bug474536.js
deleted file mode 100644
index 6a3ac35..0000000
--- a/netwerk/test/unit/test_bug474536.js
+++ /dev/null
@@ -1,90 +0,0 @@
-
-do_load_httpd_js();
-
-var httpserv = null;
-
-var _CSvc = null;
-function get_cache_service() 
-{
-  if (_CSvc)
-    return _CSvc;
-
-  return _CSvc = Cc[""""@mozilla.org/network/cache-service;1""""].
-                 getService(Ci.nsICacheService);
-}
-
-function setup_server()
-{
-  httpserv = new nsHttpServer();
-  var dataDir = do_get_file(""""data/bug474536/"""");
-  httpserv.registerDirectory(""""/"""", dataDir);
-  httpserv.start(4444);
-}
-
-function makeJARChannel(url)
-{
-  var ios = Cc[""""@mozilla.org/network/io-service;1""""].getService(Ci.nsIIOService);
-  return ios.newChannel(url, null, null).QueryInterface(Ci.nsIJARChannel);
-}
-
-var testNumber = 1;
-
-var listener = {
-  // In all test cases, the Content-disposition header returned during the HTTP
-  // request should be visible in the Channel (HTTP, JAR, or nested JAR)
-  onStartRequest: function test_onStartR(request, ctx) {
-    try {
-      do_check_true(request instanceof Ci.nsIPropertyBag);
-      try {
-        dispo = request.getProperty(""""content-disposition""""); 
-      } catch (e) {
-        do_throw(""""content-disposition not present!"""");
-      }
-      do_check_eq(request.getProperty(""""content-disposition""""),
-                                      """"attachment; filename=foo.jar"""");
-    } catch (e) {
-      do_throw(""""unexpected exception: """" + e);
-    }
-    throw Components.results.NS_ERROR_ABORT;
-  },
-  onDataAvailable: function(request, context, stream, offset, count) {
-    throw Components.results.NS_ERROR_UNEXPECTED; 
-  },
-  onStopRequest: function test_onStopR(request, ctx, status) {
-    switch (testNumber) {
-      case 1:
-        run_test2_JAR_JAR_HTTP();
-        break;
-      case 2:
-        httpserv.stop();
-        break;
-      default:
-        do_throw(""""Inconceivable!"""");
-    }
-    testNumber++;
-    do_test_finished();
-  }
-};
-
-function run_test()
-{
-  setup_server(); 
-
-  test1_JAR_HTTP();
-}
-
-function test1_JAR_HTTP() {
-  var jarChannel1 = 
-    makeJARChannel(""""jar:http://localhost:4444/foo.jar!/foo.html"""");
-  jarChannel1.asyncOpen(listener, null);
-  do_test_pending();
-}
-
-function run_test2_JAR_JAR_HTTP()
-{
-  var jarChannel1 = 
-    makeJARChannel(""""jar:jar:http://localhost:4444/foo.jar!/bar.jar!/bar.html"""");
-  jarChannel1.asyncOpen(listener, null);
-  do_test_pending();
-}
-"""
0ca6603d9c25fe0d349f726cde2c749287c40673,39936,474536,Jason Duell,"Adding test for bug 474536.  r=dcamp sr=bzbarsky
",1251905593,"""diff --git a/netwerk/test/unit/data/bug474536/foo.jar b/netwerk/test/unit/data/bug474536/foo.jar
new file mode 100644
index 0000000..de20c50
Binary files /dev/null and b/netwerk/test/unit/data/bug474536/foo.jar differ
diff --git a/netwerk/test/unit/data/bug474536/foo.jar^headers^ b/netwerk/test/unit/data/bug474536/foo.jar^headers^
new file mode 100644
index 0000000..f7ae703
--- /dev/null
+++ b/netwerk/test/unit/data/bug474536/foo.jar^headers^
@@ -0,0 +1,2 @@
+Content-type: application/java-archive
+Content-Disposition: attachment; filename=foo.jar
diff --git a/netwerk/test/unit/test_bug474536.js b/netwerk/test/unit/test_bug474536.js
new file mode 100644
index 0000000..6a3ac35
--- /dev/null
+++ b/netwerk/test/unit/test_bug474536.js
@@ -0,0 +1,90 @@
+
+do_load_httpd_js();
+
+var httpserv = null;
+
+var _CSvc = null;
+function get_cache_service() 
+{
+  if (_CSvc)
+    return _CSvc;
+
+  return _CSvc = Cc[""""@mozilla.org/network/cache-service;1""""].
+                 getService(Ci.nsICacheService);
+}
+
+function setup_server()
+{
+  httpserv = new nsHttpServer();
+  var dataDir = do_get_file(""""data/bug474536/"""");
+  httpserv.registerDirectory(""""/"""", dataDir);
+  httpserv.start(4444);
+}
+
+function makeJARChannel(url)
+{
+  var ios = Cc[""""@mozilla.org/network/io-service;1""""].getService(Ci.nsIIOService);
+  return ios.newChannel(url, null, null).QueryInterface(Ci.nsIJARChannel);
+}
+
+var testNumber = 1;
+
+var listener = {
+  // In all test cases, the Content-disposition header returned during the HTTP
+  // request should be visible in the Channel (HTTP, JAR, or nested JAR)
+  onStartRequest: function test_onStartR(request, ctx) {
+    try {
+      do_check_true(request instanceof Ci.nsIPropertyBag);
+      try {
+        dispo = request.getProperty(""""content-disposition""""); 
+      } catch (e) {
+        do_throw(""""content-disposition not present!"""");
+      }
+      do_check_eq(request.getProperty(""""content-disposition""""),
+                                      """"attachment; filename=foo.jar"""");
+    } catch (e) {
+      do_throw(""""unexpected exception: """" + e);
+    }
+    throw Components.results.NS_ERROR_ABORT;
+  },
+  onDataAvailable: function(request, context, stream, offset, count) {
+    throw Components.results.NS_ERROR_UNEXPECTED; 
+  },
+  onStopRequest: function test_onStopR(request, ctx, status) {
+    switch (testNumber) {
+      case 1:
+        run_test2_JAR_JAR_HTTP();
+        break;
+      case 2:
+        httpserv.stop();
+        break;
+      default:
+        do_throw(""""Inconceivable!"""");
+    }
+    testNumber++;
+    do_test_finished();
+  }
+};
+
+function run_test()
+{
+  setup_server(); 
+
+  test1_JAR_HTTP();
+}
+
+function test1_JAR_HTTP() {
+  var jarChannel1 = 
+    makeJARChannel(""""jar:http://localhost:4444/foo.jar!/foo.html"""");
+  jarChannel1.asyncOpen(listener, null);
+  do_test_pending();
+}
+
+function run_test2_JAR_JAR_HTTP()
+{
+  var jarChannel1 = 
+    makeJARChannel(""""jar:jar:http://localhost:4444/foo.jar!/bar.jar!/bar.html"""");
+  jarChannel1.asyncOpen(listener, null);
+  do_test_pending();
+}
+"""
f097171825933e06dbad8f5c381c943625d77744,40251,488995,Bob Clary,"bug 488995 - JavaScript Test by PenPal.
",1250580600,"""diff --git a/js/tests/js1_5/extensions/regress-488995.js b/js/tests/js1_5/extensions/regress-488995.js
new file mode 100755
index 0000000..f3ddc85
--- /dev/null
+++ b/js/tests/js1_5/extensions/regress-488995.js
@@ -0,0 +1,79 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is JavaScript Engine testing utilities.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): PenPal
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var gTestfile = 'regress-488995.js';
+//-----------------------------------------------------------------------------
+var BUGNUMBER = 488995;
+var summary = 'Do not crash with watch, __defineSetter__ on svg';
+var actual = '';
+var expect = '';
+
+
+//-----------------------------------------------------------------------------
+test();
+//-----------------------------------------------------------------------------
+
+function test()
+{
+  enterFunc ('test');
+  printBugNumber(BUGNUMBER);
+  printStatus (summary);
+
+  if (typeof document == 'undefined')
+  {
+    print('Test skipped: requires browser.');
+  }
+  else
+  {
+    try
+    {
+      var o=document.createElementNS(""""http://www.w3.org/2000/svg"""", """"svg"""");
+      var p=o.y;
+      p.watch('animVal', function(id, oldvar, newval) {} );
+      p.type='xxx';
+      p.__defineSetter__('animVal', function() {});
+      p.animVal=0;
+    }
+    catch(ex)
+    {
+    }
+  }
+
+  reportCompare(expect, actual, summary);
+
+  exitFunc ('test');
+}"""
52b181540b9937bc1af40af64390c7911f335cac,40592,441360,Mats Palmgren,"Re-enable crash test for bug 441360 on gtk2 platforms. b=455463 r=me
",1250961325,"""diff --git a/gfx/thebes/crashtests/crashtests.list b/gfx/thebes/crashtests/crashtests.list
index 9e1ec4a..48743f2 100644
--- a/gfx/thebes/crashtests/crashtests.list
+++ b/gfx/thebes/crashtests/crashtests.list
@@ -50,10 +50,10 @@ load 421393-1.html
 load 421813-1.html
 load 423270-1.html
 load 429899-1.html
+load 441360.html
 load 463307-1.html
 load 467703-1.xhtml
 load 467873-1.html
 load 470418-1.html
-skip-if(MOZ_WIDGET_TOOLKIT==""""gtk2"""") load 441360.html # filed bug 455463 for gtk2
 load 487549-1.html
 load 490777-1.html"""
637c9c7d49cfa8347896c1a116c43a6812c8bab6,40807,476547,Robert O'Callahan,"Bug 476547. Make lquote and rquote actually work, especially when there are dynamic changes, by finding the correct text frames to modify and notifying the text frame that the DOM text has changed. r=karlt
",1254889721,"""diff --git a/layout/mathml/crashtests/476547-1.xhtml b/layout/mathml/crashtests/476547-1.xhtml
new file mode 100644
index 0000000..0cece35
--- /dev/null
+++ b/layout/mathml/crashtests/476547-1.xhtml
@@ -0,0 +1,5 @@
+<html xmlns=""""http://www.w3.org/1999/xhtml"""" style=""""quotes: '&lt;1&gt;' '';"""">
+<body onload=""""document.getElementById('ms').setAttribute('lquote', '');"""" style=""""direction: rtl;"""">
+<span><ms id=""""ms"""" xmlns=""""http://www.w3.org/1998/Math/MathML""""><mstyle/></ms></span>
+</body>
+</html>
diff --git a/layout/mathml/crashtests/crashtests.list b/layout/mathml/crashtests/crashtests.list
index 20b5d70..2920040 100644
--- a/layout/mathml/crashtests/crashtests.list
+++ b/layout/mathml/crashtests/crashtests.list
@@ -47,3 +47,4 @@ load 420420-1.xhtml
 load 443089-1.xhtml
 load 463763-1.xhtml
 load 463763-2.xhtml
+load 476547-1.xhtml
diff --git a/layout/mathml/nsMathMLTokenFrame.cpp b/layout/mathml/nsMathMLTokenFrame.cpp
index 48fbffe..829e073 100644
--- a/layout/mathml/nsMathMLTokenFrame.cpp
+++ b/layout/mathml/nsMathMLTokenFrame.cpp
@@ -142,7 +142,7 @@ nsMathMLTokenFrame::SetInitialChildList(nsIAtom*        aListName,
   if (NS_FAILED(rv))
     return rv;
 
-  SetQuotes();
+  SetQuotes(PR_FALSE);
   ProcessTextData();
   return rv;
 }
@@ -259,7 +259,7 @@ nsMathMLTokenFrame::AttributeChanged(PRInt32         aNameSpaceID,
 {
   if (nsGkAtoms::lquote_ == aAttribute ||
       nsGkAtoms::rquote_ == aAttribute) {
-    SetQuotes();
+    SetQuotes(PR_TRUE);
   }
 
   return nsMathMLContainerFrame::
@@ -378,57 +378,44 @@ nsMathMLTokenFrame::SetTextStyle()
 // So the main idea in this code is to see if there are lquote and 
 // rquote attributes. If these are there, we ovewrite the default
 // quotes in the text frames.
+// XXX this is somewhat bogus, we probably should map lquote and rquote
+// to 'content' style rules
 //
 // But what if the mathml.css file wasn't loaded? 
 // We also check that we are not relying on null pointers...
 
 static void
-SetQuote(nsIFrame*       aFrame, 
-         nsString&       aValue)
+SetQuote(nsIFrame* aFrame, nsString& aValue, PRBool aNotify)
 {
-  nsIFrame* textFrame;
-  do {
-    // walk down the hierarchy of first children because they could be wrapped
-    textFrame = aFrame->GetFirstChild(nsnull);
-    if (textFrame) {
-      if (textFrame->GetType() == nsGkAtoms::textFrame)
-        break;
-    }
-    aFrame = textFrame;
-  } while (textFrame);
-  if (textFrame) {
-    nsIContent* quoteContent = textFrame->GetContent();
-    if (quoteContent && quoteContent->IsNodeOfType(nsINode::eTEXT)) {
-      quoteContent->SetText(aValue, PR_FALSE); // no notify since we don't want a reflow yet
-    }
-  }
+  if (!aFrame)
+    return;
+
+  nsIFrame* textFrame = aFrame->GetFirstChild(nsnull);
+  if (!textFrame)
+    return;
+
+  nsIContent* quoteContent = textFrame->GetContent();
+  if (!quoteContent->IsNodeOfType(nsINode::eTEXT))
+    return;
+
+  quoteContent->SetText(aValue, aNotify);
 }
 
 void
-nsMathMLTokenFrame::SetQuotes()
+nsMathMLTokenFrame::SetQuotes(PRBool aNotify)
 {
   if (mContent->Tag() != nsGkAtoms::ms_)
     return;
 
-  nsIFrame* rightFrame = nsnull;
-  nsIFrame* baseFrame = nsnull;
-  nsIFrame* leftFrame = mFrames.FirstChild();
-  if (leftFrame)
-    baseFrame = leftFrame->GetNextSibling();
-  if (baseFrame)
-    rightFrame = baseFrame->GetNextSibling();
-  if (!leftFrame || !baseFrame || !rightFrame)
-    return;
-
   nsAutoString value;
   // lquote
   if (GetAttribute(mContent, mPresentationData.mstyle,
                    nsGkAtoms::lquote_, value)) {
-    SetQuote(leftFrame, value);
+    SetQuote(nsLayoutUtils::GetBeforeFrame(this), value, aNotify);
   }
   // rquote
   if (GetAttribute(mContent, mPresentationData.mstyle,
                    nsGkAtoms::rquote_, value)) {
-    SetQuote(rightFrame, value);
+    SetQuote(nsLayoutUtils::GetAfterFrame(this), value, aNotify);
   }
 }
diff --git a/layout/mathml/nsMathMLTokenFrame.h b/layout/mathml/nsMathMLTokenFrame.h
index a2ef8fd..e5d3603 100644
--- a/layout/mathml/nsMathMLTokenFrame.h
+++ b/layout/mathml/nsMathMLTokenFrame.h
@@ -102,7 +102,7 @@ protected:
   PRBool SetTextStyle();
 
   // helper to set the quotes of <ms>
-  void SetQuotes();
+  void SetQuotes(PRBool aNotify);
 };
 
 #endif /* nsMathMLTokentFrame_h___ */
diff --git a/layout/reftests/mathml/quotes-1-ref.xhtml b/layout/reftests/mathml/quotes-1-ref.xhtml
new file mode 100644
index 0000000..6afae30
--- /dev/null
+++ b/layout/reftests/mathml/quotes-1-ref.xhtml
@@ -0,0 +1,9 @@
+<html xmlns=""""http://www.w3.org/1999/xhtml"""">
+<body>
+<p>:L_R</p>
+<p>:L_&#x201D;</p>
+<p>:&#x201C;_R</p>
+<p>:L_&#x201D;</p>
+<p>:&#x201C;_R</p>
+</body>
+</html>
diff --git a/layout/reftests/mathml/quotes-1.xhtml b/layout/reftests/mathml/quotes-1.xhtml
new file mode 100644
index 0000000..4f175b2
--- /dev/null
+++ b/layout/reftests/mathml/quotes-1.xhtml
@@ -0,0 +1,23 @@
+<html xmlns=""""http://www.w3.org/1999/xhtml"""" class=""""reftest-wait"""">
+<body>
+<p>:<ms xmlns=""""http://www.w3.org/1998/Math/MathML"""" lquote=""""L"""" rquote=""""R"""">_</ms></p>
+<p>:<ms id=""""m1"""" xmlns=""""http://www.w3.org/1998/Math/MathML"""">_</ms></p>
+<p>:<ms id=""""m2"""" xmlns=""""http://www.w3.org/1998/Math/MathML"""">_</ms></p>
+<p>:<ms id=""""m3"""" xmlns=""""http://www.w3.org/1998/Math/MathML"""" lquote=""""_"""">_</ms></p>
+<p>:<ms id=""""m4"""" xmlns=""""http://www.w3.org/1998/Math/MathML"""" rquote=""""_"""">_</ms></p>
+<script>
+function doTest() {
+  var m1 = document.getElementById(""""m1"""");
+  m1.setAttribute(""""lquote"""", """"L"""");
+  var m2 = document.getElementById(""""m2"""");
+  m2.setAttribute(""""rquote"""", """"R"""");
+  var m3 = document.getElementById(""""m3"""");
+  m3.setAttribute(""""lquote"""", """"L"""");
+  var m4 = document.getElementById(""""m4"""");
+  m4.setAttribute(""""rquote"""", """"R"""");
+  document.documentElement.removeAttribute('class');
+}
+window.addEventListener(""""MozReftestInvalidate"""", doTest, false);
+</script>
+</body>
+</html>
diff --git a/layout/reftests/mathml/reftest.list b/layout/reftests/mathml/reftest.list
index 0a99861..7c833b5 100644
--- a/layout/reftests/mathml/reftest.list
+++ b/layout/reftests/mathml/reftest.list
@@ -1,8 +1,9 @@
 == dynamic-mi.xhtml dynamic-mi-ref.xhtml
 == mi-mathvariant-1.xhtml mi-mathvariant-1-ref.xhtml
 == mi-mathvariant-2.xhtml mi-mathvariant-2-ref.xhtml
-== table-width-1.xhtml table-width-1-ref.xhtml
-== overbar-width-1.xhtml overbar-width-1-ref.xhtml
-== underbar-width-1.xhtml underbar-width-1-ref.xhtml
 != non-spacing-accent-1.xhtml non-spacing-accent-1-ref.xhtml
+== overbar-width-1.xhtml overbar-width-1-ref.xhtml
+== quotes-1.xhtml quotes-1-ref.xhtml
 != stretchy-underbar-1.xhtml stretchy-underbar-1-ref.xhtml 
+== table-width-1.xhtml table-width-1-ref.xhtml
+== underbar-width-1.xhtml underbar-width-1-ref.xhtml"""
58c0e59a7593504b2c4bd6ebae21577f7da071f3,41119,451898,Boris Zbarsky,"Bug 451898.  When stopping an error page load, make sure to null out mLSHE.  r=biesi
",1248889168,"""diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
index 0f552fe..bbcffad 100644
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -3952,6 +3952,12 @@ nsDocShell::Stop(PRUint32 aStopFlags)
     // Revoke any pending event related to content viewer restoration
     mRestorePresentationEvent.Revoke();
 
+    if (mLoadType == LOAD_ERROR_PAGE && mLSHE) {
+        // Since error page loads never unset mLSHE, do so now
+        SetHistoryEntry(&mOSHE, mLSHE);
+        SetHistoryEntry(&mLSHE, nsnull);
+    }
+
     if (nsIWebNavigation::STOP_CONTENT & aStopFlags) {
         // Stop the document loading
         if (mContentViewer)"""
e1a1d7932863fc1013207b443164578a9f80ab46,43332,498897,Peter Van der Beken,"Testcase for bug 498897.

--HG--
extra : rebase_source : a70554700d208221bfa8c7349cb11f879341e317
",1245429109,"""diff --git a/content/base/test/Makefile.in b/content/base/test/Makefile.in
index 91f09d0..d36484a 100644
--- a/content/base/test/Makefile.in
+++ b/content/base/test/Makefile.in
@@ -313,6 +313,10 @@ _TEST_FILES = 	test_bug5141.html \
 		file_htmlserializer_ipv6.html \
 		file_htmlserializer_ipv6_out.html \
 		test_bug498433.html \
+		test_bug498897.html \
+		file_bug498897.html \
+		file_bug498897.html^headers^ \
+		file_bug498897.css \
 		$(NULL)
 # Disabled; see bug 492181
 #		test_plugin_freezing.html
diff --git a/content/base/test/file_bug498897.css b/content/base/test/file_bug498897.css
new file mode 100644
index 0000000..84beffd
--- /dev/null
+++ b/content/base/test/file_bug498897.css
@@ -0,0 +1 @@
+body { background: orange; }
diff --git a/content/base/test/file_bug498897.html b/content/base/test/file_bug498897.html
new file mode 100644
index 0000000..b0d36f4
--- /dev/null
+++ b/content/base/test/file_bug498897.html
@@ -0,0 +1,23 @@
+<html>
+<head>
+	<title>Testcase for bug 498897</title>
+<script type=""""application/javascript"""" language=""""javascript"""">
+<!--
+function test()
+{
+  var hadException = false;
+  try {
+    document.createComment('a');
+  }
+  catch (e) {
+    hadException = true;
+  }
+  parent.ok(!hadException, """"Shouldn't have got an exception!"""");
+  parent.testFinished();
+}
+//-->
+</script>
+</head>
+<body onload=""""test();"""">
+</body>
+</html>
diff --git a/content/base/test/file_bug498897.html^headers^ b/content/base/test/file_bug498897.html^headers^
new file mode 100644
index 0000000..09b46ca4
--- /dev/null
+++ b/content/base/test/file_bug498897.html^headers^
@@ -0,0 +1 @@
+Link: <file_bug498897.css>; rel=stylesheet
diff --git a/content/base/test/test_bug498897.html b/content/base/test/test_bug498897.html
new file mode 100644
index 0000000..839a35a
--- /dev/null
+++ b/content/base/test/test_bug498897.html
@@ -0,0 +1,108 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=498897
+-->
+<head>
+  <title>Test for Bug 498897</title>
+  <script type=""""application/javascript"""" src=""""/MochiKit/packed.js""""></script>
+  <script type=""""application/javascript"""" src=""""/tests/SimpleTest/SimpleTest.js""""></script>
+  <link rel=""""stylesheet"""" type=""""text/css"""" href=""""/tests/SimpleTest/test.css""""/>
+</head>
+<body>
+<a target=""""_blank"""" href=""""https://bugzilla.mozilla.org/show_bug.cgi?id=498897"""">Mozilla Bug 498897</a>
+<p id=""""display""""><iframe id=""""testframe""""></iframe></p>
+<div id=""""content"""" style=""""display: none"""">
+  
+</div>
+<pre id=""""test"""">
+<script type=""""application/javascript"""">
+
+/** Test for Bug 498897 **/
+
+var checkedLoad = false;
+
+netscape.security.PrivilegeManager.enablePrivilege(""""UniversalXPConnect"""");
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+
+// Content policy / factory implementation for the test
+var policyID = Components.ID(""""{65944d64-2390-422e-bea3-80d0af7f69ef}"""");
+var policyName = """"@mozilla.org/498897_testpolicy;1"""";
+var policy = {
+  // nsISupports implementation
+  QueryInterface: function(iid) {
+    netscape.security.PrivilegeManager.enablePrivilege(""""UniversalXPConnect"""");
+
+    if (iid.equals(Ci.nsISupports) ||
+        iid.equals(Ci.nsIFactory) ||
+        iid.equals(Ci.nsIContentPolicy))
+      return this;
+
+    throw Components.results.NS_ERROR_NO_INTERFACE;
+  },
+
+  // nsIFactory implementation
+  createInstance: function(outer, iid) {
+    return this.QueryInterface(iid);
+  },
+
+  // nsIContentPolicy implementation
+  shouldLoad: function(contentType, contentLocation, requestOrigin, context,
+                       mimeTypeGuess, extra) {
+    netscape.security.PrivilegeManager.enablePrivilege(""""UniversalXPConnect"""");
+
+    if (contentLocation instanceof Ci.nsIURL &&
+        contentLocation.fileName == """"file_bug498897.css"""" &&
+        requestOrigin instanceof Ci.nsIURL &&
+        requestOrigin.fileName == """"file_bug498897.html"""") {
+      checkedLoad = true;
+    }
+
+    return Ci.nsIContentPolicy.ACCEPT;
+  },
+
+  shouldProcess: function(contentType, contentLocation, requestOrigin, context,
+                          mimeTypeGuess, extra) {
+    netscape.security.PrivilegeManager.enablePrivilege(""""UniversalXPConnect"""");
+
+    return Ci.nsIContentPolicy.ACCEPT;
+  }
+}
+
+var componentManager = Components.manager
+                                 .QueryInterface(Ci.nsIComponentRegistrar);
+componentManager.registerFactory(policyID, """"Test content policy for bug 498897"""",
+                                 policyName, policy);
+
+var categoryManager =
+  Cc[""""@mozilla.org/categorymanager;1""""].getService(Ci.nsICategoryManager);
+categoryManager.addCategoryEntry(""""content-policy"""", policyName, policyName,
+                                 false, true);
+
+function testFinished()
+{
+  netscape.security.PrivilegeManager.enablePrivilege(""""UniversalXPConnect"""");
+
+  ok(checkedLoad, """"Content policy didn't get called!"""");
+
+  categoryManager.deleteCategoryEntry(""""content-policy"""", policyName, false);
+
+  setTimeout(function() {
+    netscape.security.PrivilegeManager.enablePrivilege(""""UniversalXPConnect"""");
+
+    componentManager.unregisterFactory(policyID, policy);
+
+    SimpleTest.finish();
+  }, 0);
+}
+
+SimpleTest.waitForExplicitFinish();
+
+document.getElementById(""""testframe"""").src = """"file_bug498897.html"""";
+
+</script>
+</pre>
+</body>
+</html>"""
82f9000307da0f895db958bfc99d346e43863647,43696,476049,Bob Clary,"bug 476049 - JavaScript Test by Igor Bukanov.
",1243899666,"""diff --git a/js/tests/js1_5/Regress/regress-476049.js b/js/tests/js1_5/Regress/regress-476049.js
new file mode 100644
index 0000000..144d8a0
--- /dev/null
+++ b/js/tests/js1_5/Regress/regress-476049.js
@@ -0,0 +1,76 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is JavaScript Engine testing utilities.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Igor Bukanov
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var gTestfile = 'regress-476049.js';
+//-----------------------------------------------------------------------------
+var BUGNUMBER = 476049;
+var summary = 'JSOP_DEFVAR enables gvar optimization for non-permanent properties';
+var actual = '';
+var expect = '';
+
+printBugNumber(BUGNUMBER);
+printStatus (summary);
+
+// This test requires either two input files in the shell or two 
+// script blocks in the browser. 
+
+if (typeof window == 'undefined')
+{
+  print(expect = actual = 'Test skipped');
+}
+else
+{
+  document.write(
+    '<script type=""""text/javascript"""">' +
+    'for (var i = 0; i != 1000; ++i)' + 
+    '  this[""""a""""+i] = 0;' + 
+    'eval(""""var x"""");' + 
+    'for (var i = 0; i != 1000; ++i)' + 
+    '  delete this[""""a""""+i];' + 
+    '<\/script>'
+    );
+
+  document.write(
+    '<script type=""""text/javascript"""">' +
+    'var x;' + 
+    'eval(""""delete x;"""");' +
+    'x={};' +
+    '<\/script>'
+    );
+}
+
+reportCompare(expect, actual, summary);"""
4b4b2f24479466a7edcb0be1a4fc5d38c4f7ec28,44747,491801,Daniel Veditz,"bug 491801 the no_auth URLparser needs to enforce no_auth, r=jduell, sr=biesi
",1242530495,"""diff --git a/netwerk/base/src/nsURLParsers.cpp b/netwerk/base/src/nsURLParsers.cpp
index 50ac921..3dbd11e 100644
--- a/netwerk/base/src/nsURLParsers.cpp
+++ b/netwerk/base/src/nsURLParsers.cpp
@@ -388,6 +388,17 @@ nsBaseURLParser::ParseFileName(const char *filename, PRInt32 filenameLen,
 // nsNoAuthURLParser implementation
 //----------------------------------------------------------------------------
 
+NS_IMETHODIMP
+nsNoAuthURLParser::ParseAuthority(const char *auth, PRInt32 authLen,
+                                 PRUint32 *usernamePos, PRInt32 *usernameLen,
+                                 PRUint32 *passwordPos, PRInt32 *passwordLen,
+                                 PRUint32 *hostnamePos, PRInt32 *hostnameLen,
+                                 PRInt32 *port)
+{
+    NS_NOTREACHED(""""Shouldn't parse auth in a NoAuthURL!"""");
+    return NS_ERROR_UNEXPECTED;
+}
+
 void
 nsNoAuthURLParser::ParseAfterScheme(const char *spec, PRInt32 specLen,
                                     PRUint32 *authPos, PRInt32 *authLen,
@@ -419,11 +430,11 @@ nsNoAuthURLParser::ParseAfterScheme(const char *spec, PRInt32 specLen,
                 p = (const char *) memchr(spec + 2, '/', specLen - 2);
             }
             if (p) {
-                SET_RESULT(auth, 2, p - (spec + 2));
+                SET_RESULT(auth, 0, -1);
                 SET_RESULT(path, p - spec, specLen - (p - spec));
             }
             else {
-                SET_RESULT(auth, 2, specLen - 2);
+                SET_RESULT(auth, 0, -1);
                 SET_RESULT(path, 0, -1);
             }
             return;
diff --git a/netwerk/base/src/nsURLParsers.h b/netwerk/base/src/nsURLParsers.h
index 1da4c07..81f3b5d 100644
--- a/netwerk/base/src/nsURLParsers.h
+++ b/netwerk/base/src/nsURLParsers.h
@@ -70,7 +70,7 @@ protected:
 // eg. file:////foo/bar.txt   (UNC-filepath = \\foo\bar.txt)
 //
 // XXX except in this case:
-//     file://foo/bar.txt     (foo is authority)
+//     file://foo/bar.txt     (the authority """"foo""""  is ignored)
 //----------------------------------------------------------------------------
 
 class nsNoAuthURLParser : public nsBaseURLParser
@@ -83,6 +83,12 @@ public:
                              PRUint32 *, PRInt32 *);
 #endif
 
+    NS_IMETHOD ParseAuthority(const char *auth, PRInt32 authLen,
+                              PRUint32 *usernamePos, PRInt32 *usernameLen,
+                              PRUint32 *passwordPos, PRInt32 *passwordLen,
+                              PRUint32 *hostnamePos, PRInt32 *hostnameLen,
+                              PRInt32 *port);
+
     void ParseAfterScheme(const char *spec, PRInt32 specLen,
                           PRUint32 *authPos, PRInt32 *authLen,
                           PRUint32 *pathPos, PRInt32 *pathLen);"""
bca0b7a81c397d330bc74818d5f82b001f33815c,45316,488995,Igor Bukanov,"bug 488995 - fixing error reporting for getter-only properties. r=mrbkap sr=jst
",1240396748,"""diff --git a/js/src/jsobj.cpp b/js/src/jsobj.cpp
index e6cc8cc..55b0136 100644
--- a/js/src/jsobj.cpp
+++ b/js/src/jsobj.cpp
@@ -5987,6 +5987,21 @@ js_IsCallable(JSObject *obj, JSContext *cx)
     return callable;
 }
 
+void
+js_ReportGetterOnlyAssignment(JSContext *cx)
+{
+    JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
+                         JSMSG_GETTER_ONLY, NULL);
+}
+
+
+JS_FRIEND_API(JSBool)
+js_GetterOnlyPropertyStub(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+    js_ReportGetterOnlyAssignment(cx);
+    return JS_FALSE;
+}
+
 #ifdef DEBUG
 
 /*
diff --git a/js/src/jsobj.h b/js/src/jsobj.h
index f84c2cd..7cd33ac 100644
--- a/js/src/jsobj.h
+++ b/js/src/jsobj.h
@@ -854,6 +854,12 @@ js_ComputeFilename(JSContext *cx, JSStackFrame *caller,
 extern JSBool
 js_IsCallable(JSObject *obj, JSContext *cx);
 
+void
+js_ReportGetterOnlyAssignment(JSContext *cx);
+
+extern JS_FRIEND_API(JSBool)
+js_GetterOnlyPropertyStub(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
 #ifdef DEBUG
 JS_FRIEND_API(void) js_DumpChars(const jschar *s, size_t n);
 JS_FRIEND_API(void) js_DumpString(JSString *str);
diff --git a/js/src/jsscope.h b/js/src/jsscope.h
index 65348ef..5a68e26 100644
--- a/js/src/jsscope.h
+++ b/js/src/jsscope.h
@@ -375,8 +375,7 @@ js_SetSprop(JSContext* cx, JSScopeProperty* sprop, JSObject* obj, jsval* vp)
     }
 
     if (sprop->attrs & JSPROP_GETTER) {
-        JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
-                             JSMSG_GETTER_ONLY, NULL);
+        js_ReportGetterOnlyAssignment(cx);
         return JS_FALSE;
     }
 
diff --git a/js/src/xpconnect/src/XPCIDispatchExtension.cpp b/js/src/xpconnect/src/XPCIDispatchExtension.cpp
index eb500c6..7ad6326 100644
--- a/js/src/xpconnect/src/XPCIDispatchExtension.cpp
+++ b/js/src/xpconnect/src/XPCIDispatchExtension.cpp
@@ -295,18 +295,23 @@ JSBool XPCIDispatchExtension::DefineProperty(XPCCallContext & ccx,
     // Define the property on the object
     NS_ASSERTION(member->IsProperty(), """"way broken!"""");
     propFlags |= JSPROP_GETTER | JSPROP_SHARED;
+    JSPropertyOp getter = JS_DATA_TO_FUNC_PTR(JSPropertyOp, funobj);
+    JSPropertyOp setter;
     if(member->IsSetter())
     {
         propFlags |= JSPROP_SETTER;
         propFlags &= ~JSPROP_READONLY;
+        setter = getter;
+    }
+    else
+    {
+        setter = js_GetterOnlyPropertyStub;
     }
     AutoResolveName arn(ccx, idval);
     if(resolved)
         *resolved = JS_TRUE;
     return JS_ValueToId(ccx, idval, &id) &&
-           JS_DefinePropertyById(ccx, obj, id, JSVAL_VOID,
-                                 JS_DATA_TO_FUNC_PTR(JSPropertyOp, funobj),
-                                 JS_DATA_TO_FUNC_PTR(JSPropertyOp, funobj),
+           JS_DefinePropertyById(ccx, obj, id, JSVAL_VOID, getter, setter,
                                  propFlags);
 
 }
diff --git a/js/src/xpconnect/src/xpcwrappednativejsops.cpp b/js/src/xpconnect/src/xpcwrappednativejsops.cpp
index eac1a30..dd3aa0d 100644
--- a/js/src/xpconnect/src/xpcwrappednativejsops.cpp
+++ b/js/src/xpconnect/src/xpcwrappednativejsops.cpp
@@ -469,21 +469,26 @@ DefinePropertyIfFound(XPCCallContext& ccx,
     NS_ASSERTION(member->IsAttribute(), """"way broken!"""");
 
     propFlags |= JSPROP_GETTER | JSPROP_SHARED;
+    JSObject* funobj = JSVAL_TO_OBJECT(funval);
+    JSPropertyOp getter = JS_DATA_TO_FUNC_PTR(JSPropertyOp, funobj);
+    JSPropertyOp setter;
     if(member->IsWritableAttribute())
     {
         propFlags |= JSPROP_SETTER;
         propFlags &= ~JSPROP_READONLY;
+        setter = getter;
+    }
+    else
+    {
+        setter = js_GetterOnlyPropertyStub;
     }
 
     AutoResolveName arn(ccx, idval);
     if(resolved)
         *resolved = JS_TRUE;
 
-    JSObject* funobj = JSVAL_TO_OBJECT(funval);
     return JS_ValueToId(ccx, idval, &id) &&
-           JS_DefinePropertyById(ccx, obj, id, JSVAL_VOID,
-                                 JS_DATA_TO_FUNC_PTR(JSPropertyOp, funobj),
-                                 JS_DATA_TO_FUNC_PTR(JSPropertyOp, funobj),
+           JS_DefinePropertyById(ccx, obj, id, JSVAL_VOID, getter, setter,
                                  propFlags);
 }
 """
458b440b1ad87892c98101d0453a542cd64a201f,45379,479560,Blake Kaplan,"Bug 479560, r+sr=jst
",1239968502,"""diff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h
index 42daba0..c528c23 100644
--- a/js/src/xpconnect/src/xpcprivate.h
+++ b/js/src/xpconnect/src/xpcprivate.h
@@ -2541,7 +2541,7 @@ private:
     nsXPCWrappedJSClass(XPCCallContext& ccx, REFNSIID aIID,
                         nsIInterfaceInfo* aInfo);
 
-    JSObject*  NewOutObject(JSContext* cx);
+    JSObject*  NewOutObject(JSContext* cx, JSObject* scope);
 
     JSBool IsReflectable(uint16 i) const
         {return (JSBool)(mDescriptors[i/32] & (1 << (i%32)));}
diff --git a/js/src/xpconnect/src/xpcwrappedjsclass.cpp b/js/src/xpconnect/src/xpcwrappedjsclass.cpp
index 36c0efd..8e01961 100644
--- a/js/src/xpconnect/src/xpcwrappedjsclass.cpp
+++ b/js/src/xpconnect/src/xpcwrappedjsclass.cpp
@@ -1512,7 +1512,7 @@ nsXPCWrappedJSClass::CallMethod(nsXPCWrappedJS* wrapper, uint16 methodIndex,
         if(param.IsOut())
         {
             // create an 'out' object
-            JSObject* out_obj = NewOutObject(cx);
+            JSObject* out_obj = NewOutObject(cx, obj);
             if(!out_obj)
             {
                 retval = NS_ERROR_OUT_OF_MEMORY;
@@ -1869,9 +1869,9 @@ nsXPCWrappedJSClass::GetInterfaceName()
 }
 
 JSObject*
-nsXPCWrappedJSClass::NewOutObject(JSContext* cx)
+nsXPCWrappedJSClass::NewOutObject(JSContext* cx, JSObject* scope)
 {
-    return JS_NewObject(cx, nsnull, nsnull, nsnull);
+    return JS_NewObject(cx, nsnull, nsnull, JS_GetGlobalForObject(cx, scope));
 }
 
 """
2cd47acecea23febb6dc4884155663c8deee47f1,45848,479943,Boris Zbarsky,"Bug 479943.  Pass in the right owner for link clicks and form submissions and stop inheriting from the document.  r=dveditz, sr=jst
",1239636722,"""diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
index d3ac740..57cc179 100644
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -6907,8 +6907,8 @@ nsDocShell::InternalLoad(nsIURI * aURI,
         // One more twist: Don't inherit the owner for external loads.
         if (aLoadType != LOAD_NORMAL_EXTERNAL && !owner &&
             (aFlags & INTERNAL_LOAD_FLAGS_INHERIT_OWNER) &&
-            ((NS_SUCCEEDED(URIInheritsSecurityContext(aURI, &inherits)) &&
-              inherits) || URIIsLocalFile(aURI))) {
+            NS_SUCCEEDED(URIInheritsSecurityContext(aURI, &inherits)) &&
+            inherits) {
 
             // Don't allow loads that would inherit our security context
             // if this document came from an unsafe channel.
diff --git a/docshell/base/nsWebShell.cpp b/docshell/base/nsWebShell.cpp
index 83f85b8..fa8d788 100644
--- a/docshell/base/nsWebShell.cpp
+++ b/docshell/base/nsWebShell.cpp
@@ -877,8 +877,8 @@ nsWebShell::OnLinkClickSync(nsIContent *aContent,
   
   rv = InternalLoad(aURI,               // New URI
                     referer,            // Referer URI
-                    nsnull,             // No onwer
-                    INTERNAL_LOAD_FLAGS_INHERIT_OWNER, // Inherit owner from document
+                    aContent->NodePrincipal(), // Owner is our node's principal
+                    INTERNAL_LOAD_FLAGS_NONE,
                     target.get(),       // Window target
                     NS_LossyConvertUTF16toASCII(typeHint).get(),
                     aPostDataStream,    // Post data stream"""
c56736bf6938ba8c82a157b779b5a4136b516262,45913,486269,Johnny Stenback,"Fixing bug 486269. Prevent plugins from being destroyed while calling into them. r=joshmoz@gmail.com, sr=bzbarsky@mit.edu
",1239139257,"""diff --git a/modules/plugin/base/src/nsJSNPRuntime.cpp b/modules/plugin/base/src/nsJSNPRuntime.cpp
index b26fcb6..79655ad 100644
--- a/modules/plugin/base/src/nsJSNPRuntime.cpp
+++ b/modules/plugin/base/src/nsJSNPRuntime.cpp
@@ -1148,6 +1148,8 @@ NPObjWrapper_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
     return JS_FALSE;
   }
 
+  PluginDestructionGuard pdg(LookupNPP(npobj));
+
   // We must permit methods here since JS_DefineUCFunction() will add
   // the function as a property
   if (!npobj->_class->hasProperty(npobj, (NPIdentifier)id) &&
@@ -1173,6 +1175,8 @@ NPObjWrapper_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
     return JS_FALSE;
   }
 
+  PluginDestructionGuard pdg(LookupNPP(npobj));
+
   if (!npobj->_class->hasProperty(npobj, (NPIdentifier)id))
     return JS_TRUE;
 
@@ -1194,13 +1198,6 @@ NPObjWrapper_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
     return JS_FALSE;
   }
 
-  if (!npobj->_class->hasProperty(npobj, (NPIdentifier)id)) {
-    ThrowJSException(cx, """"Trying to set unsupported property on scriptable """"
-                     """"plugin object!"""");
-
-    return JS_FALSE;
-  }
-
   // Find out what plugin (NPP) is the owner of the object we're
   // manipulating, and make it own any JSObject wrappers created here.
   NPP npp = LookupNPP(npobj);
@@ -1211,6 +1208,15 @@ NPObjWrapper_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
     return JS_FALSE;
   }
 
+  PluginDestructionGuard pdg(npp);
+
+  if (!npobj->_class->hasProperty(npobj, (NPIdentifier)id)) {
+    ThrowJSException(cx, """"Trying to set unsupported property on scriptable """"
+                     """"plugin object!"""");
+
+    return JS_FALSE;
+  }
+
   NPVariant npv;
   if (!JSValToNPVariant(npp, cx, *vp, &npv)) {
     ThrowJSException(cx, """"Error converting jsval to NPVariant!"""");
@@ -1245,21 +1251,20 @@ NPObjWrapper_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
     return JS_FALSE;
   }
 
-  PRBool hasProperty = npobj->_class->hasProperty(npobj, (NPIdentifier)id);
-  PRBool hasMethod = npobj->_class->hasMethod(npobj, (NPIdentifier)id);
-  NPP npp = nsnull;
-  if (hasProperty) {
-    // Find out what plugin (NPP) is the owner of the object we're
-    // manipulating, and make it own any JSObject wrappers created
-    // here.
-    npp = LookupNPP(npobj);
-    if (!npp) {
-      ThrowJSException(cx, """"No NPP found for NPObject!"""");
+  // Find out what plugin (NPP) is the owner of the object we're
+  // manipulating, and make it own any JSObject wrappers created here.
+  NPP npp = LookupNPP(npobj);
+  if (!npp) {
+    ThrowJSException(cx, """"No NPP found for NPObject!"""");
 
-      return JS_FALSE;
-    }
+    return JS_FALSE;
   }
 
+  PluginDestructionGuard pdg(npp);
+
+  PRBool hasProperty = npobj->_class->hasProperty(npobj, (NPIdentifier)id);
+  PRBool hasMethod = npobj->_class->hasMethod(npobj, (NPIdentifier)id);
+
   // To support ambiguous members, we return NPObject Member class here.
   if (hasProperty && hasMethod)
     return CreateNPObjectMember(npp, cx, obj, npobj, id, vp);
@@ -1318,6 +1323,8 @@ CallNPMethodInternal(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
     return JS_FALSE;
   }
 
+  PluginDestructionGuard pdg(npp);
+
   NPVariant npargs_buf[8];
   NPVariant *npargs = npargs_buf;
 
@@ -1445,6 +1452,8 @@ NPObjWrapper_newEnumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
     return JS_FALSE;
   }
 
+  PluginDestructionGuard pdg(LookupNPP(npobj));
+
   NS_ASSERTION(statep, """"Must have a statep to enumerate!"""");
 
   switch(enum_op) {
@@ -1515,6 +1524,8 @@ NPObjWrapper_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
     return JS_FALSE;
   }
 
+  PluginDestructionGuard pdg(LookupNPP(npobj));
+
   if (npobj->_class->hasProperty(npobj, (NPIdentifier)id)) {
     JSBool ok;
 """
9aecf64355f57bed327bc46d0bf53b8069502385,45922,480134,Vladimir Vukicevic,"b=480134; apply 500 char limit to all OSX versions; r=roc
",1239132268,"""diff --git a/gfx/thebes/src/gfxAtsuiFonts.cpp b/gfx/thebes/src/gfxAtsuiFonts.cpp
index 5bd4523..d4cfbdb 100644
--- a/gfx/thebes/src/gfxAtsuiFonts.cpp
+++ b/gfx/thebes/src/gfxAtsuiFonts.cpp
@@ -683,9 +683,9 @@ gfxAtsuiFontGroup::GuessMaximumStringLength()
     
     // bug 436663 - ATSUI crashes on 10.5.3 with certain character sequences 
     // at around 512 characters, so for safety sake max out at 500 characters
-    if (gfxPlatformMac::GetPlatform()->OSXVersion() >= MAC_OS_X_VERSION_10_5_HEX) {
-        realGuessMax = PR_MIN(500, realGuessMax);
-    }
+    // bug 480134 - Do this for all OSX versions now, because there may be
+    // other related bugs on 10.4.
+    realGuessMax = PR_MIN(500, realGuessMax);
 
     return realGuessMax;
 }"""
7210c0ea457c831c053dd98ab308933c077a2a16,46363,485286,Blake Kaplan,"Bug 485286 - Allocate all of these consistently. r+sr=peterv/sicking (a=ss for checkin into a CLOSED TREE).
",1238052189,"""diff --git a/content/xslt/src/xslt/txKeyFunctionCall.cpp b/content/xslt/src/xslt/txKeyFunctionCall.cpp
index 1d27aa9..083529e 100644
--- a/content/xslt/src/xslt/txKeyFunctionCall.cpp
+++ b/content/xslt/src/xslt/txKeyFunctionCall.cpp
@@ -388,17 +388,20 @@ nsresult txXSLKey::testNode(const txXPathNode& aNode,
     PRUint32 currKey, numKeys = mKeys.Length();
     for (currKey = 0; currKey < numKeys; ++currKey) {
         if (mKeys[currKey].matchPattern->matches(aNode, &aEs)) {
-            txSingleNodeContext evalContext(aNode, &aEs);
-            nsresult rv = aEs.pushEvalContext(&evalContext);
+            txSingleNodeContext *evalContext =
+                new txSingleNodeContext(aNode, &aEs);
+            NS_ENSURE_TRUE(evalContext, NS_ERROR_OUT_OF_MEMORY);
+
+            nsresult rv = aEs.pushEvalContext(evalContext);
             NS_ENSURE_SUCCESS(rv, rv);
 
             nsRefPtr<txAExprResult> exprResult;
-            rv = mKeys[currKey].useExpr->evaluate(&evalContext,
+            rv = mKeys[currKey].useExpr->evaluate(evalContext,
                                                   getter_AddRefs(exprResult));
-
-            aEs.popEvalContext();
             NS_ENSURE_SUCCESS(rv, rv);
 
+            delete aEs.popEvalContext();
+
             if (exprResult->getResultType() == txAExprResult::NODESET) {
                 txNodeSet* res = static_cast<txNodeSet*>
                                             (static_cast<txAExprResult*>"""
72aea043876d137bf38ff90051cb576d6dfc5c30,46366,485217,Blake Kaplan,"Bug 485217 - Add a crashtest.
",1238016816,"""diff --git a/content/xslt/crashtests/485217.xml b/content/xslt/crashtests/485217.xml
new file mode 100644
index 0000000..93a20e4
--- /dev/null
+++ b/content/xslt/crashtests/485217.xml
@@ -0,0 +1,8 @@
+<?xml version=""""1.0"""" encoding=""""UTF-8""""?>
+<?xml-stylesheet type=""""text/xsl"""" href=""""485217.xsl""""?>
+
+
+<root xmlns:xsi=""""http://www.w3.org/2001/XMLSchema-instance"""">
+    <item1 id=""""AAAAAAA"""" />
+    <item2 id=""""AAAAAAAAA"""" label=""""AAAAAAAAAAAA""""/>
+</root>
diff --git a/content/xslt/crashtests/485217.xsl b/content/xslt/crashtests/485217.xsl
new file mode 100644
index 0000000..7e12a09
--- /dev/null
+++ b/content/xslt/crashtests/485217.xsl
@@ -0,0 +1,18 @@
+<?xml version=""""1.0"""" encoding=""""UTF-8""""?>
+
+<xsl:stylesheet version=""""2.0"""" xmlns:xsl=""""http://www.w3.org/1999/XSL/Transform"""">
+
+    <xsl:key name=""""label"""" match=""""item2"""" use=""""w00t()""""/>
+
+    <xsl:template match=""""root"""">
+                    <xsl:for-each select=""""//item1"""">
+                        <xsl:call-template name=""""item1"""" />
+                    </xsl:for-each>
+    </xsl:template>
+
+    <xsl:template name=""""item1"""">
+                <xsl:for-each select=""""key('label', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA')"""">
+                </xsl:for-each>
+    </xsl:template>
+
+</xsl:stylesheet>
diff --git a/content/xslt/crashtests/crashtests.list b/content/xslt/crashtests/crashtests.list
index 9b72df9..fee1879 100644
--- a/content/xslt/crashtests/crashtests.list
+++ b/content/xslt/crashtests/crashtests.list
@@ -2,3 +2,4 @@ load 91332.xml
 load 111994.xml
 load 226425.xml
 load 406106-1.html
+load 485217.xml"""
0ea6b319854a5a85b22283def21e0f9965e940f0,46368,485217,Blake Kaplan,"Bug 485217 - Pop the eval context before returning. r+sr=peterv
",1238011664,"""diff --git a/content/xslt/src/xslt/txKeyFunctionCall.cpp b/content/xslt/src/xslt/txKeyFunctionCall.cpp
index e1531a7..1d27aa9 100644
--- a/content/xslt/src/xslt/txKeyFunctionCall.cpp
+++ b/content/xslt/src/xslt/txKeyFunctionCall.cpp
@@ -395,9 +395,9 @@ nsresult txXSLKey::testNode(const txXPathNode& aNode,
             nsRefPtr<txAExprResult> exprResult;
             rv = mKeys[currKey].useExpr->evaluate(&evalContext,
                                                   getter_AddRefs(exprResult));
-            NS_ENSURE_SUCCESS(rv, rv);
 
             aEs.popEvalContext();
+            NS_ENSURE_SUCCESS(rv, rv);
 
             if (exprResult->getResultType() == txAExprResult::NODESET) {
                 txNodeSet* res = static_cast<txNodeSet*>"""
f7eea58ef2fff54ee0d2fb7dc607ed3eba0c3b82,46389,498897,Peter Van der Beken,"Fix for bug 498897. r/sr=mrbkap.

--HG--
extra : rebase_source : d1f8c9d42fc5c0369e8674d7c148ddc25bdfaaed
",1245429108,"""diff --git a/content/base/src/nsDocument.cpp b/content/base/src/nsDocument.cpp
index da9dc2e..cd1cb86 100644
--- a/content/base/src/nsDocument.cpp
+++ b/content/base/src/nsDocument.cpp
@@ -153,6 +153,7 @@ static NS_DEFINE_CID(kDOMEventGroupCID, NS_DOMEVENTGROUP_CID);
 #include """"nsIDOMXPathEvaluator.h""""
 #include """"nsDOMCID.h""""
 
+#include """"jsapi.h""""
 #include """"nsIJSContextStack.h""""
 #include """"nsIXPConnect.h""""
 #include """"nsCycleCollector.h""""
@@ -3534,6 +3535,34 @@ nsDocument::SetScriptGlobalObject(nsIScriptGlobalObject *aScriptGlobalObject)
     mLayoutHistoryState = nsnull;
     mScopeObject = do_GetWeakReference(aScriptGlobalObject);
 
+    // If we already have a wrapper at this point, it might have the wrong
+    // parent and scope, so reparent it.
+    nsIXPConnectWrappedNative *wrapper =
+      static_cast<nsIXPConnectWrappedNative*>(GetWrapper());
+    if (wrapper) {
+      JSObject *obj = nsnull;
+      wrapper->GetJSObject(&obj);
+      if (obj) {
+        JSObject *newScope = aScriptGlobalObject->GetGlobalJSObject();
+        nsIScriptContext *scx = aScriptGlobalObject->GetContext();
+        JSContext *cx = scx ? (JSContext *)scx->GetNativeContext() : nsnull;
+        if (!cx) {
+          nsContentUtils::ThreadJSContextStack()->Peek(&cx);
+          if (!cx) {
+            nsContentUtils::ThreadJSContextStack()->GetSafeJSContext(&cx);
+            NS_ASSERTION(cx, """"Uhoh, no context, this is bad!"""");
+          }
+        }
+        if (cx) {
+          nsCOMPtr<nsIXPConnectJSObjectHolder> newWrapper;
+          nsContentUtils::XPConnect()->
+            ReparentWrappedNativeIfFound(cx, JS_GetGlobalForObject(cx, obj),
+                                         newScope, wrapper->Native(),
+                                         getter_AddRefs(newWrapper));
+        }
+      }
+    }
+
     if (mAllowDNSPrefetch) {
       nsCOMPtr<nsIDocShell> docShell = do_QueryReferent(mDocumentContainer);
       if (docShell) {"""
0e640909433e14adae349de0ebe6d11904136e40,46424,484320,Olli Pettay,"Bug 484320, r=dveditz, sr=mrbkap, a=blocking1.9.1
",1237909395,"""diff --git a/layout/xul/base/src/tree/src/nsTreeSelection.cpp b/layout/xul/base/src/tree/src/nsTreeSelection.cpp
index 581deec..012b715 100644
--- a/layout/xul/base/src/tree/src/nsTreeSelection.cpp
+++ b/layout/xul/base/src/tree/src/nsTreeSelection.cpp
@@ -268,6 +268,8 @@ nsTreeSelection::nsTreeSelection(nsITreeBoxObject* aTree)
 nsTreeSelection::~nsTreeSelection()
 {
   delete mFirstRange;
+  if (mSelectTimer)
+    mSelectTimer->Cancel();
 }
 
 // QueryInterface implementation for nsBoxObject"""
2fec20f74366fc7cfb89d58ef2fa49b40da25fd8,46521,483086,Ryan Flint,"Bug 483086. r=gavin, a=beltzner
",1237362763,"""diff --git a/browser/components/search/test/483086-1.xml b/browser/components/search/test/483086-1.xml
new file mode 100644
index 0000000..e792fc9
--- /dev/null
+++ b/browser/components/search/test/483086-1.xml
@@ -0,0 +1,10 @@
+<OpenSearchDescription xmlns=""""http://a9.com/-/spec/opensearch/1.1/""""
+                       xmlns:moz=""""http://www.mozilla.org/2006/browser/search/"""">
+  <ShortName>483086a</ShortName>
+  <Description>Bug 483086 Test 1</Description>
+  <Image width=""""16"""" height=""""16"""">data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAABGklEQVQoz2NgGB6AnZ1dUlJSXl4eSDIyMhLW4Ovr%2B%2Fr168uXL69Zs4YoG%2BLi4i5dusTExMTGxsbNzd3f37937976%2BnpmZmagbHR09J49e5YvX66kpATVEBYW9ubNm2nTphkbG7e2tp44cQLIuHfvXm5urpaWFlDKysqqu7v73LlzECMYIiIiHj58mJCQoKKicvXq1bS0NKBgW1vbjh074uPjgeqAXE1NzSdPnvDz84M0AEUvXLgAsW379u1z5swBen3jxo2zZ892cHB4%2BvQp0KlAfwI1cHJyghQFBwfv2rULokFXV%2FfixYu7d%2B8GGqGgoMDKyrpu3br9%2B%2FcDuXl5eVA%2FAEWBfoWHAdAYoNuAYQ0XAeoUERFhGDYAAPoUaT2dfWJuAAAAAElFTkSuQmCC</Image>
+  <Url type=""""text/html"""" method=""""GET"""" template=""""http://localhost:8888/browser/browser/components/search/test/?search"""">
+    <Param name=""""test"""" value=""""{searchTerms}""""/>
+  </Url>
+  <moz:SearchForm>foo://example.com</moz:SearchForm>
+</OpenSearchDescription>
diff --git a/browser/components/search/test/483086-2.xml b/browser/components/search/test/483086-2.xml
new file mode 100644
index 0000000..ed2d4a7
--- /dev/null
+++ b/browser/components/search/test/483086-2.xml
@@ -0,0 +1,10 @@
+<OpenSearchDescription xmlns=""""http://a9.com/-/spec/opensearch/1.1/""""
+                       xmlns:moz=""""http://www.mozilla.org/2006/browser/search/"""">
+  <ShortName>483086b</ShortName>
+  <Description>Bug 483086 Test 2</Description>
+  <Image width=""""16"""" height=""""16"""">data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAABGklEQVQoz2NgGB6AnZ1dUlJSXl4eSDIyMhLW4Ovr%2B%2Fr168uXL69Zs4YoG%2BLi4i5dusTExMTGxsbNzd3f37937976%2BnpmZmagbHR09J49e5YvX66kpATVEBYW9ubNm2nTphkbG7e2tp44cQLIuHfvXm5urpaWFlDKysqqu7v73LlzECMYIiIiHj58mJCQoKKicvXq1bS0NKBgW1vbjh074uPjgeqAXE1NzSdPnvDz84M0AEUvXLgAsW379u1z5swBen3jxo2zZ892cHB4%2BvQp0KlAfwI1cHJyghQFBwfv2rULokFXV%2FfixYu7d%2B8GGqGgoMDKyrpu3br9%2B%2FcDuXl5eVA%2FAEWBfoWHAdAYoNuAYQ0XAeoUERFhGDYAAPoUaT2dfWJuAAAAAElFTkSuQmCC</Image>
+  <Url type=""""text/html"""" method=""""GET"""" template=""""http://localhost:8888/browser/browser/components/search/test/?search"""">
+    <Param name=""""test"""" value=""""{searchTerms}""""/>
+  </Url>
+  <moz:SearchForm>http://example.com</moz:SearchForm>
+</OpenSearchDescription>
diff --git a/browser/components/search/test/Makefile.in b/browser/components/search/test/Makefile.in
index 7587869..2534d06 100644
--- a/browser/components/search/test/Makefile.in
+++ b/browser/components/search/test/Makefile.in
@@ -48,6 +48,9 @@ _BROWSER_TEST_FILES = 	  browser_405664.js \
 	                  browser_415700.js \
 	                  testEngine.xml \
 	                  browser_426329.js \
+	                  browser_483086.js \
+	                  483086-1.xml \
+	                  483086-2.xml \
 	                  $(NULL)
 
 libs:: $(_BROWSER_TEST_FILES)
diff --git a/browser/components/search/test/browser_483086.js b/browser/components/search/test/browser_483086.js
new file mode 100644
index 0000000..6374264
--- /dev/null
+++ b/browser/components/search/test/browser_483086.js
@@ -0,0 +1,90 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Ryan Flint <rflint@dslr.net> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+let gSS = Cc[""""@mozilla.org/browser/search-service;1""""].
+           getService(Ci.nsIBrowserSearchService);
+let gObs = Cc[""""@mozilla.org/observer-service;1""""].
+           getService(Ci.nsIObserverService);
+
+function test() {
+  waitForExplicitFinish();
+
+  let observer = {
+    observe: function(aSubject, aTopic, aData) {
+      switch (aData) {
+        case """"engine-added"""":
+          let engine = gSS.getEngineByName(""""483086a"""");
+          ok(engine, """"Test engine 1 installed"""");
+          isnot(engine.searchForm, """"foo://example.com"""",
+                """"Invalid SearchForm URL dropped"""");
+          gSS.removeEngine(engine);
+          break;
+        case """"engine-removed"""":
+          gObs.removeObserver(this, """"browser-search-engine-modified"""");
+          test2();
+          break;
+      }
+    }
+  };
+
+  gObs.addObserver(observer, """"browser-search-engine-modified"""", false);
+  gSS.addEngine(""""http://localhost:8888/browser/browser/components/search/test/483086-1.xml"""",
+                Ci.nsISearchEngine.DATA_XML, """"data:image/x-icon;%00"""",
+                false);
+}
+
+function test2() {
+  let observer = {
+    observe: function(aSubject, aTopic, aData) {
+      switch (aData) {
+        case """"engine-added"""":
+          let engine = gSS.getEngineByName(""""483086b"""");
+          ok(engine, """"Test engine 2 installed"""");
+          is(engine.searchForm, """"http://example.com"""", """"SearchForm is correct"""");
+          gSS.removeEngine(engine);
+          break;
+        case """"engine-removed"""":  
+          gObs.removeObserver(this, """"browser-search-engine-modified"""");
+          finish();
+          break;
+      }
+    }
+  };
+
+  gObs.addObserver(observer, """"browser-search-engine-modified"""", false);
+  gSS.addEngine(""""http://localhost:8888/browser/browser/components/search/test/483086-2.xml"""",
+                Ci.nsISearchEngine.DATA_XML, """"data:image/x-icon;%00"""",
+                false);
+}
diff --git a/toolkit/components/search/nsSearchService.js b/toolkit/components/search/nsSearchService.js
index dbf62b4..2e60d57 100644
--- a/toolkit/components/search/nsSearchService.js
+++ b/toolkit/components/search/nsSearchService.js
@@ -92,7 +92,7 @@ const CACHE_INVALIDATION_DELAY = 1000;
 
 // Current cache version. This should be incremented if the format of the cache
 // file is modified.
-const CACHE_VERSION = 3;
+const CACHE_VERSION = 4;
 
 const ICON_DATAURL_PREFIX = """"data:image/x-icon;base64,"""";
 
@@ -1055,7 +1055,17 @@ Engine.prototype = {
   // The name of the charset used to submit the search terms.
   _queryCharset: null,
   // A URL string pointing to the engine's search form.
-  _searchForm: null,
+  __searchForm: null,
+  get _searchForm() {
+    return this.__searchForm;
+  },
+  set _searchForm(aValue) {
+    if (/^https?:/i.test(aValue))
+      this.__searchForm = aValue;
+    else
+      LOG(""""_searchForm: Invalid URL dropped for """" + this._name ||
+          """"the current engine"""");
+  },
   // The URI object from which the engine was retrieved.
   // This is null for local plugins, and is used for error messages and logging.
   _uri: null,
@@ -1983,7 +1993,7 @@ Engine.prototype = {
     this._hidden = aJson.hidden || null;
     this._type = aJson.type || SEARCH_TYPE_MOZSEARCH;
     this._queryCharset = aJson.queryCharset || DEFAULT_QUERY_CHARSET;
-    this._searchForm = aJson.searchForm;
+    this.__searchForm = aJson.__searchForm;
     this.__installLocation = aJson._installLocation || SEARCH_APP_DIR;
     this._updateInterval = aJson._updateInterval || null;
     this._updateURL = aJson._updateURL || null;
@@ -2015,7 +2025,7 @@ Engine.prototype = {
       _name: this._name,
       description: this.description,
       filePath: this._file.QueryInterface(Ci.nsILocalFile).persistentDescriptor,
-      searchForm: this.searchForm,
+      __searchForm: this.__searchForm,
       _iconURL: this._iconURL,
       _urls: [url._serializeToJSON() for each(url in this._urls)] 
     };"""
9a798e98c6bc1a04a51723784069ebb24e9c1da4,46535,484031,Boris Zbarsky,"Bug 484031.  Be a bit more careful with ContentAppended.  r+sr=roc
",1238426594,"""diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
index 9558f95..7035ec1 100644
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -6100,6 +6100,13 @@ nsCSSFrameConstructor::ContentAppended(nsIContent*     aContainer,
       // ContentInserted will ignore the passed-in index.
       PRUint32 containerCount = aContainer->GetChildCount();
       for (PRUint32 i = aNewIndexInContainer; i < containerCount; i++) {
+        nsIContent* content = aContainer->GetChildAt(i);
+        if (mPresShell->GetPrimaryFrameFor(content)) {
+          // Already have a frame for this content; a previous ContentInserted
+          // in this loop must have reconstructed its insertion parent.  Skip
+          // it.
+          continue;
+        }
         LAYOUT_PHASE_TEMP_EXIT();
         // Call ContentInserted with this index.
         ContentInserted(aContainer, aContainer->GetChildAt(i), i,"""
c970581f9ae471bc850ae21f3a5a4ab2f59c5297,46539,484031,Boris Zbarsky,"Backing out revision 6a8a88c62925 (bug 484031) on suspicion of causing a Tp increase
",1238450669,"""diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
index 7035ec1..9558f95 100644
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -6100,13 +6100,6 @@ nsCSSFrameConstructor::ContentAppended(nsIContent*     aContainer,
       // ContentInserted will ignore the passed-in index.
       PRUint32 containerCount = aContainer->GetChildCount();
       for (PRUint32 i = aNewIndexInContainer; i < containerCount; i++) {
-        nsIContent* content = aContainer->GetChildAt(i);
-        if (mPresShell->GetPrimaryFrameFor(content)) {
-          // Already have a frame for this content; a previous ContentInserted
-          // in this loop must have reconstructed its insertion parent.  Skip
-          // it.
-          continue;
-        }
         LAYOUT_PHASE_TEMP_EXIT();
         // Call ContentInserted with this index.
         ContentInserted(aContainer, aContainer->GetChildAt(i), i,"""
64a69b9c6a5e6e3e86c056b48db9310cb57d3f49,46549,485286,Blake Kaplan,"Bug 485286 - Add a crashtest.
",1238439040,"""diff --git a/content/xslt/crashtests/485286.xml b/content/xslt/crashtests/485286.xml
new file mode 100644
index 0000000..c87aa94
--- /dev/null
+++ b/content/xslt/crashtests/485286.xml
@@ -0,0 +1,12 @@
+<?xml-stylesheet type=""""application/xml"""" href=""""485286.xml""""?>
+<transform xmlns=""""http://www.w3.org/1999/XSL/Transform"""" version=""""1.0"""">
+  <variable name=""""v"""">
+    <for-each select=""""/"""">
+      <value-of select=""""count(1)""""/>
+    </for-each>
+  </variable>
+  <key name=""""k"""" match=""""/"""" use=""""$v""""/>
+  <template match=""""/"""">
+    <value-of select=""""key('k', /..)""""/>
+  </template>
+</transform>
diff --git a/content/xslt/crashtests/crashtests.list b/content/xslt/crashtests/crashtests.list
index fee1879..e330e99 100644
--- a/content/xslt/crashtests/crashtests.list
+++ b/content/xslt/crashtests/crashtests.list
@@ -3,3 +3,4 @@ load 111994.xml
 load 226425.xml
 load 406106-1.html
 load 485217.xml
+load 485286.xml"""
752f9dbcd0e430ddb06487babbaa1a256cf28b31,46561,484031,Boris Zbarsky,"Bug 484031.  Be a bit more careful with ContentAppended.  r+sr=roc
",1238426594,"""diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
index f0bd4c4..3e5ac5d 100644
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -6100,6 +6100,13 @@ nsCSSFrameConstructor::ContentAppended(nsIContent*     aContainer,
       // ContentInserted will ignore the passed-in index.
       PRUint32 containerCount = aContainer->GetChildCount();
       for (PRUint32 i = aNewIndexInContainer; i < containerCount; i++) {
+        nsIContent* content = aContainer->GetChildAt(i);
+        if (mPresShell->GetPrimaryFrameFor(content)) {
+          // Already have a frame for this content; a previous ContentInserted
+          // in this loop must have reconstructed its insertion parent.  Skip
+          // it.
+          continue;
+        }
         LAYOUT_PHASE_TEMP_EXIT();
         // Call ContentInserted with this index.
         ContentInserted(aContainer, aContainer->GetChildAt(i), i,"""
ca2b803034294801b93b2b595cfe7c49cfc5251d,46773,484031,Boris Zbarsky,"Use the local instead of making another virtual  function call.  Followup for bug 484031
",1238523699,"""diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
index 87f14d6..89b0b8d 100644
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -6111,8 +6111,7 @@ nsCSSFrameConstructor::ContentAppended(nsIContent*     aContainer,
         }
         LAYOUT_PHASE_TEMP_EXIT();
         // Call ContentInserted with this index.
-        ContentInserted(aContainer, aContainer->GetChildAt(i), i,
-                        mTempFrameTreeState);
+        ContentInserted(aContainer, content, i, mTempFrameTreeState);
         LAYOUT_PHASE_TEMP_REENTER();
       }
 """
6373f77812d1949552ccddf97bcebc6142de536c,46811,471962,Paolo Amadini,"Add test for bug 471962, r=gavin
",1237229430,"""diff --git a/toolkit/content/tests/Makefile.in b/toolkit/content/tests/Makefile.in
index 5bbab58..b7929dd 100644
--- a/toolkit/content/tests/Makefile.in
+++ b/toolkit/content/tests/Makefile.in
@@ -47,6 +47,6 @@ MODULE		= test_toolkit_general
 
 XPCSHELL_TESTS = unit
 
-DIRS = chrome widgets
+DIRS = browser chrome widgets
 
 include $(topsrcdir)/config/rules.mk
diff --git a/toolkit/content/tests/browser/Makefile.in b/toolkit/content/tests/browser/Makefile.in
new file mode 100644
index 0000000..20da998
--- /dev/null
+++ b/toolkit/content/tests/browser/Makefile.in
@@ -0,0 +1,54 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the """"License""""); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an """"AS IS"""" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the """"GPL""""), or
+# the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH          = ../../../..
+topsrcdir      = @top_srcdir@
+srcdir         = @srcdir@
+VPATH          = @srcdir@
+relativesrcdir = toolkit/content/tests/browser
+
+include $(DEPTH)/config/autoconf.mk
+include $(topsrcdir)/config/rules.mk
+
+_BROWSER_FILES = \
+  bug471962_testpage_inner.sjs \
+  bug471962_testpage_outer.sjs \
+  browser_bug471962.js \
+  $(NULL)
+
+libs:: $(_BROWSER_FILES)
+	$(INSTALL) $(foreach f,$^,""""$f"""") $(DEPTH)/_tests/testing/mochitest/browser/$(relativesrcdir)
diff --git a/toolkit/content/tests/browser/browser_bug471962.js b/toolkit/content/tests/browser/browser_bug471962.js
new file mode 100644
index 0000000..fba9f60
--- /dev/null
+++ b/toolkit/content/tests/browser/browser_bug471962.js
@@ -0,0 +1,290 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla XUL Toolkit Testing Code.
+ *
+ * The Initial Developer of the Original Code is
+ * Paolo Amadini <http://www.amadzone.org/>.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+function test()
+{
+  const Cc = Components.classes;
+  const Ci = Components.interfaces;
+  const Cu = Components.utils;
+  const Cr = Components.results;
+  const Cm = Components.manager;
+
+  Cu.import(""""resource://gre/modules/XPCOMUtils.jsm"""");
+
+  // --- Mock nsIFilePicker implementation ---
+
+  var componentRegistrar = Cm.QueryInterface(Ci.nsIComponentRegistrar);
+
+  var originalFilePickerFactory;
+  var mockFilePickerFactory;
+  var destFile;
+
+  // Note: The original class name is platform-dependent, however it is not
+  // important that we restore the exact class name when we restore the
+  // original factory.
+  const kFilePickerCID = """"{bd57cee8-1dd1-11b2-9fe7-95cf4709aea3}"""";
+  const kFilePickerContractID = """"@mozilla.org/filepicker;1"""";
+  const kFilePickerPossibleClassName = """"File Picker"""";
+
+  function registerMockFilePickerFactory() {
+    // This file picker implementation is tailored for this test and returns
+    // the file specified in destFile, and a filter index of kSaveAsType_URL.
+    // The file is overwritten if it exists.
+    var mockFilePicker = {
+      QueryInterface: XPCOMUtils.generateQI([Ci.nsIFilePicker]),
+      init: function(aParent, aTitle, aMode) { },
+      appendFilters: function(aFilterMask) { },
+      appendFilter: function(aTitle, aFilter) { },
+      defaultString: """""""",
+      defaultExtension: """""""",
+      set filterIndex() { },
+      get filterIndex() {
+        return 1; // kSaveAsType_URL
+      },
+      displayDirectory: null,
+      get file() {
+        return destFile.clone();
+      },
+      get fileURL() {
+        return Cc[""""@mozilla.org/network/io-service;1""""].
+               getService(Ci.nsIIOService).newFileURI(destFile);
+      },
+      get files() {
+        throw Cr.NS_ERROR_NOT_IMPLEMENTED;
+      },
+      show: function() {
+        // Assume we overwrite the file if it exists
+        return (destFile.exists() ?
+                Ci.nsIFilePicker.returnReplace :
+                Ci.nsIFilePicker.returnOK);
+      }
+    };
+
+    mockFilePickerFactory = {
+      createInstance: function(aOuter, aIid) {
+        if (aOuter != null)
+          throw Cr.NS_ERROR_NO_AGGREGATION;
+        return mockFilePicker.QueryInterface(aIid);
+      }
+    };
+
+    // Preserve the original factory
+    originalFilePickerFactory = Cm.getClassObject(Cc[kFilePickerContractID],
+                                                  Ci.nsIFactory);
+
+    // Register the mock factory
+    componentRegistrar.registerFactory(
+      Components.ID(kFilePickerCID),
+      """"Mock File Picker Implementation"""",
+      kFilePickerContractID,
+      mockFilePickerFactory
+    );
+  }
+
+  function unregisterMockFilePickerFactory() {
+    // Free references to the mock factory
+    componentRegistrar.unregisterFactory(
+      Components.ID(kFilePickerCID),
+      mockFilePickerFactory
+    );
+
+    // Restore the original factory
+    componentRegistrar.registerFactory(
+      Components.ID(kFilePickerCID),
+      kFilePickerPossibleClassName,
+      kFilePickerContractID,
+      originalFilePickerFactory
+    );
+  }
+
+  // --- Download progress listener ---
+
+  var downloadManager = Cc[""""@mozilla.org/download-manager;1""""].
+                        getService(Ci.nsIDownloadManager);
+
+  var downloadListener = {
+    QueryInterface: XPCOMUtils.generateQI([Ci.nsIDownloadProgressListener]),
+    document: null,
+    onDownloadStateChange: function(aState, aDownload) {
+      switch (aDownload.state) {
+        // The download finished successfully, continue the test
+        case Ci.nsIDownloadManager.DOWNLOAD_FINISHED:
+          onDownloadFinished(true);
+          break;
+
+        // The download finished with a failure, abort the test
+        case Ci.nsIDownloadManager.DOWNLOAD_DIRTY:
+        case Ci.nsIDownloadManager.DOWNLOAD_FAILED:
+        case Ci.nsIDownloadManager.DOWNLOAD_CANCELED:
+          onDownloadFinished(false);
+          break;
+      }
+    },
+    onStateChange: function(aWebProgress, aRequest, aState, aStatus,
+     aDownload) { },
+    onProgressChange: function(aWebProgress, aRequest, aCurSelfProgress,
+     aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress, aDownload) { },
+    onSecurityChange: function(aWebProgress, aRequest, aState) { }
+  }
+
+  // --- Download Manager UI manual control ---
+
+  var mainPrefBranch = Cc[""""@mozilla.org/preferences-service;1""""].
+                       getService(Ci.nsIPrefBranch);
+
+  const kShowWhenStartingPref = """"browser.download.manager.showWhenStarting"""";
+  const kRetentionPref = """"browser.download.manager.retention"""";
+
+  function tweakDownloadManagerPrefs() {
+    // Prevent the Download Manager UI from showing automatically
+    mainPrefBranch.setBoolPref(kShowWhenStartingPref, false);
+    // Prevent the download from remaining in the Download Manager UI
+    mainPrefBranch.setIntPref(kRetentionPref, 0);
+  }
+
+  function restoreDownloadManagerPrefs() {
+    mainPrefBranch.clearUserPref(kShowWhenStartingPref);
+    mainPrefBranch.clearUserPref(kRetentionPref);
+  }
+
+  // --- Test procedure ---
+
+  var innerFrame;
+
+  function startTest() {
+    waitForExplicitFinish();
+
+    // Display the outer page
+    gBrowser.addEventListener(""""pageshow"""", onPageShow, false);
+    gBrowser.loadURI(""""http://localhost:8888/browser/toolkit/content/tests/browser/bug471962_testpage_outer.sjs"""");
+  }
+
+  function onPageShow() {
+    gBrowser.removeEventListener(""""pageshow"""", onPageShow, false);
+
+    // Submit the form in the outer page, then wait for both the outer
+    //  document and the inner frame to be loaded again
+    gBrowser.addEventListener(""""DOMContentLoaded"""", waitForTwoReloads, false);
+    gBrowser.contentDocument.getElementById(""""postForm"""").submit();
+  }
+
+  var isFirstReload = true;
+
+  function waitForTwoReloads() {
+    // The first time this function is called, do nothing
+    if (isFirstReload) {
+      isFirstReload = false;
+      return;
+    }
+
+    // The second time, go on with the normal test flow
+    gBrowser.removeEventListener(""""DOMContentLoaded"""", waitForTwoReloads, false);
+
+    // Save a reference to the inner frame in the reloaded page for later
+    innerFrame = gBrowser.contentDocument.getElementById(""""innerFrame"""");
+
+    // Submit the form in the inner page
+    gBrowser.addEventListener(""""DOMContentLoaded"""", onInnerSubmitted, false);
+    innerFrame.contentDocument.getElementById(""""postForm"""").submit();
+  }
+
+  function onInnerSubmitted() {
+    gBrowser.removeEventListener(""""DOMContentLoaded"""", onInnerSubmitted, false);
+
+    // Determine the path where the inner page will be saved
+    destFile = Cc[""""@mozilla.org/file/directory_service;1""""].
+     getService(Ci.nsIProperties).get(""""TmpD"""", Ci.nsIFile);
+    destFile.append(""""testsave_bug471962.html"""");
+
+    // Wait for the download to finish
+    downloadManager.addListener(downloadListener);
+
+    // Prevent the test from showing the Download Manager UI
+    tweakDownloadManagerPrefs();
+
+    // Call the internal save function defined in contentAreaUtils.js, while
+    // replacing the file picker component with a mock implementation that
+    // returns the path of the temporary file
+    registerMockFilePickerFactory();
+    var docToSave = innerFrame.contentDocument;
+    // We call internalSave instead of saveDocument to bypass the history cache
+    internalSave(docToSave.location.href, docToSave, null, null,
+                 docToSave.contentType, false, null, null,
+                 docToSave.referrer ? makeURI(docToSave.referrer) : null,
+                 false, null);
+    unregisterMockFilePickerFactory();
+  }
+
+  function onDownloadFinished(aSuccess) {
+    downloadManager.removeListener(downloadListener);
+    restoreDownloadManagerPrefs();
+
+    // Abort the test if the download wasn't successful
+    if (!aSuccess) {
+      ok(false, """"Unexpected failure, the inner frame couldn't be saved!"""");
+      finish();
+      return;
+    }
+
+    // Read the entire file
+    var inputStream = Cc[""""@mozilla.org/network/file-input-stream;1""""].
+                      createInstance(Ci.nsIFileInputStream);
+    inputStream.init(destFile, -1, 0, 0);
+    var scrInputStream = Cc[""""@mozilla.org/scriptableinputstream;1""""].
+                         createInstance(Ci.nsIScriptableInputStream);
+    scrInputStream.init(inputStream);
+    var fileContents = scrInputStream.
+                       read(1048576); // The file is much shorter than 1 MB
+    scrInputStream.close();
+    inputStream.close();
+
+    // Check if outer POST data is found
+    const searchPattern = """"inputfield=outer"""";
+    ok(fileContents.indexOf(searchPattern) === -1,
+       """"The saved inner frame does not contain outer POST data"""");
+
+    // Replace the current tab with a clean one
+    gBrowser.addTab();
+    gBrowser.removeCurrentTab();
+
+    // Clean up and exit
+    destFile.remove(false);
+    finish();
+  }
+
+  // Start the test now that all the inner functions are defined
+  startTest();
+}
diff --git a/toolkit/content/tests/browser/bug471962_testpage_inner.sjs b/toolkit/content/tests/browser/bug471962_testpage_inner.sjs
new file mode 100644
index 0000000..56ddbf1
--- /dev/null
+++ b/toolkit/content/tests/browser/bug471962_testpage_inner.sjs
@@ -0,0 +1,64 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla XUL Toolkit Testing Code.
+ *
+ * The Initial Developer of the Original Code is
+ * Paolo Amadini <http://www.amadzone.org/>.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Jeff Walden <jwalden+code@mit.edu>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+const CC = Components.Constructor;
+const BinaryInputStream = CC(""""@mozilla.org/binaryinputstream;1"""",
+                             """"nsIBinaryInputStream"""",
+                             """"setInputStream"""");
+
+function handleRequest(request, response)
+{
+  var body =
+   '<html>\
+    <body>\
+    Inner POST data: ';
+
+  var bodyStream = new BinaryInputStream(request.bodyInputStream);
+  var bytes = [], avail = 0;
+  while ((avail = bodyStream.available()) > 0)
+   body += String.fromCharCode.apply(String, bodyStream.readByteArray(avail));
+
+  body +=
+    '<form id=""""postForm"""" action=""""bug471962_testpage_inner.sjs"""" method=""""post"""">\
+     <input type=""""text"""" name=""""inputfield"""" value=""""inner"""">\
+     <input type=""""submit"""">\
+     </form>\
+     </body>\
+     </html>';
+
+  response.bodyOutputStream.write(body, body.length);
+}
diff --git a/toolkit/content/tests/browser/bug471962_testpage_outer.sjs b/toolkit/content/tests/browser/bug471962_testpage_outer.sjs
new file mode 100644
index 0000000..636c729
--- /dev/null
+++ b/toolkit/content/tests/browser/bug471962_testpage_outer.sjs
@@ -0,0 +1,67 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla XUL Toolkit Testing Code.
+ *
+ * The Initial Developer of the Original Code is
+ * Paolo Amadini <http://www.amadzone.org/>.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Jeff Walden <jwalden+code@mit.edu>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+const CC = Components.Constructor;
+const BinaryInputStream = CC(""""@mozilla.org/binaryinputstream;1"""",
+                             """"nsIBinaryInputStream"""",
+                             """"setInputStream"""");
+
+function handleRequest(request, response)
+{
+  var body =
+   '<html>\
+    <body>\
+    Outer POST data: ';
+
+  var bodyStream = new BinaryInputStream(request.bodyInputStream);
+  var bytes = [], avail = 0;
+  while ((avail = bodyStream.available()) > 0)
+   body += String.fromCharCode.apply(String, bodyStream.readByteArray(avail));
+
+  body +=
+    '<form id=""""postForm"""" action=""""bug471962_testpage_outer.sjs"""" method=""""post"""">\
+     <input type=""""text"""" name=""""inputfield"""" value=""""outer"""">\
+     <input type=""""submit"""">\
+     </form>\
+     \
+     <iframe id=""""innerFrame"""" src=""""bug471962_testpage_inner.sjs"""" width=""""400"""" height=""""200"""">\
+     \
+     </body>\
+     </html>';
+
+  response.bodyOutputStream.write(body, body.length);
+}"""
d085378ec9ca6185b91eacbf245bee6231f41adc,46812,471962,Gavin Sharp,"Bug 471962: wrong post data sent when saving an inner frame, r=bzbarsky
",1237229239,"""diff --git a/toolkit/content/contentAreaUtils.js b/toolkit/content/contentAreaUtils.js
index a9c33d1..7dfa67f 100644
--- a/toolkit/content/contentAreaUtils.js
+++ b/toolkit/content/contentAreaUtils.js
@@ -339,7 +339,7 @@ function internalSave(aURL, aDocument, aDefaultFileName, aContentDisposition,
                    saveAsType == kSaveAsType_Text) ?
                   """"text/plain"""" : null,
     target      : fileURL,
-    postData    : isDocument ? getPostData() : null,
+    postData    : isDocument ? getPostData(aDocument) : null,
     bypassCache : aShouldBypassCache
   };
 
@@ -686,10 +686,13 @@ function appendFiltersForContentType(aFilePicker, aContentType, aFileExtension,
   aFilePicker.appendFilters(Components.interfaces.nsIFilePicker.filterAll);
 }
 
-function getPostData()
+function getPostData(aDocument)
 {
   try {
-    var sessionHistory = getWebNavigation().sessionHistory;
+    var sessionHistory = aDocument.defaultView
+                                  .QueryInterface(Components.interfaces.nsIInterfaceRequestor)
+                                  .getInterface(Components.interfaces.nsIWebNavigation)
+                                  .sessionHistory;
     return sessionHistory.getEntryAtIndex(sessionHistory.index, false)
                          .QueryInterface(Components.interfaces.nsISHEntry)
                          .postData;"""
3168b3814588cfd0b0722febe8d099f608061d5e,46926,452913,Bob Clary,"bug 452913 - JavaScript Test by Gary Kwong.
",1237069628,"""diff --git a/js/tests/js1_8/extensions/regress-452913.js b/js/tests/js1_8/extensions/regress-452913.js
new file mode 100755
index 0000000..1501ae8
--- /dev/null
+++ b/js/tests/js1_8/extensions/regress-452913.js
@@ -0,0 +1,51 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is JavaScript Engine testing utilities.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Gary Kwong
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var gTestfile = 'regress-452913.js';
+//-----------------------------------------------------------------------------
+var BUGNUMBER = 452913;
+var summary = 'Do not crash with defined getter and for (let)';
+var actual = '';
+var expect = '';
+
+printBugNumber(BUGNUMBER);
+printStatus (summary);
+ 
+(this.__defineGetter__(""""x"""", function (x)'foo'.replace(/o/g, [1].push)));
+for(let y in [,,,]) for(let y in [,,,]) x = x;
+
+reportCompare(expect, actual, summary);"""
b5012821d5ee7cb2fcd0596b09c2c4dad0c7fb2d,47006,479880,Jason Duell,"Bug 479880.  Prevent failed SSL tunnel replies from being interpreted: replace with boilerplate error pages.  r=jwalden, sr=bzbarsky
",1240516172,"""diff --git a/netwerk/protocol/http/src/nsHttpChannel.cpp b/netwerk/protocol/http/src/nsHttpChannel.cpp
index 6076b2b..47f08fe 100644
--- a/netwerk/protocol/http/src/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/src/nsHttpChannel.cpp
@@ -853,6 +853,71 @@ nsHttpChannel::CallOnStartRequest()
 }
 
 nsresult
+nsHttpChannel::ProcessFailedSSLConnect(PRUint32 httpStatus)
+{
+    // Failure to set up SSL proxy tunnel means one of the following:
+    // 1) Proxy wants authorization, or forbids.
+    // 2) DNS at proxy couldn't resolve target URL.
+    // 3) Proxy connection to target failed or timed out.
+    // 4) Eve noticed our proxy CONNECT, and is replying with malicious HTML.
+    // 
+    // Our current architecture will parse response content with the
+    // permission of the target URL!  Given #4, we must avoid rendering the
+    // body of the reply, and instead give the user a (hopefully helpful) 
+    // boilerplate error page, based on just the HTTP status of the reply.
+
+    NS_ABORT_IF_FALSE(mConnectionInfo->UsingSSL(),
+                      """"SSL connect failed but not using SSL?"""");
+    nsresult rv;
+    switch (httpStatus) 
+    {
+    case 403: // HTTP/1.1: """"Forbidden""""
+    case 407: // ProcessAuthentication() failed
+    case 501: // HTTP/1.1: """"Not Implemented""""
+        // user sees boilerplate Mozilla """"Proxy Refused Connection"""" page.
+        rv = NS_ERROR_PROXY_CONNECTION_REFUSED; 
+        break;
+    // Squid sends 404 if DNS fails (regular 404 from target is tunneled)
+    case 404: // HTTP/1.1: """"Not Found""""
+    // RFC 2616: """"some deployed proxies are known to return 400 or 500 when
+    // DNS lookups time out.""""  (Squid uses 500 if it runs out of sockets: so
+    // we have a conflict here).
+    case 400: // HTTP/1.1 """"Bad Request""""
+    case 500: // HTTP/1.1: """"Internal Server Error""""
+        /* User sees: """"Address Not Found: Firefox can't find the server at
+         * www.foo.com.""""
+         */
+        rv = NS_ERROR_UNKNOWN_HOST; 
+        break;
+    case 502: // HTTP/1.1: """"Bad Gateway"""" (invalid resp from target server)
+    // Squid returns 503 if target request fails for anything but DNS.
+    case 503: // HTTP/1.1: """"Service Unavailable""""
+        /* User sees: """"Failed to Connect:
+         *  Firefox can't establish a connection to the server at
+         *  www.foo.com.  Though the site seems valid, the browser
+         *  was unable to establish a connection.""""
+         */
+        rv = NS_ERROR_CONNECTION_REFUSED;
+        break;
+    // RFC 2616 uses 504 for both DNS and target timeout, so not clear what to
+    // do here: picking target timeout, as DNS covered by 400/404/500
+    case 504: // HTTP/1.1: """"Gateway Timeout"""" 
+        // user sees: """"Network Timeout: The server at www.foo.com
+        //              is taking too long to respond.""""
+        rv = NS_ERROR_NET_TIMEOUT;
+        break;
+    // Confused proxy server or malicious response
+    default:
+        rv = NS_ERROR_PROXY_CONNECTION_REFUSED; 
+        break;
+    }
+    LOG((""""Cancelling failed SSL proxy connection [this=%x httpStatus=%u]\n"""",
+         this, httpStatus)); 
+    Cancel(rv);
+    return rv;
+}
+
+nsresult
 nsHttpChannel::ProcessResponse()
 {
     nsresult rv;
@@ -861,6 +926,9 @@ nsHttpChannel::ProcessResponse()
     LOG((""""nsHttpChannel::ProcessResponse [this=%x httpStatus=%u]\n"""",
         this, httpStatus));
 
+    if (mTransaction->SSLConnectFailed() && httpStatus != 407)
+        return ProcessFailedSSLConnect(httpStatus);
+
     // notify """"http-on-examine-response"""" observers
     gHttpHandler->OnExamineResponse(this);
 
@@ -947,6 +1015,8 @@ nsHttpChannel::ProcessResponse()
         rv = ProcessAuthentication(httpStatus);
         if (NS_FAILED(rv)) {
             LOG((""""ProcessAuthentication failed [rv=%x]\n"""", rv));
+            if (mTransaction->SSLConnectFailed())
+                return ProcessFailedSSLConnect(httpStatus);
             CheckForSuperfluousAuth();
             rv = ProcessNormal();
         }
diff --git a/netwerk/protocol/http/src/nsHttpChannel.h b/netwerk/protocol/http/src/nsHttpChannel.h
index a3523af..f3a6dcd 100644
--- a/netwerk/protocol/http/src/nsHttpChannel.h
+++ b/netwerk/protocol/http/src/nsHttpChannel.h
@@ -172,6 +172,7 @@ private:
     nsresult ProcessNormal();
     nsresult ProcessNotModified();
     nsresult ProcessRedirection(PRUint32 httpStatus);
+    nsresult ProcessFailedSSLConnect(PRUint32 httpStatus);
     nsresult ProcessAuthentication(PRUint32 httpStatus);
     nsresult ProcessFallback(PRBool *fallingBack);
     PRBool   ResponseWouldVary();"""
cdf0797ac0373a4a85da64e2ad70d3dfe02dd750,47377,481342,Dave Camp,"Bug 481342 - Fix some unpacking logic.  r+sr=bz

--HG--
rename : docshell/test/bug369814.zip => docshell/test/bug369814.jar
",1236722280,"""diff --git a/docshell/test/Makefile.in b/docshell/test/Makefile.in
index 87fbffe..fd58880 100644
--- a/docshell/test/Makefile.in
+++ b/docshell/test/Makefile.in
@@ -61,6 +61,7 @@ _TEST_FILES = \
 		test_bug344861.html \
 		test_bug369814.html \
 		bug369814.zip \
+		bug369814.jar \
 		test_bug384014.html \
 		test_bug387979.html \
 		test_bug404548.html \
diff --git a/docshell/test/bug369814.jar b/docshell/test/bug369814.jar
new file mode 100644
index 0000000..86b9c8c
Binary files /dev/null and b/docshell/test/bug369814.jar differ
diff --git a/docshell/test/test_bug369814.html b/docshell/test/test_bug369814.html
index 85a7b3b..7944b95 100644
--- a/docshell/test/test_bug369814.html
+++ b/docshell/test/test_bug369814.html
@@ -149,6 +149,18 @@ var gTests = [
     """"pokes"""" : { },
     """"func"""" : anchorTest,
   },
+  { """"name"""" : """"iframes.html loaded from view-source jar type, pref disabled"""",
+    """"url"""" : """"jar:view-source:http://localhost:8888/tests/docshell/test/bug369814.jar!/iframes.html"""",
+    """"pref"""" : true,
+    """"pokes"""" : { },
+    """"func"""" : loadErrorTest
+  },
+  { """"name"""" : """"iframes.html loaded from view-source jar type, pref enabled"""",
+    """"url"""" : """"jar:view-source:http://localhost:8888/tests/docshell/test/bug369814.jar!/iframes.html"""",
+    """"pref"""" : true,
+    """"pokes"""" : { },
+    """"func"""" : loadErrorTest
+  },
 ];
 
 var gNextTest = 0;
diff --git a/modules/libjar/nsJARChannel.cpp b/modules/libjar/nsJARChannel.cpp
index e1f2464..2b17b0f 100644
--- a/modules/libjar/nsJARChannel.cpp
+++ b/modules/libjar/nsJARChannel.cpp
@@ -46,6 +46,7 @@
 #include """"nsEscape.h""""
 #include """"nsIPrefService.h""""
 #include """"nsIPrefBranch.h""""
+#include """"nsIViewSourceChannel.h""""
 #include """"nsChannelProperties.h""""
 
 #include """"nsIScriptSecurityManager.h""""
@@ -786,8 +787,11 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
             nsCAutoString contentType;
             nsCAutoString charset;
             NS_ParseContentType(header, contentType, charset);
-            mIsUnsafe = !contentType.EqualsLiteral(""""application/java-archive"""") &&
-                        !contentType.EqualsLiteral(""""application/x-jar"""");
+            nsCAutoString channelContentType;
+            channel->GetContentType(channelContentType);
+            mIsUnsafe = !(contentType.Equals(channelContentType) &&
+                          (contentType.EqualsLiteral(""""application/java-archive"""") ||
+                           contentType.EqualsLiteral(""""application/x-jar"""")));
             rv = httpChannel->GetResponseHeader(NS_LITERAL_CSTRING(""""Content-Disposition""""),
                                                 header);
             if (NS_SUCCEEDED(rv))
@@ -821,6 +825,14 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
     }
 
     if (NS_SUCCEEDED(status)) {
+        // Refuse to unpack view-source: jars even if open-unsafe-types is set.
+        nsCOMPtr<nsIViewSourceChannel> viewSource = do_QueryInterface(channel);
+        if (viewSource) {
+            status = NS_ERROR_UNSAFE_CONTENT_TYPE;
+        }
+    }
+
+    if (NS_SUCCEEDED(status)) {
         mJarFile = file;
     
         rv = CreateJarInput(nsnull);"""
848c75bbb831613f1ac9354d0ab158137183cced,47390,459524,Nelson Bolyard,"Bug 459524 - Interpret SOCKS5 DNS reply more accurately, r=biesi
",1236716046,"""diff --git a/netwerk/socket/base/nsSOCKSIOLayer.cpp b/netwerk/socket/base/nsSOCKSIOLayer.cpp
index 48ab7ab..7ef9f74 100644
--- a/netwerk/socket/base/nsSOCKSIOLayer.cpp
+++ b/netwerk/socket/base/nsSOCKSIOLayer.cpp
@@ -162,21 +162,41 @@ nsSOCKSSocketInfo::SetInternalProxyAddr(PRNetAddr *aInternalProxyAddr)
     return NS_OK;
 }
 
+static PRInt32
+pr_RecvAll(PRFileDesc *fd, unsigned char *buf, PRInt32 amount, PRIntn flags, 
+           PRIntervalTime timeout)
+{
+    PRInt32 bytesRead = 0;
+    PRInt32 offset = 0;
+
+    while (offset < amount) {
+    	bytesRead = PR_Recv(fd, buf + offset, amount - offset, flags, timeout);
+	if (bytesRead > 0) {
+	    offset += bytesRead;
+	} else if (bytesRead == 0 || offset != 0) {
+	    return offset;
+	} else {
+	    return bytesRead;
+	}
+    }
+    return offset;
+}
 
 // Negotiate a SOCKS 5 connection. Assumes the TCP connection to the socks 
 // server port has been established.
 static nsresult
 ConnectSOCKS5(PRFileDesc *fd, const PRNetAddr *addr, PRNetAddr *extAddr, PRIntervalTime timeout)
 {
+    int request_len = 0;
+    int response_len = 0;
+    int desired_len = 0;
+    unsigned char request[22];
+    unsigned char response[262];
+
     NS_ENSURE_TRUE(fd, NS_ERROR_NOT_INITIALIZED);
     NS_ENSURE_TRUE(addr, NS_ERROR_NOT_INITIALIZED);
     NS_ENSURE_TRUE(extAddr, NS_ERROR_NOT_INITIALIZED);
 
-    unsigned char request[22];
-    int request_len = 0;
-    unsigned char response[22];
-    int response_len = 0;
-
     request[0] = 0x05; // SOCKS version 5
     request[1] = 0x01; // number of auth procotols we recognize
     // auth protocols
@@ -197,11 +217,11 @@ ConnectSOCKS5(PRFileDesc *fd, const PRNetAddr *addr, PRNetAddr *extAddr, PRInter
         return NS_ERROR_FAILURE;
     }
 
-    // get the server's response. Use PR_Recv() instead of 
-    response_len = 2;
-    response_len = PR_Recv(fd, response, response_len, 0, timeout);
+    // get the server's response. 
+    desired_len = 2;
+    response_len = pr_RecvAll(fd, response, desired_len, 0, timeout);
 
-    if (response_len <= 0) {
+    if (response_len < desired_len) {
 
         LOGERROR((""""PR_Recv() failed. response_len = %d."""", response_len));
         return NS_ERROR_FAILURE;
@@ -357,17 +377,14 @@ ConnectSOCKS5(PRFileDesc *fd, const PRNetAddr *addr, PRNetAddr *extAddr, PRInter
         return NS_ERROR_FAILURE;
     }
 
-    response_len = 22;
-    response_len = PR_Recv(fd, response, response_len, 0, timeout);
-    if (response_len <= 0) {
-
-        // bad read
+    desired_len = 5;
+    response_len = pr_RecvAll(fd, response, desired_len, 0, timeout);
+    if (response_len < desired_len) { // bad read
         LOGERROR((""""PR_Recv() failed getting connect command reply. response_len = %d."""", response_len));
         return NS_ERROR_FAILURE;
     }
 
     if (response[0] != 0x05) {
-
         // bad response
         LOGERROR((""""Not a SOCKS 5 reply. Expected: 5; received: %x"""", response[0]));
         return NS_ERROR_FAILURE;
@@ -397,6 +414,26 @@ ConnectSOCKS5(PRFileDesc *fd, const PRNetAddr *addr, PRNetAddr *extAddr, PRInter
 
     }
 
+    switch (response[3]) {
+        case 0x01: // IPv4
+	    desired_len = 4 + 2 - 1;
+            break;
+        case 0x03: // FQDN 
+	    desired_len = response[4] + 2;
+            break;
+        case 0x04: // IPv6
+	    desired_len = 16 + 2 - 1;
+            break;
+        default: // unknown format
+            return NS_ERROR_FAILURE;
+            break;
+    }
+    response_len = pr_RecvAll(fd, response + 5, desired_len, 0, timeout);
+    if (response_len < desired_len) { // bad read
+        LOGERROR((""""PR_Recv() failed getting connect command reply. response_len = %d."""", response_len));
+        return NS_ERROR_FAILURE;
+    }
+    response_len += 5;
 
     // get external bound address (this is what 
     // the outside world sees as """"us"""")
@@ -434,17 +471,16 @@ ConnectSOCKS5(PRFileDesc *fd, const PRNetAddr *addr, PRNetAddr *extAddr, PRInter
             *ip++ = response[18]; *ip++ = response[19];
 
             break;
-        case 0x03: // FQDN (should not get this back)
-        default: // unknown format
+        case 0x03: // FQDN 
             // if we get here, we don't know our external address.
             // however, as that's possibly not critical to the user,
             // we let it slide.
-            PR_InitializeNetAddr(PR_IpAddrNull, 0, extAddr);
-            //return NS_ERROR_FAILURE;
+            extPort = (response[response_len - 2] << 8) | 
+                       response[response_len - 1];
+            PR_InitializeNetAddr(PR_IpAddrNull, extPort, extAddr);
             break;
     }
     return NS_OK;
-
 }
 
 // Negotiate a SOCKS 4 connection. Assumes the TCP connection to the socks 
@@ -452,15 +488,16 @@ ConnectSOCKS5(PRFileDesc *fd, const PRNetAddr *addr, PRNetAddr *extAddr, PRInter
 static nsresult
 ConnectSOCKS4(PRFileDesc *fd, const PRNetAddr *addr, PRIntervalTime timeout)
 {
-    NS_ENSURE_TRUE(fd, NS_ERROR_NOT_INITIALIZED);
-    NS_ENSURE_TRUE(addr, NS_ERROR_NOT_INITIALIZED);
-
-    unsigned char request[12];
     int request_len = 0;
     int write_len;
-    unsigned char response[10];
     int response_len = 0;
+    int desired_len = 0;
     char *ip = nsnull;
+    unsigned char request[12];
+    unsigned char response[10];
+
+    NS_ENSURE_TRUE(fd, NS_ERROR_NOT_INITIALIZED);
+    NS_ENSURE_TRUE(addr, NS_ERROR_NOT_INITIALIZED);
 
     request[0] = 0x04; // SOCKS version 4
     request[1] = 0x01; // CD command code -- 1 for connect
@@ -564,10 +601,9 @@ ConnectSOCKS4(PRFileDesc *fd, const PRNetAddr *addr, PRIntervalTime timeout)
     }
 
     // get the server's response
-    response_len = 8;	// size of the response
-    response_len = PR_Recv(fd, response, response_len, 0, timeout);
-
-    if (response_len <= 0) {
+    desired_len = 8;	// size of the response
+    response_len = pr_RecvAll(fd, response, desired_len, 0, timeout);
+    if (response_len < desired_len) {
         LOGERROR((""""PR_Recv() failed. response_len = %d."""", response_len));
         return NS_ERROR_FAILURE;
     }"""
604d0516c6835d59368159ab59dad0a73da0f5e6,47417,481558,Jonas Sicking,"Bug 481558: Don't apply XBL that isn't located in the same domain as the bound document. r/sr=bz

--HG--
extra : rebase_source : 6ef8c8ffcf8d9df0f6f9a0cdadd45f12564d7e37
",1236665706,"""diff --git a/content/xbl/src/nsXBLService.cpp b/content/xbl/src/nsXBLService.cpp
index f9c76ee..35d6ff2 100644
--- a/content/xbl/src/nsXBLService.cpp
+++ b/content/xbl/src/nsXBLService.cpp
@@ -1103,6 +1103,25 @@ nsXBLService::LoadBindingDocumentInfo(nsIContent* aBoundElement,
                               nsIContentPolicy::TYPE_XBL,
                               aBoundDocument);
     NS_ENSURE_SUCCESS(rv, rv);
+
+    // Also make sure that we're same-origin with the bound document
+    // except if the stylesheet is a UA stylesheet. We fake testing
+    // for UA stylesheets by calling CheckLoadURI.
+    nsCOMPtr<nsIURI> principalURI;
+    rv = aOriginPrincipal->GetURI(getter_AddRefs(principalURI));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    if (principalURI) {
+      nsresult uaCheckRes =
+        nsContentUtils::GetSecurityManager()->
+        CheckLoadURIWithPrincipal(aBoundDocument->NodePrincipal(),
+                                  principalURI, 0);
+      if (NS_SUCCEEDED(uaCheckRes)) {
+        rv = aBoundDocument->NodePrincipal()->CheckMayLoad(aBindingURI,
+                                                           PR_TRUE);
+        NS_ENSURE_SUCCESS(rv, rv);
+      }
+    }
   }
 
   *aResult = nsnull;
diff --git a/content/xbl/test/Makefile.in b/content/xbl/test/Makefile.in
index f2dd3cb..73954c1 100644
--- a/content/xbl/test/Makefile.in
+++ b/content/xbl/test/Makefile.in
@@ -67,6 +67,9 @@ _TEST_FILES =	\
 		file_bug379959_cross.html \
 		file_bug379959_xbl.xml \
 		test_bug468210.xhtml \
+		test_bug481558.html \
+		file_bug481558css.sjs \
+		file_bug481558.xbl \
 		$(NULL)
 
 libs:: $(_TEST_FILES)
diff --git a/content/xbl/test/file_bug481558.xbl b/content/xbl/test/file_bug481558.xbl
new file mode 100644
index 0000000..1d6d305
--- /dev/null
+++ b/content/xbl/test/file_bug481558.xbl
@@ -0,0 +1,13 @@
+<bindings xmlns=""""http://www.mozilla.org/xbl""""
+          xmlns:xbl=""""http://www.mozilla.org/xbl""""
+          xmlns:html=""""http://www.w3.org/1999/xhtml"""">
+<binding id=""""test"""">
+  <content>
+    <children/>
+    Binding Attached
+  </content>
+  <implementation>
+    <property name=""""xblBoundProperty"""" onget=""""return 1;""""/>
+  </implementation>
+</binding>
+</bindings>
diff --git a/content/xbl/test/file_bug481558css.sjs b/content/xbl/test/file_bug481558css.sjs
new file mode 100644
index 0000000..a4b5333
--- /dev/null
+++ b/content/xbl/test/file_bug481558css.sjs
@@ -0,0 +1,17 @@
+function handleRequest(request, response)
+{
+  var query = {};
+  request.queryString.split('&').forEach(function (val) {
+    [name, value] = val.split('=');
+    query[name] = unescape(value);
+  });
+
+  response.setHeader(""""Content-Type"""", """"text/css"""", false);
+  css = """"#"""" + query.id + """" { -moz-binding: url(\"""""""";
+  if (query.server) {
+    css += """"http://"""" + query.server + """"/tests/content/xbl/test/"""";
+  }
+  css += """"file_bug481558.xbl#test\""""); }"""";
+
+  response.write(css);
+}
diff --git a/content/xbl/test/test_bug481558.html b/content/xbl/test/test_bug481558.html
new file mode 100644
index 0000000..92389f5
--- /dev/null
+++ b/content/xbl/test/test_bug481558.html
@@ -0,0 +1,39 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=481558
+-->
+<head>
+  <title>Test for Bug 481558</title>
+  <script type=""""text/javascript"""" src=""""/MochiKit/MochiKit.js""""></script>
+  <script type=""""text/javascript"""" src=""""/tests/SimpleTest/SimpleTest.js""""></script>
+  <link rel=""""stylesheet"""" type=""""text/css"""" href=""""/tests/SimpleTest/test.css"""">
+  <link rel=""""stylesheet"""" type=""""text/css""""
+        href=""""file_bug481558css.sjs?id=id1"""">
+  <link rel=""""stylesheet"""" type=""""text/css""""
+        href=""""file_bug481558css.sjs?id=id2&server=example.com"""">
+  <link rel=""""stylesheet"""" type=""""text/css"""" href=""""http://example.com/tests/content/xbl/test/file_bug481558css.sjs?id=id3"""">
+  <link rel=""""stylesheet"""" type=""""text/css"""" href=""""http://example.com/tests/content/xbl/test/file_bug481558css.sjs?id=id4&server=example.com"""">
+</head>
+<body onload=""""runTest();"""">
+<a target=""""_blank"""" href=""""https://bugzilla.mozilla.org/show_bug.cgi?id=481558"""">Mozilla Bug 481558</a>
+<p id=""""id1""""></p>
+<p id=""""id2""""></p>
+<p id=""""id3""""></p>
+<p id=""""id4""""></p>
+<pre id=""""test"""">
+<script class=""""testbody"""" type=""""text/javascript"""">
+
+SimpleTest.waitForExplicitFinish();
+function runTest() {
+  is ($('id1').xblBoundProperty, 1, """"XBL should be attached"""");
+  is ($('id2').xblBoundProperty, undefined, """"XBL shouldn't be attached"""");
+  is ($('id3').xblBoundProperty, undefined, """"XBL shouldn't be attached"""");
+  is ($('id4').xblBoundProperty, undefined, """"XBL shouldn't be attached"""");
+  SimpleTest.finish();
+}
+
+</script>
+</pre>
+</body>
+</html>"""
a67529d45e1d2bbd2ac83ed60237fc06026100b4,47461,473709,Bob Clary,"bug 473709 - JavaScript Test by Gary Kwong.
",1236302112,"""diff --git a/js/tests/e4x/Regress/regress-473709.js b/js/tests/e4x/Regress/regress-473709.js
new file mode 100755
index 0000000..d072ad7
--- /dev/null
+++ b/js/tests/e4x/Regress/regress-473709.js
@@ -0,0 +1,66 @@
+/* -*- Mode: java; tab-width:8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is JavaScript Engine testing utilities.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Gary Kwong
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+gTestfile = 'regress-473709.js';
+
+var summary = 'Do not assert: cursor == (uint8 *)copy->messageArgs[0] + argsCopySize';
+var BUGNUMBER = 473709;
+var actual = '';
+var expect = '';
+
+printBugNumber(BUGNUMBER);
+START(summary);
+
+function f() { eval(""""(function() { switch(x, x) { default: for(x2; <x><y/></x>;) (function(){}) <x><y/></x>;break; case (+<><x><y/></x></>): break;   }; })()""""); }
+
+if (typeof gczeal == 'function')
+{
+    gczeal(2);
+}
+
+try
+{
+    f();
+}
+catch(ex)
+{
+}
+
+TEST(1, expect, actual);
+
+END();"""
ba6d1ffde6d1a50c49d01873d8adc68d05253038,47832,478901,Daniel Veditz,"bug 478901 update to libpng 1.2.35, patch by Glenn Randers-Pehrson, r=Joe Drew, sr=dveditz, blocking=vlad
",1235898925,"""diff --git a/modules/libimg/png/CHANGES b/modules/libimg/png/CHANGES
index 3f04811..da52eab 100644
--- a/modules/libimg/png/CHANGES
+++ b/modules/libimg/png/CHANGES
@@ -2186,7 +2186,7 @@ version 1.2.30beta03 [July 6, 2008]
 version 1.2.30beta04 [July 10, 2008]
   Merged more cosmetic whitespace changes from libpng-1.4.0beta19.
 
-version 1.0.38rc01, 1.2.30rc01 [December 18, 2008]
+version 1.0.38rc01, 1.2.30rc01 [July 18, 2008]
   No changes.
 
 version 1.0.38rc02, 1.2.30rc02 [July 21, 2008]
@@ -2309,6 +2309,25 @@ version 1.0.42rc01, 1.2.34rc01 [December 11, 2008]
 version 1.0.42, 1.2.34 [December 18, 2008]
   No changes.
 
+version 1.2.35beta01 [February 4, 2009]
+  Zero out some arrays of pointers after png_malloc(). (Tavis Ormandy)
+
+version 1.2.35beta02 [Feburary 4, 2009]
+  Zero out more arrays of pointers after png_malloc().
+
+version 1.2.35beta03 [February 5, 2009]
+  Use png_memset() instead of a loop to intialize pointers.  We realize
+    this will not work on platforms where the NULL pointer is not all zeroes.
+
+version 1.2.35rc01 [February 11, 2009]
+  No changes.
+
+version 1.2.35rc02 [February 12, 2009]
+  Fix typo in new png_memset call in pngset.c (png_color should be png_charp)
+
+version 1.0.43 and 1.2.35 [February 14, 2009]
+  No changes.
+
 Send comments/corrections/commendations to png-mng-implement at lists.sf.net
 (subscription required; visit
 https://lists.sourceforge.net/lists/listinfo/png-mng-implement
diff --git a/modules/libimg/png/LICENSE b/modules/libimg/png/LICENSE
index 4597e13..50b4041 100644
--- a/modules/libimg/png/LICENSE
+++ b/modules/libimg/png/LICENSE
@@ -8,7 +8,7 @@ COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:
 If you modify libpng you may insert additional notices immediately following
 this sentence.
 
-libpng versions 1.2.6, August 15, 2004, through 1.2.34, December 18, 2008, are
+libpng versions 1.2.6, August 15, 2004, through 1.2.35, February 14, 2009, are
 Copyright (c) 2004, 2006-2008 Glenn Randers-Pehrson, and are
 distributed according to the same disclaimer and license as libpng-1.2.5
 with the following individual added to the list of Contributing Authors
@@ -106,4 +106,4 @@ certification mark of the Open Source Initiative.
 
 Glenn Randers-Pehrson
 glennrp at users.sourceforge.net
-December 18, 2008
+February 14, 2009
diff --git a/modules/libimg/png/MOZCHANGES b/modules/libimg/png/MOZCHANGES
index 1201997..1e8af5e 100644
--- a/modules/libimg/png/MOZCHANGES
+++ b/modules/libimg/png/MOZCHANGES
@@ -1,6 +1,8 @@
 
 Changes made to pristine png source by mozilla.org developers.
 
+2009/02/19  -- Synced with libpng-1.2.35 (bug #478901).
+
 2008/08/21  -- Synced with libpng-1.2.31 (bug #418900).
 
 2008/03/29  -- Initialize prev_row for each APNG frame, only when
diff --git a/modules/libimg/png/README b/modules/libimg/png/README
index 3dd92f4..6d57ac4 100644
--- a/modules/libimg/png/README
+++ b/modules/libimg/png/README
@@ -1,4 +1,4 @@
-README for libpng version 1.2.34 - December 18, 2008 (shared library 12.0)
+README for libpng version 1.2.35 - February 14, 2009 (shared library 12.0)
 See the note about version numbers near the top of png.h
 
 See INSTALL for instructions on how to install libpng.
@@ -194,11 +194,11 @@ Files in this distribution:
        descrip.mms      =>  VMS makefile for MMS or MMK
        makefile.std     =>  Generic UNIX makefile (cc, creates static libpng.a)
        makefile.elf     =>  Linux/ELF makefile symbol versioning,
-                            gcc, creates libpng12.so.0.1.2.34)
+                            gcc, creates libpng12.so.0.1.2.35)
        makefile.linux   =>  Linux/ELF makefile
-                            (gcc, creates libpng12.so.0.1.2.34)
+                            (gcc, creates libpng12.so.0.1.2.35)
        makefile.gcmmx   =>  Linux/ELF makefile
-                            (gcc, creates libpng12.so.0.1.2.34,
+                            (gcc, creates libpng12.so.0.1.2.35,
                             uses assembler code tuned for Intel MMX platform)
        makefile.gcc     =>  Generic makefile (gcc, creates static libpng.a)
        makefile.knr     =>  Archaic UNIX Makefile that converts files with
@@ -220,12 +220,12 @@ Files in this distribution:
        makefile.openbsd =>  OpenBSD makefile
        makefile.sgi     =>  Silicon Graphics IRIX (cc, creates static lib)
        makefile.sggcc   =>  Silicon Graphics
-                            (gcc, creates libpng12.so.0.1.2.34)
+                            (gcc, creates libpng12.so.0.1.2.35)
        makefile.sunos   =>  Sun makefile
        makefile.solaris =>  Solaris 2.X makefile
-                            (gcc, creates libpng12.so.0.1.2.34)
+                            (gcc, creates libpng12.so.0.1.2.35)
        makefile.so9     =>  Solaris 9 makefile
-                            (gcc, creates libpng12.so.0.1.2.34)
+                            (gcc, creates libpng12.so.0.1.2.35)
        makefile.32sunu  =>  Sun Ultra 32-bit makefile
        makefile.64sunu  =>  Sun Ultra 64-bit makefile
        makefile.sco     =>  For SCO OSr5  ELF and Unixware 7 with Native cc
diff --git a/modules/libimg/png/libpng.txt b/modules/libimg/png/libpng.txt
index f9921aa..4f56736 100644
--- a/modules/libimg/png/libpng.txt
+++ b/modules/libimg/png/libpng.txt
@@ -1,15 +1,15 @@
   libpng.txt - A description on how to use and modify libpng
   
- libpng version 1.2.34 - December 18, 2008
+ libpng version 1.2.35 - February 14, 2009
  Updated and distributed by Glenn Randers-Pehrson
  <glennrp at users.sourceforge.net>
- Copyright (c) 1998-2008 Glenn Randers-Pehrson
+ Copyright (c) 1998-2009 Glenn Randers-Pehrson
  For conditions of distribution and use, see copyright
  notice in png.h.
   
  Based on:
   
- libpng versions 0.97, January 1998, through 1.2.34 - December 18, 2008
+ libpng versions 0.97, January 1998, through 1.2.35 - February 14, 2009
  Updated and distributed by Glenn Randers-Pehrson
  Copyright (c) 1998-2008 Glenn Randers-Pehrson
 
@@ -472,6 +472,8 @@ row_pointers prior to calling png_read_png() with
    row_pointers = png_malloc(png_ptr,
       height*png_sizeof(png_bytep));
    for (int i=0; i<height, i++)
+      row_pointers[i]=NULL;  /* security precaution */
+   for (int i=0; i<height, i++)
       row_pointers[i]=png_malloc(png_ptr,
          width*pixel_size);
    png_set_rows(png_ptr, info_ptr, &row_pointers);
@@ -2851,13 +2853,13 @@ application:
 
 IX. Y2K Compliance in libpng
 
-August 21, 2008
+February 14, 2009
 
 Since the PNG Development group is an ad-hoc body, we can't make
 an official declaration.
 
 This is your unofficial assurance that libpng from version 0.71 and
-upward through 1.2.31 are Y2K compliant.  It is my belief that earlier
+upward through 1.2.35 are Y2K compliant.  It is my belief that earlier
 versions were also Y2K compliant.
 
 Libpng only has three year fields.  One is a 2-byte unsigned integer that
diff --git a/modules/libimg/png/png.c b/modules/libimg/png/png.c
index ae78dd3..2f8fcb0 100644
--- a/modules/libimg/png/png.c
+++ b/modules/libimg/png/png.c
@@ -13,7 +13,7 @@
 #include """"png.h""""
 
 /* Generate a compiler error if there is an old png.h in the search path. */
-typedef version_1_2_34 Your_png_h_is_not_version_1_2_34;
+typedef version_1_2_35 Your_png_h_is_not_version_1_2_35;
 
 /* Version information for C files.  This had better match the version
  * string defined in png.h.  */
@@ -697,7 +697,7 @@ png_charp PNGAPI
 png_get_copyright(png_structp png_ptr)
 {
    png_ptr = png_ptr;  /* silence compiler warning about unused png_ptr */
-   return ((png_charp) """"\n libpng version 1.2.34 - December 18, 2008\n\
+   return ((png_charp) """"\n libpng version 1.2.35 - February 14, 2009\n\
    Copyright (c) 1998-2008 Glenn Randers-Pehrson\n\
    Copyright (c) 1996-1997 Andreas Dilger\n\
    Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n"""");
diff --git a/modules/libimg/png/png.h b/modules/libimg/png/png.h
index b9bee0b..969c8e1 100644
--- a/modules/libimg/png/png.h
+++ b/modules/libimg/png/png.h
@@ -1,14 +1,14 @@
 /* png.h - header file for PNG reference library
  *
- * libpng version 1.2.34 - December 18, 2008
- * Copyright (c) 1998-2008 Glenn Randers-Pehrson
+ * libpng version 1.2.35 - February 14, 2009
+ * Copyright (c) 1998-2009 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
  * Authors and maintainers:
  *  libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
  *  libpng versions 0.89c, June 1996, through 0.96, May 1997: Andreas Dilger
- *  libpng versions 0.97, January 1998, through 1.2.34 - December 18, 2008: Glenn
+ *  libpng versions 0.97, January 1998, through 1.2.35 - February 14, 2009: Glenn
  *  See also """"Contributing Authors"""", below.
  *
  * Note about libpng version numbers:
@@ -217,6 +217,11 @@
  *    1.2.34rc01              13    10234  12.so.0.34[.0]
  *    1.0.42                  10    10042  10.so.0.42[.0]
  *    1.2.34                  13    10234  12.so.0.34[.0]
+ *    1.2.35beta01-03         13    10235  12.so.0.35[.0]
+ *    1.0.43rc01-02           10    10043  10.so.0.43[.0]
+ *    1.2.35rc01-02           13    10235  12.so.0.35[.0]
+ *    1.0.43                  10    10043  10.so.0.43[.0]
+ *    1.2.35                  13    10235  12.so.0.35[.0]
  *
  *    Henceforth the source version will match the shared-library major
  *    and minor numbers; the shared-library major version number will be
@@ -246,7 +251,7 @@
  * If you modify libpng you may insert additional notices immediately following
  * this sentence.
  *
- * libpng versions 1.2.6, August 15, 2004, through 1.2.34, December 18, 2008, are
+ * libpng versions 1.2.6, August 15, 2004, through 1.2.35, February 14, 2009, are
  * Copyright (c) 2004, 2006-2008 Glenn Randers-Pehrson, and are
  * distributed according to the same disclaimer and license as libpng-1.2.5
  * with the following individual added to the list of Contributing Authors:
@@ -358,13 +363,13 @@
  * Y2K compliance in libpng:
  * =========================
  *
- *    December 18, 2008
+ *    February 14, 2009
  *
  *    Since the PNG Development group is an ad-hoc body, we can't make
  *    an official declaration.
  *
  *    This is your unofficial assurance that libpng from version 0.71 and
- *    upward through 1.2.34 are Y2K compliant.  It is my belief that earlier
+ *    upward through 1.2.35 are Y2K compliant.  It is my belief that earlier
  *    versions were also Y2K compliant.
  *
  *    Libpng only has three year fields.  One is a 2-byte unsigned integer
@@ -420,9 +425,9 @@
  */
 
 /* Version information for png.h - this should match the version in png.c */
-#define PNG_LIBPNG_VER_STRING """"1.2.34""""
+#define PNG_LIBPNG_VER_STRING """"1.2.35""""
 #define PNG_HEADER_VERSION_STRING \
-   """" libpng version 1.2.34 - December 18, 2008\n""""
+   """" libpng version 1.2.35 - February 14, 2009\n""""
 
 #define PNG_LIBPNG_VER_SONUM   0
 #define PNG_LIBPNG_VER_DLLNUM  13
@@ -430,7 +435,7 @@
 /* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
 #define PNG_LIBPNG_VER_MAJOR   1
 #define PNG_LIBPNG_VER_MINOR   2
-#define PNG_LIBPNG_VER_RELEASE 34
+#define PNG_LIBPNG_VER_RELEASE 35
 /* This should match the numeric part of the final component of
  * PNG_LIBPNG_VER_STRING, omitting any leading zero: */
 
@@ -458,7 +463,7 @@
  * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only
  * version 1.0.0 was mis-numbered 100 instead of 10000).  From
  * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release */
-#define PNG_LIBPNG_VER 10234 /* 1.2.34 */
+#define PNG_LIBPNG_VER 10235 /* 1.2.35 */
 
 #ifndef PNG_VERSION_INFO_ONLY
 /* include the compression library's header */
@@ -1534,7 +1539,7 @@ struct png_struct_def
 /* This triggers a compiler error in png.c, if png.c and png.h
  * do not agree upon the version number.
  */
-typedef png_structp version_1_2_34;
+typedef png_structp version_1_2_35;
 
 typedef png_struct FAR * FAR * png_structpp;
 
diff --git a/modules/libimg/png/pngconf.h b/modules/libimg/png/pngconf.h
index e47d53c..f6a4465 100644
--- a/modules/libimg/png/pngconf.h
+++ b/modules/libimg/png/pngconf.h
@@ -1,9 +1,9 @@
 
 /* pngconf.h - machine configurable file for libpng
  *
- * libpng version 1.2.34 - December 18, 2008
+ * libpng version 1.2.35 - February 14, 2009
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2008 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2009 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  */
@@ -235,6 +235,8 @@
 #  include <windows.h>
    /* Console I/O functions are not supported on WindowsCE */
 #  define PNG_NO_CONSOLE_IO
+   /* abort() may not be supported on some/all Windows CE platforms */
+#  define PNG_ABORT() exit(-1)
 #  ifdef PNG_DEBUG
 #    undef PNG_DEBUG
 #  endif
diff --git a/modules/libimg/png/pngget.c b/modules/libimg/png/pngget.c
index f9bb43d..2d74198 100644
--- a/modules/libimg/png/pngget.c
+++ b/modules/libimg/png/pngget.c
@@ -1044,7 +1044,7 @@ png_get_mmx_rowbytes_threshold (png_structp png_ptr)
 #endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */
 
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
-/* these functions were added to libpng 1.2.6 */
+/* These functions were added to libpng 1.2.6 */
 png_uint_32 PNGAPI
 png_get_user_width_max (png_structp png_ptr)
 {
diff --git a/modules/libimg/png/pngread.c b/modules/libimg/png/pngread.c
index e964e3e..8b8a153 100644
--- a/modules/libimg/png/pngread.c
+++ b/modules/libimg/png/pngread.c
@@ -1,9 +1,9 @@
 
 /* pngread.c - read a PNG file
  *
- * Last changed in libpng 1.2.30 [August 13, 2008]
+ * Last changed in libpng 1.2.35 [February 14, 2009]
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2008 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2009 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -1577,11 +1577,11 @@ png_read_png(png_structp png_ptr, png_infop info_ptr,
 #ifdef PNG_FREE_ME_SUPPORTED
       info_ptr->free_me |= PNG_FREE_ROWS;
 #endif
+      png_memset(info_ptr->row_pointers, 0, info_ptr->height
+         * png_sizeof(png_bytep));
       for (row = 0; row < (int)info_ptr->height; row++)
-      {
          info_ptr->row_pointers[row] = (png_bytep)png_malloc(png_ptr,
             png_get_rowbytes(png_ptr, info_ptr));
-      }
    }
 
    png_read_image(png_ptr, info_ptr->row_pointers);
diff --git a/modules/libimg/png/pngrtran.c b/modules/libimg/png/pngrtran.c
index f389275..a916f54 100644
--- a/modules/libimg/png/pngrtran.c
+++ b/modules/libimg/png/pngrtran.c
@@ -1,9 +1,9 @@
 
 /* pngrtran.c - transforms the data in a row for PNG readers
  *
- * Last changed in libpng 1.2.30 [August 13, 2008]
+ * Last changed in libpng 1.2.35 [February 14, 2009]
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2008 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2009 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -309,9 +309,7 @@ png_set_dither(png_structp png_ptr, png_colorp palette,
 
          hash = (png_dsortpp)png_malloc(png_ptr, (png_uint_32)(769 *
             png_sizeof(png_dsortp)));
-         for (i = 0; i < 769; i++)
-            hash[i] = NULL;
-/*         png_memset(hash, 0, 769 * png_sizeof(png_dsortp)); */
+         png_memset(hash, 0, 769 * png_sizeof(png_dsortp));
 
          num_new_palette = num_palette;
 
@@ -684,7 +682,7 @@ png_set_rgb_to_gray_fixed(png_structp png_ptr, int error_action,
       }
       png_ptr->rgb_to_gray_red_coeff   = red_int;
       png_ptr->rgb_to_gray_green_coeff = green_int;
-      png_ptr->rgb_to_gray_blue_coeff  = 
+      png_ptr->rgb_to_gray_blue_coeff  =
          (png_uint_16)(32768 - red_int - green_int);
    }
 }
@@ -1329,7 +1327,7 @@ png_do_read_transformations(png_structp png_ptr)
       if (rgb_error)
       {
          png_ptr->rgb_to_gray_status=1;
-         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) == 
+         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
              PNG_RGB_TO_GRAY_WARN)
             png_warning(png_ptr, """"png_do_rgb_to_gray found nongray pixel"""");
          if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
@@ -3836,7 +3834,7 @@ png_do_expand(png_row_infop row_info, png_bytep row,
                dp = row + (row_info->rowbytes << 1) - 1;
                for (i = 0; i < row_width; i++)
                {
-                  if (*(sp - 1) == gray_high && *(sp) == gray_low) 
+                  if (*(sp - 1) == gray_high && *(sp) == gray_low)
                   {
                      *dp-- = 0;
                      *dp-- = 0;
@@ -4133,6 +4131,8 @@ png_build_gamma_table(png_structp png_ptr)
         double fin, fout;
         png_uint_32 last, max;
 
+        png_memset(png_ptr->gamma_16_table, 0, num * png_sizeof(png_uint_16p)); 
+
         for (i = 0; i < num; i++)
         {
            png_ptr->gamma_16_table[i] = (png_uint_16p)png_malloc(png_ptr,
@@ -4188,6 +4188,8 @@ png_build_gamma_table(png_structp png_ptr)
         png_ptr->gamma_16_to_1 = (png_uint_16pp)png_malloc(png_ptr,
            (png_uint_32)(num * png_sizeof(png_uint_16p )));
 
+        png_memset(png_ptr->gamma_16_to_1, 0, num * png_sizeof(png_uint_16p)); 
+
         for (i = 0; i < num; i++)
         {
            png_ptr->gamma_16_to_1[i] = (png_uint_16p)png_malloc(png_ptr,
@@ -4211,6 +4213,9 @@ png_build_gamma_table(png_structp png_ptr)
         png_ptr->gamma_16_from_1 = (png_uint_16pp)png_malloc(png_ptr,
            (png_uint_32)(num * png_sizeof(png_uint_16p)));
 
+        png_memset(png_ptr->gamma_16_from_1, 0,
+           num * png_sizeof(png_uint_16p)); 
+
         for (i = 0; i < num; i++)
         {
            png_ptr->gamma_16_from_1[i] = (png_uint_16p)png_malloc(png_ptr,
diff --git a/modules/libimg/png/pngrutil.c b/modules/libimg/png/pngrutil.c
index 58ae8f9..25d1d27 100644
--- a/modules/libimg/png/pngrutil.c
+++ b/modules/libimg/png/pngrutil.c
@@ -1123,6 +1123,7 @@ png_handle_sPLT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 
    png_debug(1, """"in png_handle_sPLT"""");
 
+
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, """"Missing IHDR before sPLT"""");
    else if (png_ptr->mode & PNG_HAVE_IDAT)
@@ -1909,6 +1910,7 @@ png_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 
    png_debug(1, """"in png_handle_tEXt"""");
 
+
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, """"Missing IHDR before tEXt"""");
 
@@ -1925,6 +1927,7 @@ png_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 #endif
 
    png_free(png_ptr, png_ptr->chunkdata);
+
    png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
    if (png_ptr->chunkdata == NULL)
    {
@@ -1942,6 +1945,7 @@ png_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
    }
 
    key = png_ptr->chunkdata;
+
    key[slength] = 0x00;
 
    for (text = key; *text; text++)
@@ -1991,6 +1995,8 @@ png_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
    png_size_t slength, prefix_len, data_len;
 
    png_debug(1, """"in png_handle_zTXt"""");
+
+
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, """"Missing IHDR before zTXt"""");
 
@@ -2095,6 +2101,7 @@ png_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 
    png_debug(1, """"in png_handle_iTXt"""");
 
+
    if (!(png_ptr->mode & PNG_HAVE_IHDR))
       png_error(png_ptr, """"Missing IHDR before iTXt"""");
 
@@ -2383,6 +2390,7 @@ png_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 
    png_debug(1, """"in png_handle_unknown"""");
 
+
    if (png_ptr->mode & PNG_HAVE_IDAT)
    {
 #ifdef PNG_USE_LOCAL_ARRAYS
@@ -3371,9 +3379,9 @@ defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
    png_debug1(3, """"width = %lu,"""", png_ptr->width);
    png_debug1(3, """"height = %lu,"""", png_ptr->height);
    png_debug1(3, """"iwidth = %lu,"""", png_ptr->iwidth);
-   png_debug1(3, """"num_rows = %lu"""", png_ptr->num_rows);
+   png_debug1(3, """"num_rows = %lu,"""", png_ptr->num_rows);
    png_debug1(3, """"rowbytes = %lu,"""", png_ptr->rowbytes);
-   png_debug1(3, """"irowbytes = %lu,"""", png_ptr->irowbytes);
+   png_debug1(3, """"irowbytes = %lu"""", png_ptr->irowbytes);
 
    png_ptr->flags |= PNG_FLAG_ROW_INIT;
 }
diff --git a/modules/libimg/png/pngset.c b/modules/libimg/png/pngset.c
index 1e303fb..77fbc7c 100644
--- a/modules/libimg/png/pngset.c
+++ b/modules/libimg/png/pngset.c
@@ -1,9 +1,9 @@
 
 /* pngset.c - storage of image information into info struct
  *
- * Last changed in libpng 1.2.34 [December 18, 2008]
+ * Last changed in libpng 1.2.35 [February 14, 2009]
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2008 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2009 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -61,7 +61,8 @@ png_set_cHRM(png_structp png_ptr, png_infop info_ptr,
 #endif
    info_ptr->valid |= PNG_INFO_cHRM;
 }
-#endif
+#endif /* PNG_FLOATING_POINT_SUPPORTED */
+
 #ifdef PNG_FIXED_POINT_SUPPORTED
 void PNGAPI
 png_set_cHRM_fixed(png_structp png_ptr, png_infop info_ptr,
@@ -387,7 +388,11 @@ png_set_pCAL(png_structp png_ptr, png_infop info_ptr,
       return;
    }
 
-   info_ptr->pcal_params[nparams] = NULL;
+#ifdef PNG_FREE_ME_SUPPORTED
+   info_ptr->free_me |= PNG_FREE_PCAL;
+#endif
+
+   png_memset(info_ptr->pcal_params, 0, (nparams + 1) * png_sizeof(png_charp));
 
    for (i = 0; i < nparams; i++)
    {
@@ -404,9 +409,6 @@ png_set_pCAL(png_structp png_ptr, png_infop info_ptr,
    }
 
    info_ptr->valid |= PNG_INFO_pCAL;
-#ifdef PNG_FREE_ME_SUPPORTED
-   info_ptr->free_me |= PNG_FREE_PCAL;
-#endif
 }
 #endif
 
@@ -640,7 +642,7 @@ png_set_sRGB_gAMA_and_cHRM(png_structp png_ptr, png_infop info_ptr,
    }
 #endif /* cHRM */
 }
-#endif
+#endif /* sRGB */
 
 
 #if defined(PNG_iCCP_SUPPORTED)
@@ -964,6 +966,7 @@ png_set_sPLT(png_structp png_ptr,
 
     png_memcpy(np, info_ptr->splt_palettes,
            info_ptr->splt_palettes_num * png_sizeof(png_sPLT_t));
+
     png_free(png_ptr, info_ptr->splt_palettes);
     info_ptr->splt_palettes=NULL;
 
diff --git a/modules/libimg/png/pngwio.c b/modules/libimg/png/pngwio.c
index 3c008c3..52eb7c0 100644
--- a/modules/libimg/png/pngwio.c
+++ b/modules/libimg/png/pngwio.c
@@ -1,9 +1,9 @@
 
 /* pngwio.c - functions for data output
  *
- * Last changed in libpng 1.2.30 [August 13, 2008]
+ * Last changed in libpng 1.2.35 [February 14, 2009]
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2008 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2009 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -137,7 +137,7 @@ png_default_flush(png_structp png_ptr)
    if (png_ptr == NULL) return;
 #if !defined(_WIN32_WCE)
    io_ptr = (png_FILE_p)CVT_PTR((png_ptr->io_ptr));
-   if (io_ptr != NULL)
+   if (io_ptr != NULL && fileno(io_ptr) != -1)
       fflush(io_ptr);
 #endif
 }
diff --git a/modules/libimg/png/pngwrite.c b/modules/libimg/png/pngwrite.c
index 0ef89a1..b03753b 100644
--- a/modules/libimg/png/pngwrite.c
+++ b/modules/libimg/png/pngwrite.c
@@ -1,7 +1,7 @@
 
 /* pngwrite.c - general routines to write a PNG file
  *
- * Last changed in libpng 1.2.31 [August 19, 2008]
+ * Last changed in libpng 1.2.34 [December 18, 2008]
  * For conditions of distribution and use, see copyright notice in png.h
  * Copyright (c) 1998-2008 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)"""
e8d7f539b76ba9a2d059b74e9a823eb0a1c0839d,48059,479336,Daniel Veditz ext:(%20/%20Reed%20Loden%20%3Creed%40mozilla.com%3E),"Bug 479336 - ""IDN blacklist needs to include box-drawing characters"" [r=dveditz]
",1235494251,"""diff --git a/modules/libpref/src/init/all.js b/modules/libpref/src/init/all.js
index 6894d28..85947b4 100644
--- a/modules/libpref/src/init/all.js
+++ b/modules/libpref/src/init/all.js
@@ -738,7 +738,7 @@ pref(""""network.IDN.whitelist.xn--zckzah"""", true);
 // attempt and so we always display the domain name as punycode. This would 
 // override the settings """"network.IDN_show_punycode"""" and 
 // """"network.IDN.whitelist.*"""".
-pref(""""network.IDN.blacklist_chars"""", """"\u0020\u00A0\u00BC\u00BD\u01C3\u0337\u0338\u05C3\u05F4\u06D4\u0702\u115F\u1160\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u200B\u2024\u2027\u2028\u2029\u202F\u2039\u203A\u2044\u205F\u2154\u2155\u2156\u2159\u215A\u215B\u215F\u2215\u23AE\u29F6\u29F8\u2AFB\u2AFD\u2FF0\u2FF1\u2FF2\u2FF3\u2FF4\u2FF5\u2FF6\u2FF7\u2FF8\u2FF9\u2FFA\u2FFB\u3000\u3002\u3014\u3015\u3033\u3164\u321D\u321E\u33AE\u33AF\u33C6\u33DF\uFE14\uFE15\uFE3F\uFE5D\uFE5E\uFEFF\uFF0E\uFF0F\uFF61\uFFA0\uFFF9\uFFFA\uFFFB\uFFFC\uFFFD"""");
+pref(""""network.IDN.blacklist_chars"""", """"\u0020\u00A0\u00BC\u00BD\u00BE\u01C3\u02D0\u0337\u0338\u0589\u05C3\u05F4\u0609\u060A\u066A\u06D4\u0701\u0702\u0703\u0704\u115F\u1160\u1735\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u200B\u2024\u2027\u2028\u2029\u202F\u2039\u203A\u2041\u2044\u2052\u205F\u2153\u2154\u2155\u2156\u2157\u2158\u2159\u215A\u215B\u215C\u215D\u215E\u215F\u2215\u2236\u23AE\u2571\u29F6\u29F8\u2AFB\u2AFD\u2FF0\u2FF1\u2FF2\u2FF3\u2FF4\u2FF5\u2FF6\u2FF7\u2FF8\u2FF9\u2FFA\u2FFB\u3000\u3002\u3014\u3015\u3033\u3164\u321D\u321E\u33AE\u33AF\u33C6\u33DF\uA789\uFE14\uFE15\uFE3F\uFE5D\uFE5E\uFEFF\uFF0E\uFF0F\uFF61\uFFA0\uFFF9\uFFFA\uFFFB\uFFFC\uFFFD"""");
 
 // This preference specifies a list of domains for which DNS lookups will be
 // IPv4 only. Works around broken DNS servers which can't handle IPv6 lookups"""
e537dcd4fe95c4f037af4e4fffaea2f6bdf4cf74,48298,474536,Jason Duell,"Bug 474536.  Expose the underlying channel's content-disposition on jar: channels.  r+sr=bzbarsky
",1235075118,"""diff --git a/modules/libjar/nsJARChannel.cpp b/modules/libjar/nsJARChannel.cpp
index 2058727..73914df 100644
--- a/modules/libjar/nsJARChannel.cpp
+++ b/modules/libjar/nsJARChannel.cpp
@@ -46,6 +46,7 @@
 #include """"nsEscape.h""""
 #include """"nsIPrefService.h""""
 #include """"nsIPrefBranch.h""""
+#include """"nsChannelProperties.h""""
 
 #include """"nsIScriptSecurityManager.h""""
 #include """"nsIPrincipal.h""""
@@ -218,6 +219,9 @@ nsJARInputThunk::IsNonBlocking(PRBool *nonBlocking)
 }
 
 //-----------------------------------------------------------------------------
+// nsJARChannel
+//-----------------------------------------------------------------------------
+
 
 nsJARChannel::nsJARChannel()
     : mContentLength(-1)
@@ -246,18 +250,23 @@ nsJARChannel::~nsJARChannel()
     NS_RELEASE(handler); // NULL parameter
 }
 
-NS_IMPL_ISUPPORTS6(nsJARChannel,
-                   nsIRequest,
-                   nsIChannel,
-                   nsIStreamListener,
-                   nsIRequestObserver,
-                   nsIDownloadObserver,
-                   nsIJARChannel)
+NS_IMPL_ISUPPORTS_INHERITED6(nsJARChannel,
+                             nsHashPropertyBag,
+                             nsIRequest,
+                             nsIChannel,
+                             nsIStreamListener,
+                             nsIRequestObserver,
+                             nsIDownloadObserver,
+                             nsIJARChannel)
 
 nsresult 
 nsJARChannel::Init(nsIURI *uri)
 {
     nsresult rv;
+    rv = nsHashPropertyBag::Init();
+    if (NS_FAILED(rv))
+        return rv;
+
     mJarURI = do_QueryInterface(uri, &rv);
     if (NS_FAILED(rv))
         return rv;
@@ -752,6 +761,7 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
     }
 
     if (NS_SUCCEEDED(status) && channel) {
+        nsCAutoString header;
         // Grab the security info from our base channel
         channel->GetSecurityInfo(getter_AddRefs(mSecurityInfo));
 
@@ -760,16 +770,17 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
             // We only want to run scripts if the server really intended to
             // send us a JAR file.  Check the server-supplied content type for
             // a JAR type.
-            nsCAutoString header;
             httpChannel->GetResponseHeader(NS_LITERAL_CSTRING(""""Content-Type""""),
                                            header);
-
             nsCAutoString contentType;
             nsCAutoString charset;
             NS_ParseContentType(header, contentType, charset);
-
             mIsUnsafe = !contentType.EqualsLiteral(""""application/java-archive"""") &&
                         !contentType.EqualsLiteral(""""application/x-jar"""");
+            rv = httpChannel->GetResponseHeader(NS_LITERAL_CSTRING(""""Content-Disposition""""),
+                                                header);
+            if (NS_SUCCEEDED(rv))
+                SetPropertyAsACString(NS_CHANNEL_PROP_CONTENT_DISPOSITION, header);
         } else {
             nsCOMPtr<nsIJARChannel> innerJARChannel(do_QueryInterface(channel));
             if (innerJARChannel) {
@@ -777,6 +788,10 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
                 innerJARChannel->GetIsUnsafe(&unsafe);
                 mIsUnsafe = unsafe;
             }
+            // Soon-to-be common way to get Disposition: right now only nsIJARChannel
+            rv = NS_GetContentDisposition(request, header);
+            if (NS_SUCCEEDED(rv))
+                SetPropertyAsACString(NS_CHANNEL_PROP_CONTENT_DISPOSITION, header);
         }
     }
 
diff --git a/modules/libjar/nsJARChannel.h b/modules/libjar/nsJARChannel.h
index 719b298..9e84f58 100644
--- a/modules/libjar/nsJARChannel.h
+++ b/modules/libjar/nsJARChannel.h
@@ -47,6 +47,7 @@
 #include """"nsIZipReader.h""""
 #include """"nsIDownloader.h""""
 #include """"nsILoadGroup.h""""
+#include """"nsHashPropertyBag.h""""
 #include """"nsIFile.h""""
 #include """"nsIURI.h""""
 #include """"nsCOMPtr.h""""
@@ -60,6 +61,7 @@ class nsJARInputThunk;
 class nsJARChannel : public nsIJARChannel
                    , public nsIDownloadObserver
                    , public nsIStreamListener
+                   , public nsHashPropertyBag
 {
 public:
     NS_DECL_ISUPPORTS
diff --git a/netwerk/base/public/nsChannelProperties.h b/netwerk/base/public/nsChannelProperties.h
index 5a45821..f1036a6 100644
--- a/netwerk/base/public/nsChannelProperties.h
+++ b/netwerk/base/public/nsChannelProperties.h
@@ -58,11 +58,21 @@
  */
 #define NS_CHANNEL_PROP_CONTENT_LENGTH_STR """"content-length""""
 
+/**
+ * MIME Content-Disposition header of channel.  
+ * Not available before onStartRequest. 
+ * Type: nsACString
+ */
+#define NS_CHANNEL_PROP_CONTENT_DISPOSITION_STR """"content-disposition""""
+
 #ifdef IMPL_NS_NET
 #define NS_CHANNEL_PROP_CONTENT_LENGTH gNetStrings->kContentLength
+#define NS_CHANNEL_PROP_CONTENT_DISPOSITION gNetStrings->kContentDisposition
 #else
 #define NS_CHANNEL_PROP_CONTENT_LENGTH \
   NS_LITERAL_STRING(NS_CHANNEL_PROP_CONTENT_LENGTH_STR)
+#define NS_CHANNEL_PROP_CONTENT_DISPOSITION \
+  NS_LITERAL_STRING(NS_CHANNEL_PROP_CONTENT_DISPOSITION_STR)
 #endif
 
 #endif
diff --git a/netwerk/base/public/nsNetStrings.h b/netwerk/base/public/nsNetStrings.h
index 603457a..44d63a77 100644
--- a/netwerk/base/public/nsNetStrings.h
+++ b/netwerk/base/public/nsNetStrings.h
@@ -49,6 +49,7 @@ public:
 
   /** """"content-length"""" */
   const nsLiteralString kContentLength;
+  const nsLiteralString kContentDisposition;
 };
 
 extern NS_HIDDEN_(nsNetStrings*) gNetStrings;
diff --git a/netwerk/base/public/nsNetUtil.h b/netwerk/base/public/nsNetUtil.h
index 5db2261..05eb50c 100644
--- a/netwerk/base/public/nsNetUtil.h
+++ b/netwerk/base/public/nsNetUtil.h
@@ -62,6 +62,7 @@
 #include """"nsIIOService.h""""
 #include """"nsIServiceManager.h""""
 #include """"nsIChannel.h""""
+#include """"nsChannelProperties.h""""
 #include """"nsIInputStreamChannel.h""""
 #include """"nsITransport.h""""
 #include """"nsIStreamTransportService.h""""
@@ -194,6 +195,19 @@ NS_NewChannel(nsIChannel           **result,
     return rv;
 }
 
+// For now, works only with JARChannel.  Future: with all channels that may
+// have Content-Disposition header (JAR, nsIHttpChannel, and nsIMultiPartChannel).
+inline nsresult
+NS_GetContentDisposition(nsIRequest     *channel,
+                         nsACString     &result)
+{
+    nsCOMPtr<nsIPropertyBag2> props(do_QueryInterface(channel));
+    if (props)
+        return props->GetPropertyAsACString(NS_CHANNEL_PROP_CONTENT_DISPOSITION,
+                                            result);
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
 // Use this function with CAUTION. It creates a stream that blocks when you
 // Read() from it and blocking the UI thread is a bad idea. If you don't want
 // to implement a full blown asynchronous consumer (via nsIStreamListener) look
diff --git a/netwerk/base/src/nsNetStrings.cpp b/netwerk/base/src/nsNetStrings.cpp
index b8d47d8..d28e9b9 100644
--- a/netwerk/base/src/nsNetStrings.cpp
+++ b/netwerk/base/src/nsNetStrings.cpp
@@ -40,7 +40,8 @@
 NS_HIDDEN_(nsNetStrings*) gNetStrings;
 
 nsNetStrings::nsNetStrings()
-  : NS_LITERAL_STRING_INIT(kContentLength, NS_CHANNEL_PROP_CONTENT_LENGTH_STR)
+  : NS_LITERAL_STRING_INIT(kContentLength, NS_CHANNEL_PROP_CONTENT_LENGTH_STR),
+    NS_LITERAL_STRING_INIT(kContentDisposition, NS_CHANNEL_PROP_CONTENT_DISPOSITION_STR)
 {}
 
 
diff --git a/netwerk/protocol/http/src/nsHttpAtomList.h b/netwerk/protocol/http/src/nsHttpAtomList.h
index 77096da..f11c724 100644
--- a/netwerk/protocol/http/src/nsHttpAtomList.h
+++ b/netwerk/protocol/http/src/nsHttpAtomList.h
@@ -62,6 +62,7 @@ HTTP_ATOM(Authorization,             """"Authorization"""")
 HTTP_ATOM(Cache_Control,             """"Cache-Control"""")
 HTTP_ATOM(Connection,                """"Connection"""")
 HTTP_ATOM(Content_Base,              """"Content-Base"""")
+HTTP_ATOM(Content_Disposition,       """"Content-Disposition"""")
 HTTP_ATOM(Content_Encoding,          """"Content-Encoding"""")
 HTTP_ATOM(Content_Language,          """"Content-Language"""")
 HTTP_ATOM(Content_Length,            """"Content-Length"""")
diff --git a/netwerk/streamconv/test/Makefile.in b/netwerk/streamconv/test/Makefile.in
index 4b8b597..ea2f55b 100644
--- a/netwerk/streamconv/test/Makefile.in
+++ b/netwerk/streamconv/test/Makefile.in
@@ -73,4 +73,3 @@ DEFINES		+= -DNGPREFS
 endif
 endif # WINNT
 
-DEFINES += -DIMPL_NS_NET
diff --git a/uriloader/base/nsURILoader.cpp b/uriloader/base/nsURILoader.cpp
index 770bcaa..a593877 100644
--- a/uriloader/base/nsURILoader.cpp
+++ b/uriloader/base/nsURILoader.cpp
@@ -65,7 +65,7 @@
 
 #include """"nsXPIDLString.h""""
 #include """"nsString.h""""
-
+#include """"nsNetUtil.h""""
 #include """"nsIDOMWindowInternal.h""""
 #include """"nsReadableUtils.h""""
 #include """"nsDOMError.h""""
@@ -380,6 +380,9 @@ nsresult nsDocumentOpenInfo::DispatchContent(nsIRequest *request, nsISupports *
     if (multipartChannel)
     {
       rv = multipartChannel->GetContentDisposition(disposition);
+    } else {
+      // Soon-to-be common way to get Disposition: right now only JARChannel
+      rv = NS_GetContentDisposition(request, disposition);
     }
   }
 """
767bb1afdfe00009f25666afe6b83dea1c47366b,48299,474536,L. David Baron,"Merge backout of Bug 474536 to fix build bustage.
",1235075891,"""diff --git a/modules/libjar/nsJARChannel.cpp b/modules/libjar/nsJARChannel.cpp
index 73914df..2058727 100644
--- a/modules/libjar/nsJARChannel.cpp
+++ b/modules/libjar/nsJARChannel.cpp
@@ -46,7 +46,6 @@
 #include """"nsEscape.h""""
 #include """"nsIPrefService.h""""
 #include """"nsIPrefBranch.h""""
-#include """"nsChannelProperties.h""""
 
 #include """"nsIScriptSecurityManager.h""""
 #include """"nsIPrincipal.h""""
@@ -219,9 +218,6 @@ nsJARInputThunk::IsNonBlocking(PRBool *nonBlocking)
 }
 
 //-----------------------------------------------------------------------------
-// nsJARChannel
-//-----------------------------------------------------------------------------
-
 
 nsJARChannel::nsJARChannel()
     : mContentLength(-1)
@@ -250,23 +246,18 @@ nsJARChannel::~nsJARChannel()
     NS_RELEASE(handler); // NULL parameter
 }
 
-NS_IMPL_ISUPPORTS_INHERITED6(nsJARChannel,
-                             nsHashPropertyBag,
-                             nsIRequest,
-                             nsIChannel,
-                             nsIStreamListener,
-                             nsIRequestObserver,
-                             nsIDownloadObserver,
-                             nsIJARChannel)
+NS_IMPL_ISUPPORTS6(nsJARChannel,
+                   nsIRequest,
+                   nsIChannel,
+                   nsIStreamListener,
+                   nsIRequestObserver,
+                   nsIDownloadObserver,
+                   nsIJARChannel)
 
 nsresult 
 nsJARChannel::Init(nsIURI *uri)
 {
     nsresult rv;
-    rv = nsHashPropertyBag::Init();
-    if (NS_FAILED(rv))
-        return rv;
-
     mJarURI = do_QueryInterface(uri, &rv);
     if (NS_FAILED(rv))
         return rv;
@@ -761,7 +752,6 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
     }
 
     if (NS_SUCCEEDED(status) && channel) {
-        nsCAutoString header;
         // Grab the security info from our base channel
         channel->GetSecurityInfo(getter_AddRefs(mSecurityInfo));
 
@@ -770,17 +760,16 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
             // We only want to run scripts if the server really intended to
             // send us a JAR file.  Check the server-supplied content type for
             // a JAR type.
+            nsCAutoString header;
             httpChannel->GetResponseHeader(NS_LITERAL_CSTRING(""""Content-Type""""),
                                            header);
+
             nsCAutoString contentType;
             nsCAutoString charset;
             NS_ParseContentType(header, contentType, charset);
+
             mIsUnsafe = !contentType.EqualsLiteral(""""application/java-archive"""") &&
                         !contentType.EqualsLiteral(""""application/x-jar"""");
-            rv = httpChannel->GetResponseHeader(NS_LITERAL_CSTRING(""""Content-Disposition""""),
-                                                header);
-            if (NS_SUCCEEDED(rv))
-                SetPropertyAsACString(NS_CHANNEL_PROP_CONTENT_DISPOSITION, header);
         } else {
             nsCOMPtr<nsIJARChannel> innerJARChannel(do_QueryInterface(channel));
             if (innerJARChannel) {
@@ -788,10 +777,6 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
                 innerJARChannel->GetIsUnsafe(&unsafe);
                 mIsUnsafe = unsafe;
             }
-            // Soon-to-be common way to get Disposition: right now only nsIJARChannel
-            rv = NS_GetContentDisposition(request, header);
-            if (NS_SUCCEEDED(rv))
-                SetPropertyAsACString(NS_CHANNEL_PROP_CONTENT_DISPOSITION, header);
         }
     }
 
diff --git a/modules/libjar/nsJARChannel.h b/modules/libjar/nsJARChannel.h
index 9e84f58..719b298 100644
--- a/modules/libjar/nsJARChannel.h
+++ b/modules/libjar/nsJARChannel.h
@@ -47,7 +47,6 @@
 #include """"nsIZipReader.h""""
 #include """"nsIDownloader.h""""
 #include """"nsILoadGroup.h""""
-#include """"nsHashPropertyBag.h""""
 #include """"nsIFile.h""""
 #include """"nsIURI.h""""
 #include """"nsCOMPtr.h""""
@@ -61,7 +60,6 @@ class nsJARInputThunk;
 class nsJARChannel : public nsIJARChannel
                    , public nsIDownloadObserver
                    , public nsIStreamListener
-                   , public nsHashPropertyBag
 {
 public:
     NS_DECL_ISUPPORTS
diff --git a/netwerk/base/public/nsChannelProperties.h b/netwerk/base/public/nsChannelProperties.h
index f1036a6..5a45821 100644
--- a/netwerk/base/public/nsChannelProperties.h
+++ b/netwerk/base/public/nsChannelProperties.h
@@ -58,21 +58,11 @@
  */
 #define NS_CHANNEL_PROP_CONTENT_LENGTH_STR """"content-length""""
 
-/**
- * MIME Content-Disposition header of channel.  
- * Not available before onStartRequest. 
- * Type: nsACString
- */
-#define NS_CHANNEL_PROP_CONTENT_DISPOSITION_STR """"content-disposition""""
-
 #ifdef IMPL_NS_NET
 #define NS_CHANNEL_PROP_CONTENT_LENGTH gNetStrings->kContentLength
-#define NS_CHANNEL_PROP_CONTENT_DISPOSITION gNetStrings->kContentDisposition
 #else
 #define NS_CHANNEL_PROP_CONTENT_LENGTH \
   NS_LITERAL_STRING(NS_CHANNEL_PROP_CONTENT_LENGTH_STR)
-#define NS_CHANNEL_PROP_CONTENT_DISPOSITION \
-  NS_LITERAL_STRING(NS_CHANNEL_PROP_CONTENT_DISPOSITION_STR)
 #endif
 
 #endif
diff --git a/netwerk/base/public/nsNetStrings.h b/netwerk/base/public/nsNetStrings.h
index 44d63a77..603457a 100644
--- a/netwerk/base/public/nsNetStrings.h
+++ b/netwerk/base/public/nsNetStrings.h
@@ -49,7 +49,6 @@ public:
 
   /** """"content-length"""" */
   const nsLiteralString kContentLength;
-  const nsLiteralString kContentDisposition;
 };
 
 extern NS_HIDDEN_(nsNetStrings*) gNetStrings;
diff --git a/netwerk/base/public/nsNetUtil.h b/netwerk/base/public/nsNetUtil.h
index 05eb50c..5db2261 100644
--- a/netwerk/base/public/nsNetUtil.h
+++ b/netwerk/base/public/nsNetUtil.h
@@ -62,7 +62,6 @@
 #include """"nsIIOService.h""""
 #include """"nsIServiceManager.h""""
 #include """"nsIChannel.h""""
-#include """"nsChannelProperties.h""""
 #include """"nsIInputStreamChannel.h""""
 #include """"nsITransport.h""""
 #include """"nsIStreamTransportService.h""""
@@ -195,19 +194,6 @@ NS_NewChannel(nsIChannel           **result,
     return rv;
 }
 
-// For now, works only with JARChannel.  Future: with all channels that may
-// have Content-Disposition header (JAR, nsIHttpChannel, and nsIMultiPartChannel).
-inline nsresult
-NS_GetContentDisposition(nsIRequest     *channel,
-                         nsACString     &result)
-{
-    nsCOMPtr<nsIPropertyBag2> props(do_QueryInterface(channel));
-    if (props)
-        return props->GetPropertyAsACString(NS_CHANNEL_PROP_CONTENT_DISPOSITION,
-                                            result);
-    return NS_ERROR_NOT_AVAILABLE;
-}
-
 // Use this function with CAUTION. It creates a stream that blocks when you
 // Read() from it and blocking the UI thread is a bad idea. If you don't want
 // to implement a full blown asynchronous consumer (via nsIStreamListener) look
diff --git a/netwerk/base/src/nsNetStrings.cpp b/netwerk/base/src/nsNetStrings.cpp
index 2ac1a86..b8d47d8 100644
--- a/netwerk/base/src/nsNetStrings.cpp
+++ b/netwerk/base/src/nsNetStrings.cpp
@@ -41,7 +41,6 @@ NS_HIDDEN_(nsNetStrings*) gNetStrings;
 
 nsNetStrings::nsNetStrings()
   : NS_LITERAL_STRING_INIT(kContentLength, NS_CHANNEL_PROP_CONTENT_LENGTH_STR)
-  : NS_LITERAL_STRING_INIT(kContentDisposition, NS_CHANNEL_PROP_CONTENT_DISPOSITION_STR)
 {}
 
 
diff --git a/netwerk/protocol/http/src/nsHttpAtomList.h b/netwerk/protocol/http/src/nsHttpAtomList.h
index f11c724..77096da 100644
--- a/netwerk/protocol/http/src/nsHttpAtomList.h
+++ b/netwerk/protocol/http/src/nsHttpAtomList.h
@@ -62,7 +62,6 @@ HTTP_ATOM(Authorization,             """"Authorization"""")
 HTTP_ATOM(Cache_Control,             """"Cache-Control"""")
 HTTP_ATOM(Connection,                """"Connection"""")
 HTTP_ATOM(Content_Base,              """"Content-Base"""")
-HTTP_ATOM(Content_Disposition,       """"Content-Disposition"""")
 HTTP_ATOM(Content_Encoding,          """"Content-Encoding"""")
 HTTP_ATOM(Content_Language,          """"Content-Language"""")
 HTTP_ATOM(Content_Length,            """"Content-Length"""")
diff --git a/netwerk/streamconv/test/Makefile.in b/netwerk/streamconv/test/Makefile.in
index ea2f55b..4b8b597 100644
--- a/netwerk/streamconv/test/Makefile.in
+++ b/netwerk/streamconv/test/Makefile.in
@@ -73,3 +73,4 @@ DEFINES		+= -DNGPREFS
 endif
 endif # WINNT
 
+DEFINES += -DIMPL_NS_NET
diff --git a/uriloader/base/nsURILoader.cpp b/uriloader/base/nsURILoader.cpp
index a593877..770bcaa 100644
--- a/uriloader/base/nsURILoader.cpp
+++ b/uriloader/base/nsURILoader.cpp
@@ -65,7 +65,7 @@
 
 #include """"nsXPIDLString.h""""
 #include """"nsString.h""""
-#include """"nsNetUtil.h""""
+
 #include """"nsIDOMWindowInternal.h""""
 #include """"nsReadableUtils.h""""
 #include """"nsDOMError.h""""
@@ -380,9 +380,6 @@ nsresult nsDocumentOpenInfo::DispatchContent(nsIRequest *request, nsISupports *
     if (multipartChannel)
     {
       rv = multipartChannel->GetContentDisposition(disposition);
-    } else {
-      // Soon-to-be common way to get Disposition: right now only JARChannel
-      rv = NS_GetContentDisposition(request, disposition);
     }
   }
 """
41d6b2d3b4ca13fc76f3e809180057e92b83abeb,48300,474536,L. David Baron,"Backed out changeset 4bd7dd7645c2 (Bug 474536)
",1235075873,"""diff --git a/modules/libjar/nsJARChannel.cpp b/modules/libjar/nsJARChannel.cpp
index 73914df..2058727 100644
--- a/modules/libjar/nsJARChannel.cpp
+++ b/modules/libjar/nsJARChannel.cpp
@@ -46,7 +46,6 @@
 #include """"nsEscape.h""""
 #include """"nsIPrefService.h""""
 #include """"nsIPrefBranch.h""""
-#include """"nsChannelProperties.h""""
 
 #include """"nsIScriptSecurityManager.h""""
 #include """"nsIPrincipal.h""""
@@ -219,9 +218,6 @@ nsJARInputThunk::IsNonBlocking(PRBool *nonBlocking)
 }
 
 //-----------------------------------------------------------------------------
-// nsJARChannel
-//-----------------------------------------------------------------------------
-
 
 nsJARChannel::nsJARChannel()
     : mContentLength(-1)
@@ -250,23 +246,18 @@ nsJARChannel::~nsJARChannel()
     NS_RELEASE(handler); // NULL parameter
 }
 
-NS_IMPL_ISUPPORTS_INHERITED6(nsJARChannel,
-                             nsHashPropertyBag,
-                             nsIRequest,
-                             nsIChannel,
-                             nsIStreamListener,
-                             nsIRequestObserver,
-                             nsIDownloadObserver,
-                             nsIJARChannel)
+NS_IMPL_ISUPPORTS6(nsJARChannel,
+                   nsIRequest,
+                   nsIChannel,
+                   nsIStreamListener,
+                   nsIRequestObserver,
+                   nsIDownloadObserver,
+                   nsIJARChannel)
 
 nsresult 
 nsJARChannel::Init(nsIURI *uri)
 {
     nsresult rv;
-    rv = nsHashPropertyBag::Init();
-    if (NS_FAILED(rv))
-        return rv;
-
     mJarURI = do_QueryInterface(uri, &rv);
     if (NS_FAILED(rv))
         return rv;
@@ -761,7 +752,6 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
     }
 
     if (NS_SUCCEEDED(status) && channel) {
-        nsCAutoString header;
         // Grab the security info from our base channel
         channel->GetSecurityInfo(getter_AddRefs(mSecurityInfo));
 
@@ -770,17 +760,16 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
             // We only want to run scripts if the server really intended to
             // send us a JAR file.  Check the server-supplied content type for
             // a JAR type.
+            nsCAutoString header;
             httpChannel->GetResponseHeader(NS_LITERAL_CSTRING(""""Content-Type""""),
                                            header);
+
             nsCAutoString contentType;
             nsCAutoString charset;
             NS_ParseContentType(header, contentType, charset);
+
             mIsUnsafe = !contentType.EqualsLiteral(""""application/java-archive"""") &&
                         !contentType.EqualsLiteral(""""application/x-jar"""");
-            rv = httpChannel->GetResponseHeader(NS_LITERAL_CSTRING(""""Content-Disposition""""),
-                                                header);
-            if (NS_SUCCEEDED(rv))
-                SetPropertyAsACString(NS_CHANNEL_PROP_CONTENT_DISPOSITION, header);
         } else {
             nsCOMPtr<nsIJARChannel> innerJARChannel(do_QueryInterface(channel));
             if (innerJARChannel) {
@@ -788,10 +777,6 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
                 innerJARChannel->GetIsUnsafe(&unsafe);
                 mIsUnsafe = unsafe;
             }
-            // Soon-to-be common way to get Disposition: right now only nsIJARChannel
-            rv = NS_GetContentDisposition(request, header);
-            if (NS_SUCCEEDED(rv))
-                SetPropertyAsACString(NS_CHANNEL_PROP_CONTENT_DISPOSITION, header);
         }
     }
 
diff --git a/modules/libjar/nsJARChannel.h b/modules/libjar/nsJARChannel.h
index 9e84f58..719b298 100644
--- a/modules/libjar/nsJARChannel.h
+++ b/modules/libjar/nsJARChannel.h
@@ -47,7 +47,6 @@
 #include """"nsIZipReader.h""""
 #include """"nsIDownloader.h""""
 #include """"nsILoadGroup.h""""
-#include """"nsHashPropertyBag.h""""
 #include """"nsIFile.h""""
 #include """"nsIURI.h""""
 #include """"nsCOMPtr.h""""
@@ -61,7 +60,6 @@ class nsJARInputThunk;
 class nsJARChannel : public nsIJARChannel
                    , public nsIDownloadObserver
                    , public nsIStreamListener
-                   , public nsHashPropertyBag
 {
 public:
     NS_DECL_ISUPPORTS
diff --git a/netwerk/base/public/nsChannelProperties.h b/netwerk/base/public/nsChannelProperties.h
index f1036a6..5a45821 100644
--- a/netwerk/base/public/nsChannelProperties.h
+++ b/netwerk/base/public/nsChannelProperties.h
@@ -58,21 +58,11 @@
  */
 #define NS_CHANNEL_PROP_CONTENT_LENGTH_STR """"content-length""""
 
-/**
- * MIME Content-Disposition header of channel.  
- * Not available before onStartRequest. 
- * Type: nsACString
- */
-#define NS_CHANNEL_PROP_CONTENT_DISPOSITION_STR """"content-disposition""""
-
 #ifdef IMPL_NS_NET
 #define NS_CHANNEL_PROP_CONTENT_LENGTH gNetStrings->kContentLength
-#define NS_CHANNEL_PROP_CONTENT_DISPOSITION gNetStrings->kContentDisposition
 #else
 #define NS_CHANNEL_PROP_CONTENT_LENGTH \
   NS_LITERAL_STRING(NS_CHANNEL_PROP_CONTENT_LENGTH_STR)
-#define NS_CHANNEL_PROP_CONTENT_DISPOSITION \
-  NS_LITERAL_STRING(NS_CHANNEL_PROP_CONTENT_DISPOSITION_STR)
 #endif
 
 #endif
diff --git a/netwerk/base/public/nsNetStrings.h b/netwerk/base/public/nsNetStrings.h
index 44d63a77..603457a 100644
--- a/netwerk/base/public/nsNetStrings.h
+++ b/netwerk/base/public/nsNetStrings.h
@@ -49,7 +49,6 @@ public:
 
   /** """"content-length"""" */
   const nsLiteralString kContentLength;
-  const nsLiteralString kContentDisposition;
 };
 
 extern NS_HIDDEN_(nsNetStrings*) gNetStrings;
diff --git a/netwerk/base/public/nsNetUtil.h b/netwerk/base/public/nsNetUtil.h
index 05eb50c..5db2261 100644
--- a/netwerk/base/public/nsNetUtil.h
+++ b/netwerk/base/public/nsNetUtil.h
@@ -62,7 +62,6 @@
 #include """"nsIIOService.h""""
 #include """"nsIServiceManager.h""""
 #include """"nsIChannel.h""""
-#include """"nsChannelProperties.h""""
 #include """"nsIInputStreamChannel.h""""
 #include """"nsITransport.h""""
 #include """"nsIStreamTransportService.h""""
@@ -195,19 +194,6 @@ NS_NewChannel(nsIChannel           **result,
     return rv;
 }
 
-// For now, works only with JARChannel.  Future: with all channels that may
-// have Content-Disposition header (JAR, nsIHttpChannel, and nsIMultiPartChannel).
-inline nsresult
-NS_GetContentDisposition(nsIRequest     *channel,
-                         nsACString     &result)
-{
-    nsCOMPtr<nsIPropertyBag2> props(do_QueryInterface(channel));
-    if (props)
-        return props->GetPropertyAsACString(NS_CHANNEL_PROP_CONTENT_DISPOSITION,
-                                            result);
-    return NS_ERROR_NOT_AVAILABLE;
-}
-
 // Use this function with CAUTION. It creates a stream that blocks when you
 // Read() from it and blocking the UI thread is a bad idea. If you don't want
 // to implement a full blown asynchronous consumer (via nsIStreamListener) look
diff --git a/netwerk/base/src/nsNetStrings.cpp b/netwerk/base/src/nsNetStrings.cpp
index 2ac1a86..b8d47d8 100644
--- a/netwerk/base/src/nsNetStrings.cpp
+++ b/netwerk/base/src/nsNetStrings.cpp
@@ -41,7 +41,6 @@ NS_HIDDEN_(nsNetStrings*) gNetStrings;
 
 nsNetStrings::nsNetStrings()
   : NS_LITERAL_STRING_INIT(kContentLength, NS_CHANNEL_PROP_CONTENT_LENGTH_STR)
-  : NS_LITERAL_STRING_INIT(kContentDisposition, NS_CHANNEL_PROP_CONTENT_DISPOSITION_STR)
 {}
 
 
diff --git a/netwerk/protocol/http/src/nsHttpAtomList.h b/netwerk/protocol/http/src/nsHttpAtomList.h
index f11c724..77096da 100644
--- a/netwerk/protocol/http/src/nsHttpAtomList.h
+++ b/netwerk/protocol/http/src/nsHttpAtomList.h
@@ -62,7 +62,6 @@ HTTP_ATOM(Authorization,             """"Authorization"""")
 HTTP_ATOM(Cache_Control,             """"Cache-Control"""")
 HTTP_ATOM(Connection,                """"Connection"""")
 HTTP_ATOM(Content_Base,              """"Content-Base"""")
-HTTP_ATOM(Content_Disposition,       """"Content-Disposition"""")
 HTTP_ATOM(Content_Encoding,          """"Content-Encoding"""")
 HTTP_ATOM(Content_Language,          """"Content-Language"""")
 HTTP_ATOM(Content_Length,            """"Content-Length"""")
diff --git a/netwerk/streamconv/test/Makefile.in b/netwerk/streamconv/test/Makefile.in
index ea2f55b..4b8b597 100644
--- a/netwerk/streamconv/test/Makefile.in
+++ b/netwerk/streamconv/test/Makefile.in
@@ -73,3 +73,4 @@ DEFINES		+= -DNGPREFS
 endif
 endif # WINNT
 
+DEFINES += -DIMPL_NS_NET
diff --git a/uriloader/base/nsURILoader.cpp b/uriloader/base/nsURILoader.cpp
index a593877..770bcaa 100644
--- a/uriloader/base/nsURILoader.cpp
+++ b/uriloader/base/nsURILoader.cpp
@@ -65,7 +65,7 @@
 
 #include """"nsXPIDLString.h""""
 #include """"nsString.h""""
-#include """"nsNetUtil.h""""
+
 #include """"nsIDOMWindowInternal.h""""
 #include """"nsReadableUtils.h""""
 #include """"nsDOMError.h""""
@@ -380,9 +380,6 @@ nsresult nsDocumentOpenInfo::DispatchContent(nsIRequest *request, nsISupports *
     if (multipartChannel)
     {
       rv = multipartChannel->GetContentDisposition(disposition);
-    } else {
-      // Soon-to-be common way to get Disposition: right now only JARChannel
-      rv = NS_GetContentDisposition(request, disposition);
     }
   }
 """
900215f16631415d8a4b0c189535bec818ff8b38,48301,474536,Jason Duell,"Bug 474536.  Expose the underlying channel's content-disposition on jar: channels.  r+sr=bzbarsky
",1235075118,"""diff --git a/modules/libjar/nsJARChannel.cpp b/modules/libjar/nsJARChannel.cpp
index 2058727..73914df 100644
--- a/modules/libjar/nsJARChannel.cpp
+++ b/modules/libjar/nsJARChannel.cpp
@@ -46,6 +46,7 @@
 #include """"nsEscape.h""""
 #include """"nsIPrefService.h""""
 #include """"nsIPrefBranch.h""""
+#include """"nsChannelProperties.h""""
 
 #include """"nsIScriptSecurityManager.h""""
 #include """"nsIPrincipal.h""""
@@ -218,6 +219,9 @@ nsJARInputThunk::IsNonBlocking(PRBool *nonBlocking)
 }
 
 //-----------------------------------------------------------------------------
+// nsJARChannel
+//-----------------------------------------------------------------------------
+
 
 nsJARChannel::nsJARChannel()
     : mContentLength(-1)
@@ -246,18 +250,23 @@ nsJARChannel::~nsJARChannel()
     NS_RELEASE(handler); // NULL parameter
 }
 
-NS_IMPL_ISUPPORTS6(nsJARChannel,
-                   nsIRequest,
-                   nsIChannel,
-                   nsIStreamListener,
-                   nsIRequestObserver,
-                   nsIDownloadObserver,
-                   nsIJARChannel)
+NS_IMPL_ISUPPORTS_INHERITED6(nsJARChannel,
+                             nsHashPropertyBag,
+                             nsIRequest,
+                             nsIChannel,
+                             nsIStreamListener,
+                             nsIRequestObserver,
+                             nsIDownloadObserver,
+                             nsIJARChannel)
 
 nsresult 
 nsJARChannel::Init(nsIURI *uri)
 {
     nsresult rv;
+    rv = nsHashPropertyBag::Init();
+    if (NS_FAILED(rv))
+        return rv;
+
     mJarURI = do_QueryInterface(uri, &rv);
     if (NS_FAILED(rv))
         return rv;
@@ -752,6 +761,7 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
     }
 
     if (NS_SUCCEEDED(status) && channel) {
+        nsCAutoString header;
         // Grab the security info from our base channel
         channel->GetSecurityInfo(getter_AddRefs(mSecurityInfo));
 
@@ -760,16 +770,17 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
             // We only want to run scripts if the server really intended to
             // send us a JAR file.  Check the server-supplied content type for
             // a JAR type.
-            nsCAutoString header;
             httpChannel->GetResponseHeader(NS_LITERAL_CSTRING(""""Content-Type""""),
                                            header);
-
             nsCAutoString contentType;
             nsCAutoString charset;
             NS_ParseContentType(header, contentType, charset);
-
             mIsUnsafe = !contentType.EqualsLiteral(""""application/java-archive"""") &&
                         !contentType.EqualsLiteral(""""application/x-jar"""");
+            rv = httpChannel->GetResponseHeader(NS_LITERAL_CSTRING(""""Content-Disposition""""),
+                                                header);
+            if (NS_SUCCEEDED(rv))
+                SetPropertyAsACString(NS_CHANNEL_PROP_CONTENT_DISPOSITION, header);
         } else {
             nsCOMPtr<nsIJARChannel> innerJARChannel(do_QueryInterface(channel));
             if (innerJARChannel) {
@@ -777,6 +788,10 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
                 innerJARChannel->GetIsUnsafe(&unsafe);
                 mIsUnsafe = unsafe;
             }
+            // Soon-to-be common way to get Disposition: right now only nsIJARChannel
+            rv = NS_GetContentDisposition(request, header);
+            if (NS_SUCCEEDED(rv))
+                SetPropertyAsACString(NS_CHANNEL_PROP_CONTENT_DISPOSITION, header);
         }
     }
 
diff --git a/modules/libjar/nsJARChannel.h b/modules/libjar/nsJARChannel.h
index 719b298..9e84f58 100644
--- a/modules/libjar/nsJARChannel.h
+++ b/modules/libjar/nsJARChannel.h
@@ -47,6 +47,7 @@
 #include """"nsIZipReader.h""""
 #include """"nsIDownloader.h""""
 #include """"nsILoadGroup.h""""
+#include """"nsHashPropertyBag.h""""
 #include """"nsIFile.h""""
 #include """"nsIURI.h""""
 #include """"nsCOMPtr.h""""
@@ -60,6 +61,7 @@ class nsJARInputThunk;
 class nsJARChannel : public nsIJARChannel
                    , public nsIDownloadObserver
                    , public nsIStreamListener
+                   , public nsHashPropertyBag
 {
 public:
     NS_DECL_ISUPPORTS
diff --git a/netwerk/base/public/nsChannelProperties.h b/netwerk/base/public/nsChannelProperties.h
index 5a45821..f1036a6 100644
--- a/netwerk/base/public/nsChannelProperties.h
+++ b/netwerk/base/public/nsChannelProperties.h
@@ -58,11 +58,21 @@
  */
 #define NS_CHANNEL_PROP_CONTENT_LENGTH_STR """"content-length""""
 
+/**
+ * MIME Content-Disposition header of channel.  
+ * Not available before onStartRequest. 
+ * Type: nsACString
+ */
+#define NS_CHANNEL_PROP_CONTENT_DISPOSITION_STR """"content-disposition""""
+
 #ifdef IMPL_NS_NET
 #define NS_CHANNEL_PROP_CONTENT_LENGTH gNetStrings->kContentLength
+#define NS_CHANNEL_PROP_CONTENT_DISPOSITION gNetStrings->kContentDisposition
 #else
 #define NS_CHANNEL_PROP_CONTENT_LENGTH \
   NS_LITERAL_STRING(NS_CHANNEL_PROP_CONTENT_LENGTH_STR)
+#define NS_CHANNEL_PROP_CONTENT_DISPOSITION \
+  NS_LITERAL_STRING(NS_CHANNEL_PROP_CONTENT_DISPOSITION_STR)
 #endif
 
 #endif
diff --git a/netwerk/base/public/nsNetStrings.h b/netwerk/base/public/nsNetStrings.h
index 603457a..44d63a77 100644
--- a/netwerk/base/public/nsNetStrings.h
+++ b/netwerk/base/public/nsNetStrings.h
@@ -49,6 +49,7 @@ public:
 
   /** """"content-length"""" */
   const nsLiteralString kContentLength;
+  const nsLiteralString kContentDisposition;
 };
 
 extern NS_HIDDEN_(nsNetStrings*) gNetStrings;
diff --git a/netwerk/base/public/nsNetUtil.h b/netwerk/base/public/nsNetUtil.h
index 5db2261..05eb50c 100644
--- a/netwerk/base/public/nsNetUtil.h
+++ b/netwerk/base/public/nsNetUtil.h
@@ -62,6 +62,7 @@
 #include """"nsIIOService.h""""
 #include """"nsIServiceManager.h""""
 #include """"nsIChannel.h""""
+#include """"nsChannelProperties.h""""
 #include """"nsIInputStreamChannel.h""""
 #include """"nsITransport.h""""
 #include """"nsIStreamTransportService.h""""
@@ -194,6 +195,19 @@ NS_NewChannel(nsIChannel           **result,
     return rv;
 }
 
+// For now, works only with JARChannel.  Future: with all channels that may
+// have Content-Disposition header (JAR, nsIHttpChannel, and nsIMultiPartChannel).
+inline nsresult
+NS_GetContentDisposition(nsIRequest     *channel,
+                         nsACString     &result)
+{
+    nsCOMPtr<nsIPropertyBag2> props(do_QueryInterface(channel));
+    if (props)
+        return props->GetPropertyAsACString(NS_CHANNEL_PROP_CONTENT_DISPOSITION,
+                                            result);
+    return NS_ERROR_NOT_AVAILABLE;
+}
+
 // Use this function with CAUTION. It creates a stream that blocks when you
 // Read() from it and blocking the UI thread is a bad idea. If you don't want
 // to implement a full blown asynchronous consumer (via nsIStreamListener) look
diff --git a/netwerk/base/src/nsNetStrings.cpp b/netwerk/base/src/nsNetStrings.cpp
index b8d47d8..2ac1a86 100644
--- a/netwerk/base/src/nsNetStrings.cpp
+++ b/netwerk/base/src/nsNetStrings.cpp
@@ -41,6 +41,7 @@ NS_HIDDEN_(nsNetStrings*) gNetStrings;
 
 nsNetStrings::nsNetStrings()
   : NS_LITERAL_STRING_INIT(kContentLength, NS_CHANNEL_PROP_CONTENT_LENGTH_STR)
+  : NS_LITERAL_STRING_INIT(kContentDisposition, NS_CHANNEL_PROP_CONTENT_DISPOSITION_STR)
 {}
 
 
diff --git a/netwerk/protocol/http/src/nsHttpAtomList.h b/netwerk/protocol/http/src/nsHttpAtomList.h
index 77096da..f11c724 100644
--- a/netwerk/protocol/http/src/nsHttpAtomList.h
+++ b/netwerk/protocol/http/src/nsHttpAtomList.h
@@ -62,6 +62,7 @@ HTTP_ATOM(Authorization,             """"Authorization"""")
 HTTP_ATOM(Cache_Control,             """"Cache-Control"""")
 HTTP_ATOM(Connection,                """"Connection"""")
 HTTP_ATOM(Content_Base,              """"Content-Base"""")
+HTTP_ATOM(Content_Disposition,       """"Content-Disposition"""")
 HTTP_ATOM(Content_Encoding,          """"Content-Encoding"""")
 HTTP_ATOM(Content_Language,          """"Content-Language"""")
 HTTP_ATOM(Content_Length,            """"Content-Length"""")
diff --git a/netwerk/streamconv/test/Makefile.in b/netwerk/streamconv/test/Makefile.in
index 4b8b597..ea2f55b 100644
--- a/netwerk/streamconv/test/Makefile.in
+++ b/netwerk/streamconv/test/Makefile.in
@@ -73,4 +73,3 @@ DEFINES		+= -DNGPREFS
 endif
 endif # WINNT
 
-DEFINES += -DIMPL_NS_NET
diff --git a/uriloader/base/nsURILoader.cpp b/uriloader/base/nsURILoader.cpp
index 770bcaa..a593877 100644
--- a/uriloader/base/nsURILoader.cpp
+++ b/uriloader/base/nsURILoader.cpp
@@ -65,7 +65,7 @@
 
 #include """"nsXPIDLString.h""""
 #include """"nsString.h""""
-
+#include """"nsNetUtil.h""""
 #include """"nsIDOMWindowInternal.h""""
 #include """"nsReadableUtils.h""""
 #include """"nsDOMError.h""""
@@ -380,6 +380,9 @@ nsresult nsDocumentOpenInfo::DispatchContent(nsIRequest *request, nsISupports *
     if (multipartChannel)
     {
       rv = multipartChannel->GetContentDisposition(disposition);
+    } else {
+      // Soon-to-be common way to get Disposition: right now only JARChannel
+      rv = NS_GetContentDisposition(request, disposition);
     }
   }
 """
49e6ff48ca92692c5405a1673f7806bf17d3e05f,48486,477979,Wladimir Palant,"Bug 477979 - Add CheckLoadURI checks for more script loads.  r+sr=jst
",1234363897,"""diff --git a/content/base/src/nsScriptLoader.cpp b/content/base/src/nsScriptLoader.cpp
index 2929f5c..ec2625f 100644
--- a/content/base/src/nsScriptLoader.cpp
+++ b/content/base/src/nsScriptLoader.cpp
@@ -199,14 +199,15 @@ IsScriptEventHandler(nsIScriptElement *aScriptElement)
 }
 
 nsresult
-nsScriptLoader::CheckContentPolicy(nsScriptLoadRequest *aRequest,
+nsScriptLoader::CheckContentPolicy(nsIDocument* aDocument,
                                    nsISupports *aContext,
+                                   nsIURI *aURI,
                                    const nsAString &aType)
 {
   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
   nsresult rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_SCRIPT,
-                                          aRequest->mURI,
-                                          mDocument->NodePrincipal(),
+                                          aURI,
+                                          aDocument->NodePrincipal(),
                                           aContext,
                                           NS_LossyConvertUTF16toASCII(aType),
                                           nsnull,    //extra
@@ -224,20 +225,34 @@ nsScriptLoader::CheckContentPolicy(nsScriptLoadRequest *aRequest,
 }
 
 nsresult
-nsScriptLoader::StartLoad(nsScriptLoadRequest *aRequest, const nsAString &aType)
+nsScriptLoader::ShouldLoadScript(nsIDocument* aDocument,
+                                 nsISupports* aContext,
+                                 nsIURI* aURI,
+                                 const nsAString &aType)
 {
   // Check that the containing page is allowed to load this URI.
   nsresult rv = nsContentUtils::GetSecurityManager()->
-    CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), aRequest->mURI,
+    CheckLoadURIWithPrincipal(aDocument->NodePrincipal(), aURI,
                               nsIScriptSecurityManager::ALLOW_CHROME);
 
   NS_ENSURE_SUCCESS(rv, rv);
 
   // After the security manager, the content-policy stuff gets a veto
+  rv = CheckContentPolicy(aDocument, aContext, aURI, aType);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  return NS_OK;
+}
+
+nsresult
+nsScriptLoader::StartLoad(nsScriptLoadRequest *aRequest, const nsAString &aType)
+{
   nsISupports *context = aRequest->mElement.get()
                          ? static_cast<nsISupports *>(aRequest->mElement.get())
                          : static_cast<nsISupports *>(mDocument);
-  rv = CheckContentPolicy(aRequest, context, aType);
+  nsresult rv = ShouldLoadScript(mDocument, context, aRequest->mURI, aType);
   if (NS_FAILED(rv)) {
     return rv;
   }
@@ -485,7 +500,7 @@ nsScriptLoader::ProcessScriptElement(nsIScriptElement *aElement)
       request->mDefer = mDeferEnabled && aElement->GetScriptDeferred();
       mPreloads.RemoveElementAt(i);
 
-      rv = CheckContentPolicy(request, aElement, type);
+      rv = CheckContentPolicy(mDocument, aElement, request->mURI, type);
       if (NS_FAILED(rv)) {
         // Note, we're dropping our last ref to request here.
         return rv;
diff --git a/content/base/src/nsScriptLoader.h b/content/base/src/nsScriptLoader.h
index e82d31c..5a297cb 100644
--- a/content/base/src/nsScriptLoader.h
+++ b/content/base/src/nsScriptLoader.h
@@ -181,6 +181,15 @@ public:
   void ProcessPendingRequests();
 
   /**
+   * Check whether it's OK to load a script from aURI in
+   * aDocument.
+   */
+  static nsresult ShouldLoadScript(nsIDocument* aDocument,
+                                   nsISupports* aContext,
+                                   nsIURI* aURI,
+                                   const nsAString &aType);
+
+  /**
    * Check whether it's OK to execute a script loaded via aChannel in
    * aDocument.
    */
@@ -233,9 +242,10 @@ protected:
   /**
    * Helper function to check the content policy for a given request.
    */
-  nsresult CheckContentPolicy(nsScriptLoadRequest *aRequest,
-                              nsISupports *aContext,
-                              const nsAString &aType);
+  static nsresult CheckContentPolicy(nsIDocument* aDocument,
+                                     nsISupports *aContext,
+                                     nsIURI *aURI,
+                                     const nsAString &aType);
 
   /**
    * Start a load for aRequest's URI.
diff --git a/content/xul/document/src/nsXULDocument.cpp b/content/xul/document/src/nsXULDocument.cpp
index c2dd39f..16da38a 100644
--- a/content/xul/document/src/nsXULDocument.cpp
+++ b/content/xul/document/src/nsXULDocument.cpp
@@ -3427,6 +3427,18 @@ nsXULDocument::LoadScript(nsXULPrototypeScript* aScriptProto, PRBool* aBlock)
         }
     }
 
+    // Allow security manager and content policies to veto the load. Note that
+    // at this point we already lost context information of the script.
+    rv = nsScriptLoader::ShouldLoadScript(
+                            this,
+                            static_cast<nsIDocument*>(this),
+                            aScriptProto->mSrcURI,
+                            NS_LITERAL_STRING(""""application/x-javascript""""));
+    if (NS_FAILED(rv)) {
+      *aBlock = PR_FALSE;
+      return rv;
+    }
+
     // Set the current script prototype so that OnStreamComplete can report
     // the right file if there are errors in the script.
     NS_ASSERTION(!mCurrentScriptProto,"""
1177ced0714bd749e0335c2658e9da6642ad63d0,48566,468771,Robert O'Callahan,"Bug 468771. Make sure to reflow the last column of a column-set if we're changing its height to be unbounded; it needs to pull all the content from the extra column, if there is one. r+sr=dbaron

--HG--
extra : rebase_source : a285d26735ef7c0cddb0f8ff21504c52cd4346fc
",1234315259,"""diff --git a/layout/generic/nsColumnSetFrame.cpp b/layout/generic/nsColumnSetFrame.cpp
index 96ae75e..60aea04 100644
--- a/layout/generic/nsColumnSetFrame.cpp
+++ b/layout/generic/nsColumnSetFrame.cpp
@@ -580,10 +580,17 @@ nsColumnSetFrame::ReflowChildren(nsHTMLReflowMetrics&     aDesiredSize,
     // Try to skip reflowing the child. We can't skip if the child is dirty. We also can't
     // skip if the next column is dirty, because the next column's first line(s)
     // might be pullable back to this column. We can't skip if it's the last child
-    // because we need to obtain the bottom margin.
+    // because we need to obtain the bottom margin. We can't skip
+    // if this is the last column and we're supposed to assign unbounded
+    // height to it, because that could change the available height from
+    // the last time we reflowed it and we should try to pull all the
+    // content from its next sibling. (Note that it might be the last
+    // column, but not be the last child because the desired number of columns
+    // has changed.)
     PRBool skipIncremental = !(GetStateBits() & NS_FRAME_IS_DIRTY)
       && !NS_SUBTREE_DIRTY(child)
       && child->GetNextSibling()
+      && !(aUnboundedLastColumn && columnCount == aConfig.mBalanceColCount - 1)
       && !NS_SUBTREE_DIRTY(child->GetNextSibling());
     // If we need to pull up content from the prev-in-flow then this is not just
     // a height shrink. The prev in flow will have set the dirty bit.
@@ -1018,6 +1025,10 @@ nsColumnSetFrame::Reflow(nsPresContext*           aPresContext,
 
   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
 
+  NS_ASSERTION(NS_FRAME_IS_COMPLETE(aStatus) ||
+               aReflowState.availableHeight != NS_UNCONSTRAINEDSIZE,
+               """"Column set should be complete if the available height is unconstrained"""");
+
   return NS_OK;
 }
 """
db84d1e8610edad745cd2866b3a3a3c90ca3ad4a,48811,476049,Igor Bukanov,"bug 476049 - optimizing js_CheckRedeclaration for the common case of non-existing properties. r=brendan
",1233604436,"""diff --git a/js/src/jsinterp.cpp b/js/src/jsinterp.cpp
index eff2ab0..b8b3752 100644
--- a/js/src/jsinterp.cpp
+++ b/js/src/jsinterp.cpp
@@ -1601,63 +1601,84 @@ js_CheckRedeclaration(JSContext *cx, JSObject *obj, jsid id, uintN attrs,
     jsval value;
     const char *type, *name;
 
+    /*
+     * Both objp and propp must be either null or given. When given, *propp
+     * must be null. This way we avoid an extra """"if (propp) *propp = NULL"""" for
+     * the common case of a non-existing property.
+     */
+    JS_ASSERT(!objp == !propp);
+    JS_ASSERT_IF(propp, !*propp);
+
+    /* The JSPROP_INITIALIZER case below may generate a warning. Since we must
+     * drop the property before reporting it, we insists on !propp to avoid
+     * looking up the property again after the reporting is done.
+     */
+    JS_ASSERT_IF(attrs & JSPROP_INITIALIZER, attrs == JSPROP_INITIALIZER);
+    JS_ASSERT_IF(attrs == JSPROP_INITIALIZER, !propp);
+
     if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &obj2, &prop))
         return JS_FALSE;
-    if (propp) {
-        *objp = obj2;
-        *propp = prop;
-    }
     if (!prop)
         return JS_TRUE;
 
-    /*
-     * Use prop as a speedup hint to OBJ_GET_ATTRIBUTES, but drop it on error.
-     * An assertion at label bad: will insist that it is null.
-     */
+    /* Use prop as a speedup hint to OBJ_GET_ATTRIBUTES. */
     if (!OBJ_GET_ATTRIBUTES(cx, obj2, id, prop, &oldAttrs)) {
         OBJ_DROP_PROPERTY(cx, obj2, prop);
-#ifdef DEBUG
-        prop = NULL;
-#endif
-        goto bad;
+        return JS_FALSE;
     }
 
     /*
-     * From here, return true, or else goto bad on failure to null out params.
      * If our caller doesn't want prop, drop it (we don't need it any longer).
      */
     if (!propp) {
         OBJ_DROP_PROPERTY(cx, obj2, prop);
         prop = NULL;
+    } else {
+        *objp = obj2;
+        *propp = prop;
     }
 
     if (attrs == JSPROP_INITIALIZER) {
         /* Allow the new object to override properties. */
         if (obj2 != obj)
             return JS_TRUE;
+
+        /* The property must be dropped already. */
+        JS_ASSERT(!prop);
         report = JSREPORT_WARNING | JSREPORT_STRICT;
     } else {
         /* We allow redeclaring some non-readonly properties. */
         if (((oldAttrs | attrs) & JSPROP_READONLY) == 0) {
-            /*
-             * Allow redeclaration of variables and functions, but insist that
-             * the new value is not a getter if the old value was, ditto for
-             * setters -- unless prop is impermanent (in which case anyone
-             * could delete it and redefine it, willy-nilly).
-             */
+            /* Allow redeclaration of variables and functions. */
             if (!(attrs & (JSPROP_GETTER | JSPROP_SETTER)))
                 return JS_TRUE;
+
+            /*
+             * Allow adding a getter only if a property already has a setter
+             * but no getter and similarly for adding a setter. That is, we
+             * allow only the following transitions:
+             *
+             *   no-property --> getter --> getter + setter
+             *   no-property --> setter --> getter + setter
+             */
             if ((~(oldAttrs ^ attrs) & (JSPROP_GETTER | JSPROP_SETTER)) == 0)
                 return JS_TRUE;
+
+            /*
+             * Allow redeclaration of an impermanent property (in which case
+             * anyone could delete it and redefine it, willy-nilly).
+             */
             if (!(oldAttrs & JSPROP_PERMANENT))
                 return JS_TRUE;
         }
+        if (prop)
+            OBJ_DROP_PROPERTY(cx, obj2, prop);
 
         report = JSREPORT_ERROR;
         isFunction = (oldAttrs & (JSPROP_GETTER | JSPROP_SETTER)) != 0;
         if (!isFunction) {
             if (!OBJ_GET_PROPERTY(cx, obj, id, &value))
-                goto bad;
+                return JS_FALSE;
             isFunction = VALUE_IS_FUNCTION(cx, value);
         }
     }
@@ -1675,19 +1696,11 @@ js_CheckRedeclaration(JSContext *cx, JSObject *obj, jsid id, uintN attrs,
            : js_var_str;
     name = js_ValueToPrintableString(cx, ID_TO_VALUE(id));
     if (!name)
-        goto bad;
+        return JS_FALSE;
     return JS_ReportErrorFlagsAndNumber(cx, report,
                                         js_GetErrorMessage, NULL,
                                         JSMSG_REDECLARED_VAR,
                                         type, name);
-
-bad:
-    if (propp) {
-        *objp = NULL;
-        *propp = NULL;
-    }
-    JS_ASSERT(!prop);
-    return JS_FALSE;
 }
 
 JSBool
@@ -5655,6 +5668,7 @@ js_Interpret(JSContext *cx)
 
             /* Lookup id in order to check for redeclaration problems. */
             id = ATOM_TO_JSID(atom);
+            prop = NULL;
             if (!js_CheckRedeclaration(cx, obj, id, attrs, &obj2, &prop))
                 goto error;
 
@@ -5677,11 +5691,11 @@ js_Interpret(JSContext *cx)
              */
             if (!fp->fun &&
                 index < GlobalVarCount(fp) &&
-                (attrs & JSPROP_PERMANENT) &&
                 obj2 == obj &&
                 OBJ_IS_NATIVE(obj)) {
                 sprop = (JSScopeProperty *) prop;
-                if (SPROP_HAS_VALID_SLOT(sprop, OBJ_SCOPE(obj)) &&
+                if ((sprop->attrs & JSPROP_PERMANENT) &&
+                    SPROP_HAS_VALID_SLOT(sprop, OBJ_SCOPE(obj)) &&
                     SPROP_HAS_STUB_GETTER(sprop) &&
                     SPROP_HAS_STUB_SETTER(sprop)) {
                     /*"""
507298bd2e95c9cdf0b26b6b4d14c770b070a64e,48852,460882,Ben Turner,"Bug 460882. r+sr=mrbkap.
",1234818973,"""diff --git a/dom/src/base/nsDOMClassInfo.cpp b/dom/src/base/nsDOMClassInfo.cpp
index 890242b..4a87683 100644
--- a/dom/src/base/nsDOMClassInfo.cpp
+++ b/dom/src/base/nsDOMClassInfo.cpp
@@ -6665,48 +6665,19 @@ nsWindowSH::OuterObject(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
     // never be called when we have no outer. But just in case, return
     // null to prevent leaking an inner window to code in a different
     // window.
-
     *_retval = nsnull;
-
     return NS_ERROR_UNEXPECTED;
   }
 
-  // Return the outer window.
-
-  // FIXME bug 420372: Our window should always have a JS object here. It
-  // doesn't because of nsJSContext::FindXPCNativeWrapperClass.
-  nsresult rv;
-  if (win->IsChromeWindow()) {
-    // Chrome windows don't get XOW wrapping.
-    JSObject *outerObj = win->GetGlobalJSObject();
-    if (!outerObj) {
-      NS_ASSERTION(origWin->IsOuterWindow(), """"What window is this?"""");
-      *_retval = obj;
-    } else {
-      *_retval = outerObj;
-    }
-
-    rv = NS_OK;
-  } else {
-    JSObject *winObj = win->GetGlobalJSObject();
-    if (!winObj) {
-      NS_ASSERTION(origWin->IsOuterWindow(), """"What window is this?"""");
-      *_retval = obj;
-      rv = NS_OK;
-    } else {
-      JSObject *scope = JS_GetScopeChain(cx);
-      if (!scope) {
-        *_retval = nsnull;
-        return NS_ERROR_FAILURE;
-      }
-      scope = ::JS_GetGlobalForObject(cx, scope);
-      jsval v;
-      rv = sXPConnect->GetXOWForObject(cx, scope, winObj, &v);
-      *_retval = NS_SUCCEEDED(rv) ? JSVAL_TO_OBJECT(v) : nsnull;
-    }
+  JSObject *winObj = win->GetGlobalJSObject();
+  if (!winObj) {
+    NS_ASSERTION(origWin->IsOuterWindow(), """"What window is this?"""");
+    *_retval = obj;
+    return NS_OK;
   }
 
-  return rv;
+  *_retval = winObj;
+  return NS_OK;
 }
 
 NS_IMETHODIMP
diff --git a/js/src/jsdbgapi.cpp b/js/src/jsdbgapi.cpp
index 9a331ee..5a5d9ff 100644
--- a/js/src/jsdbgapi.cpp
+++ b/js/src/jsdbgapi.cpp
@@ -654,7 +654,7 @@ js_watch_set(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
                       ? js_InternalCall(cx, obj,
                                         OBJECT_TO_JSVAL((JSObject *)wp->setter),
                                         1, vp, vp)
-                      : wp->setter(cx, OBJ_THIS_OBJECT(cx, obj), userid, vp));
+                      : wp->setter(cx, obj, userid, vp));
                 if (injectFrame) {
                     /* Evil code can cause us to have an arguments object. */
                     if (frame.callobj)
diff --git a/js/src/jsinterp.cpp b/js/src/jsinterp.cpp
index 2761494..f153fe0 100644
--- a/js/src/jsinterp.cpp
+++ b/js/src/jsinterp.cpp
@@ -856,16 +856,18 @@ ComputeThis(JSContext *cx, JSBool lazy, jsval *argv)
             return js_ComputeGlobalThis(cx, lazy, argv);
         }
 
+        OBJ_TO_OUTER_OBJECT(cx, thisp);
+        if (!thisp)
+            return NULL;
+        argv[-1] = OBJECT_TO_JSVAL(thisp);
+
         if (thisp->map->ops->thisObject) {
             /* Some objects (e.g., With) delegate 'this' to another object. */
             thisp = thisp->map->ops->thisObject(cx, thisp);
             if (!thisp)
                 return NULL;
-        }
-        OBJ_TO_OUTER_OBJECT(cx, thisp);
-        if (!thisp)
-            return NULL;
-        argv[-1] = OBJECT_TO_JSVAL(thisp);
+            argv[-1] = OBJECT_TO_JSVAL(thisp);
+       }
     }
     return thisp;
 }
diff --git a/js/src/jsscope.h b/js/src/jsscope.h
index fac02ad..1935abe 100644
--- a/js/src/jsscope.h
+++ b/js/src/jsscope.h
@@ -339,7 +339,7 @@ SPROP_GET(JSContext* cx, JSScopeProperty* sprop, JSObject* obj, JSObject* obj2,
                                    0, 0, vp);
     }
 
-    return sprop->getter(cx, OBJ_THIS_OBJECT(cx, obj), SPROP_USERID(sprop), vp);
+    return sprop->getter(cx, obj, SPROP_USERID(sprop), vp);
 }
 
 static JS_INLINE JSBool
@@ -360,7 +360,7 @@ SPROP_SET(JSContext* cx, JSScopeProperty* sprop, JSObject* obj, JSObject* obj2,
         return JS_FALSE;
     }
 
-    return sprop->setter(cx, OBJ_THIS_OBJECT(cx, obj), SPROP_USERID(sprop), vp);
+    return sprop->setter(cx, obj, SPROP_USERID(sprop), vp);
 }
 
 /* Macro for common expression to test for shared permanent attributes. */
diff --git a/js/src/xpconnect/idl/nsIXPConnect.idl b/js/src/xpconnect/idl/nsIXPConnect.idl
index 146e0f8..831aef7 100644
--- a/js/src/xpconnect/idl/nsIXPConnect.idl
+++ b/js/src/xpconnect/idl/nsIXPConnect.idl
@@ -405,7 +405,7 @@ interface nsIXPCFunctionThisTranslator : nsISupports
     { 0xbd, 0xd6, 0x0, 0x0, 0x64, 0x65, 0x73, 0x74 } }
 %}
 
-[uuid(f8bf005e-3700-411c-ba0c-e018075f22a4)]
+[uuid(b2ddc328-194b-45d6-95c6-52e487438096)]
 interface nsIXPConnect : nsISupports
 {
 %{ C++
@@ -785,4 +785,33 @@ interface nsIXPConnect : nsISupports
         in PRUint32 flags,
         in PRUint32 interfaceCount,
         [array, size_is(interfaceCount)] in nsIIDPtr interfaceArray);
+
+    /**
+     * Returns a XPCNativeWrapper, XPCSafeJSObjectWrapper, or
+     * XPCCrossOriginWrapper for the given object based on the principal, scope,
+     * and filename flags that are passed in.
+     *
+     * @param aJSContext
+     *     A JSContext.
+     * @param aObject
+     *     The object to wrap.
+     * @param aScope
+     *     The scope to be used in the event that we create a
+     *     XPCCrossOriginWrapper. Can be null.
+     * @param aPrincipal
+     *     The principal that should be used for the wrapper. If this parameter
+     *     is given then aFilenameFlags will not be calculated and will be
+     *     assumed to be 0 unless another value is given. If this parameter is
+     *     null then aFilenameFlags will be calculated and the value of that
+     *     argument will be ignored.
+     * @param aFilenameFlags
+     *     The filename flags from the script that will use this wrapper. See
+     *     above (aPrincipal) for details.
+     */
+    [noscript] JSVal getWrapperForObject(
+        in JSContextPtr aJSContext,
+        in JSObjectPtr aObject,
+        in JSObjectPtr aScope,
+        in nsIPrincipal aPrincipal,
+        in unsigned long aFilenameFlags);
 };
diff --git a/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp b/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp
index 0557125..aea1c1b 100644
--- a/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp
+++ b/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp
@@ -472,24 +472,31 @@ XPC_XOW_RewrapIfNeeded(JSContext *cx, JSObject *outerObj, jsval *vp)
 }
 
 JSBool
-XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp)
+XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp,
+                   XPCWrappedNative* wn)
 {
-  // Our argument should be a wrapped native object.
+  NS_ASSERTION(XPCPerThreadData::IsMainThread(cx),
+               """"Can't do this off the main thread!"""");
+
+  // Our argument should be a wrapped native object, but the caller may have
+  // passed it in as an optimization.
   JSObject *wrappedObj;
-  XPCWrappedNative *wn;
   if (!JSVAL_IS_OBJECT(*vp) ||
       !(wrappedObj = JSVAL_TO_OBJECT(*vp)) ||
-      STOBJ_GET_CLASS(wrappedObj) == &sXPC_XOW_JSClass.base ||
+      STOBJ_GET_CLASS(wrappedObj) == &sXPC_XOW_JSClass.base) {
+    return JS_TRUE;
+  }
+
+  if (!wn &&
       !(wn = XPCWrappedNative::GetWrappedNativeOfJSObject(cx, wrappedObj))) {
     return JS_TRUE;
   }
 
   XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
-  XPCCallContext ccx(NATIVE_CALLER, cx);
-  NS_ENSURE_TRUE(ccx.IsValid(), JS_FALSE);
 
   // The parent must be the inner global object for its scope.
   parent = JS_GetGlobalForObject(cx, parent);
+
   JSClass *clasp = STOBJ_GET_CLASS(parent);
   if (clasp->flags & JSCLASS_IS_EXTENDED) {
     JSExtendedClass *xclasp = reinterpret_cast<JSExtendedClass *>(clasp);
@@ -502,7 +509,7 @@ XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp)
   }
 
   XPCWrappedNativeScope *parentScope =
-    XPCWrappedNativeScope::FindInJSObjectScope(ccx, parent);
+    XPCWrappedNativeScope::FindInJSObjectScope(cx, parent, nsnull, rt);
 
 #ifdef DEBUG_mrbkap_off
   printf(""""Wrapping object at %p (%s) [%p]\n"""",
@@ -513,11 +520,7 @@ XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp)
   JSObject *outerObj = nsnull;
   WrappedNative2WrapperMap *map = parentScope->GetWrapperMap();
 
-  { // Scoped lock
-    XPCAutoLock al(rt->GetMapLock());
-    outerObj = map->Find(wrappedObj);
-  }
-
+  outerObj = map->Find(wrappedObj);
   if (outerObj) {
     NS_ASSERTION(STOBJ_GET_CLASS(outerObj) == &sXPC_XOW_JSClass.base,
                               """"What crazy object are we getting here?"""");
@@ -547,10 +550,7 @@ XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp)
 
   *vp = OBJECT_TO_JSVAL(outerObj);
 
-  { // Scoped lock
-    XPCAutoLock al(rt->GetMapLock());
-    map->Add(wn->GetScope()->GetWrapperMap(), wrappedObj, outerObj);
-  }
+  map->Add(wn->GetScope()->GetWrapperMap(), wrappedObj, outerObj);
 
   return JS_TRUE;
 }
diff --git a/js/src/xpconnect/src/nsXPConnect.cpp b/js/src/xpconnect/src/nsXPConnect.cpp
index 9597429..145d679 100644
--- a/js/src/xpconnect/src/nsXPConnect.cpp
+++ b/js/src/xpconnect/src/nsXPConnect.cpp
@@ -44,6 +44,7 @@
 
 #include """"xpcprivate.h""""
 #include """"XPCNativeWrapper.h""""
+#include """"XPCWrapper.h""""
 #include """"nsBaseHashtable.h""""
 #include """"nsHashKeys.h""""
 #include """"jsatom.h""""
@@ -2304,6 +2305,99 @@ nsXPConnect::DefineDOMQuickStubs(JSContext * cx,
                                 interfaceCount, interfaceArray);
 }
 
+NS_IMETHODIMP
+nsXPConnect::GetWrapperForObject(JSContext* aJSContext,
+                                 JSObject* aObject,
+                                 JSObject* aScope,
+                                 nsIPrincipal* aPrincipal,
+                                 PRUint32 aFilenameFlags,
+                                 jsval* _retval)
+{
+    NS_ASSERTION(aFilenameFlags != JSFILENAME_NULL, """"Null filename!"""");
+    NS_ASSERTION(XPCPerThreadData::IsMainThread(aJSContext),
+                 """"Must only be called from the main thread as these wrappers """"
+                 """"are not threadsafe!"""");
+
+    JSAutoRequest ar(aJSContext);
+
+    XPCWrappedNative *wrapper =
+        XPCWrappedNative::GetWrappedNativeOfJSObject(aJSContext, aObject);
+    if(!wrapper)
+    {
+        // Couldn't get the wrapped native (maybe a prototype?) so just return
+        // the original object.
+        *_retval = OBJECT_TO_JSVAL(aObject);
+        return NS_OK;
+    }
+
+    XPCWrappedNativeScope *xpcscope =
+        XPCWrappedNativeScope::FindInJSObjectScope(aJSContext, aScope);
+    if(!xpcscope)
+        return NS_ERROR_FAILURE;
+
+#ifdef DEBUG_mrbkap
+    {
+        JSObject *scopeobj = xpcscope->GetGlobalJSObject();
+        JSObject *toInnerize = scopeobj;
+        OBJ_TO_INNER_OBJECT(aJSContext, toInnerize);
+        NS_ASSERTION(toInnerize == scopeobj, """"Scope chain ending in outer object?"""");
+    }
+#endif
+
+    XPCWrappedNativeScope *objectscope = wrapper->GetScope();
+    {
+        JSObject *possibleOuter = objectscope->GetGlobalJSObject();
+        OBJ_TO_INNER_OBJECT(aJSContext, possibleOuter);
+        if(!possibleOuter)
+            return NS_ERROR_FAILURE;
+
+        if(objectscope->GetGlobalJSObject() != possibleOuter)
+        {
+            objectscope =
+                XPCWrappedNativeScope::FindInJSObjectScope(aJSContext,
+                                                           possibleOuter);
+            NS_ASSERTION(objectscope, """"Unable to find a scope from an object"""");
+        }
+    }
+
+    *_retval = OBJECT_TO_JSVAL(aObject);
+
+    JSBool sameScope = objectscope == xpcscope;
+    if(STOBJ_IS_SYSTEM(aObject) ||
+       (sameScope &&
+        (!XPC_XOW_ClassNeedsXOW(STOBJ_GET_CLASS(aObject)->name) ||
+         (aFilenameFlags & JSFILENAME_SYSTEM))))
+        return NS_OK;
+
+    JSObject* wrappedObj = nsnull;
+
+    if(aFilenameFlags & JSFILENAME_PROTECTED)
+    {
+        NS_ASSERTION(!sameScope, """"Bad filename flags"""");
+        wrappedObj = XPCNativeWrapper::GetNewOrUsed(aJSContext, wrapper,
+                                                    aPrincipal);
+    }
+    else if(aFilenameFlags & JSFILENAME_SYSTEM)
+    {
+        NS_ASSERTION(!sameScope, """"Bad filename flags"""");
+        jsval val = OBJECT_TO_JSVAL(aObject);
+        if(XPC_SJOW_Construct(aJSContext, nsnull, 1, &val, &val))
+            wrappedObj = JSVAL_TO_OBJECT(val);
+    }
+    else
+    {
+        jsval val = OBJECT_TO_JSVAL(aObject);
+        if(XPC_XOW_WrapObject(aJSContext, aScope, &val, wrapper))
+            wrappedObj = JSVAL_TO_OBJECT(val);
+    }
+
+    if(!wrappedObj)
+        return NS_ERROR_FAILURE;
+
+    *_retval = OBJECT_TO_JSVAL(wrappedObj);
+    return NS_OK;
+}
+
 /* attribute JSRuntime runtime; */
 NS_IMETHODIMP
 nsXPConnect::GetRuntime(JSRuntime **runtime)
diff --git a/js/src/xpconnect/src/xpccallcontext.cpp b/js/src/xpconnect/src/xpccallcontext.cpp
index 86c572b..aee3de8 100644
--- a/js/src/xpconnect/src/xpccallcontext.cpp
+++ b/js/src/xpconnect/src/xpccallcontext.cpp
@@ -75,8 +75,6 @@ XPCCallContext::XPCCallContext(XPCContext::LangType callerLanguage,
     if(!mXPC)
         return;
 
-    NS_ADDREF(mXPC);
-
     mThreadData = XPCPerThreadData::GetData(mJSContext);
 
     if(!mThreadData)
@@ -130,6 +128,11 @@ XPCCallContext::XPCCallContext(XPCContext::LangType callerLanguage,
     // hook into call context chain for our thread
     mPrevCallContext = mThreadData->SetCallContext(this);
 
+    // We only need to addref xpconnect once so only do it if this is the first
+    // context in the chain.
+    if(!mPrevCallContext)
+        NS_ADDREF(mXPC);
+
     mState = HAVE_CONTEXT;
 
     if(!obj)
@@ -294,6 +297,8 @@ XPCCallContext::~XPCCallContext()
 {
     // do cleanup...
 
+    PRBool shouldReleaseXPC = PR_FALSE;
+
     if(mXPCContext)
     {
         mXPCContext->SetCallingLangType(mPrevCallerLanguage);
@@ -304,6 +309,8 @@ XPCCallContext::~XPCCallContext()
 #else
         (void) mThreadData->SetCallContext(mPrevCallContext);
 #endif
+
+        shouldReleaseXPC = mPrevCallContext == nsnull;
     }
 
     if(mContextPopRequired)
@@ -363,7 +370,8 @@ XPCCallContext::~XPCCallContext()
     }
 #endif
 
-    NS_IF_RELEASE(mXPC);
+    if(shouldReleaseXPC && mXPC)
+        NS_RELEASE(mXPC);
 }
 
 XPCReadableJSStringWrapper *
diff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h
index 1547906..7e605b1 100644
--- a/js/src/xpconnect/src/xpcprivate.h
+++ b/js/src/xpconnect/src/xpcprivate.h
@@ -1259,8 +1259,17 @@ public:
     void RemoveWrappedNativeProtos();
 
     static XPCWrappedNativeScope*
+    FindInJSObjectScope(JSContext* cx, JSObject* obj,
+                        JSBool OKIfNotInitialized = JS_FALSE,
+                        XPCJSRuntime* runtime = nsnull);
+
+    static XPCWrappedNativeScope*
     FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
-                        JSBool OKIfNotInitialized = JS_FALSE);
+                        JSBool OKIfNotInitialized = JS_FALSE)
+    {
+        return FindInJSObjectScope(ccx, obj, OKIfNotInitialized,
+                                   ccx.GetRuntime());
+    }
 
     static void
     SystemIsBeingShutDown(JSContext* cx);
@@ -4076,7 +4085,8 @@ XPC_SJOW_AttachNewConstructorObject(XPCCallContext &ccx,
                                     JSObject *aGlobalObject);
 
 JSBool
-XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp);
+XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp,
+                   XPCWrappedNative *wn = nsnull);
 
 #ifdef XPC_IDISPATCH_SUPPORT
 // IDispatch specific classes
diff --git a/js/src/xpconnect/src/xpcwrappednativejsops.cpp b/js/src/xpconnect/src/xpcwrappednativejsops.cpp
index b5c9e2a..8ff1100 100644
--- a/js/src/xpconnect/src/xpcwrappednativejsops.cpp
+++ b/js/src/xpconnect/src/xpcwrappednativejsops.cpp
@@ -43,6 +43,7 @@
 
 #include """"xpcprivate.h""""
 #include """"XPCNativeWrapper.h""""
+#include """"XPCWrapper.h""""
 
 /***************************************************************************/
 
@@ -1275,6 +1276,108 @@ XPC_WN_JSOp_Clear(JSContext *cx, JSObject *obj)
     js_ObjectOps.clear(cx, obj);
 }
 
+namespace {
+
+NS_STACK_CLASS class AutoPopJSContext
+{
+public:
+  AutoPopJSContext(XPCJSContextStack *stack)
+  : mCx(nsnull), mStack(stack)
+  {
+      NS_ASSERTION(stack, """"Null stack!"""");
+  }
+
+  ~AutoPopJSContext()
+  {
+      if(mCx)
+          mStack->Pop(nsnull);
+  }
+
+  void PushIfNotTop(JSContext *cx)
+  {
+      NS_ASSERTION(cx, """"Null context!"""");
+      NS_ASSERTION(!mCx, """"This class is only meant to be used once!"""");
+
+      JSContext *cxTop = nsnull;
+      mStack->Peek(&cxTop);
+
+      if(cxTop != cx && NS_SUCCEEDED(mStack->Push(cx)))
+          mCx = cx;
+  }
+
+private:
+  JSContext *mCx;
+  XPCJSContextStack *mStack;
+};
+
+} // namespace
+
+static JSObject*
+XPC_WN_JSOp_ThisObject(JSContext *cx, JSObject *obj)
+{
+    // None of the wrappers we could potentially hand out are threadsafe so
+    // just hand out the given object.
+    if(!XPCPerThreadData::IsMainThread(cx))
+        return obj;
+
+    JSObject *scope = JS_GetScopeChain(cx);
+    if(!scope)
+    {
+        XPCThrower::Throw(NS_ERROR_FAILURE, cx);
+        return nsnull;
+    }
+
+    scope = JS_GetGlobalForObject(cx, scope);
+
+    XPCPerThreadData *threadData = XPCPerThreadData::GetData(cx);
+    if(!threadData)
+    {
+        XPCThrower::Throw(NS_ERROR_FAILURE, cx);
+        return nsnull;
+    }
+
+    AutoPopJSContext popper(threadData->GetJSContextStack());
+    popper.PushIfNotTop(cx);
+
+    nsIScriptSecurityManager* secMan = XPCWrapper::GetSecurityManager();
+    if(!secMan)
+    {
+        XPCThrower::Throw(NS_ERROR_FAILURE, cx);
+        return nsnull;
+    }
+
+    JSStackFrame *fp;
+    nsIPrincipal *principal = secMan->GetCxSubjectPrincipalAndFrame(cx, &fp);
+
+    jsval retval = OBJECT_TO_JSVAL(obj);
+    JSAutoTempValueRooter atvr(cx, 1, &retval);
+
+    if(principal && fp)
+    {
+        JSScript* script = JS_GetFrameScript(cx, fp);
+
+        PRUint32 flags = script ? JS_GetScriptFilenameFlags(script) : 0;
+        NS_ASSERTION(flags != JSFILENAME_NULL, """"Null filename!"""");
+
+        nsXPConnect *xpc = nsXPConnect::GetXPConnect();
+        if(!xpc)
+        {
+            XPCThrower::Throw(NS_ERROR_FAILURE, cx);
+            return nsnull;
+        }
+
+        nsresult rv = xpc->GetWrapperForObject(cx, obj, scope, principal, flags,
+                                               &retval);
+        if(NS_FAILED(rv))
+        {
+            XPCThrower::Throw(rv, cx);
+            return nsnull;
+        }
+    }
+
+    return JSVAL_TO_OBJECT(retval);
+}
+
 JSObjectOps *
 XPC_WN_GetObjectOpsNoCall(JSContext *cx, JSClass *clazz)
 {
@@ -1293,14 +1396,15 @@ JSBool xpc_InitWrappedNativeJSOps()
     {
         memcpy(&XPC_WN_NoCall_JSOps, &js_ObjectOps, sizeof(JSObjectOps));
         XPC_WN_NoCall_JSOps.enumerate = XPC_WN_JSOp_Enumerate;
+        XPC_WN_NoCall_JSOps.call = nsnull;
+        XPC_WN_NoCall_JSOps.construct = nsnull;
+        XPC_WN_NoCall_JSOps.clear = XPC_WN_JSOp_Clear;
+        XPC_WN_NoCall_JSOps.thisObject = XPC_WN_JSOp_ThisObject;
 
         memcpy(&XPC_WN_WithCall_JSOps, &js_ObjectOps, sizeof(JSObjectOps));
         XPC_WN_WithCall_JSOps.enumerate = XPC_WN_JSOp_Enumerate;
         XPC_WN_WithCall_JSOps.clear = XPC_WN_JSOp_Clear;
-
-        XPC_WN_NoCall_JSOps.call = nsnull;
-        XPC_WN_NoCall_JSOps.construct = nsnull;
-        XPC_WN_NoCall_JSOps.clear = XPC_WN_JSOp_Clear;
+        XPC_WN_WithCall_JSOps.thisObject = XPC_WN_JSOp_ThisObject;
     }
     return JS_TRUE;
 }
diff --git a/js/src/xpconnect/src/xpcwrappednativescope.cpp b/js/src/xpconnect/src/xpcwrappednativescope.cpp
index 06494db..005fdae 100644
--- a/js/src/xpconnect/src/xpcwrappednativescope.cpp
+++ b/js/src/xpconnect/src/xpcwrappednativescope.cpp
@@ -737,18 +737,19 @@ GetScopeOfObject(JSObject* obj)
 
 
 #ifdef DEBUG
-void DEBUG_CheckForComponentsInScope(XPCCallContext& ccx, JSObject* obj,
-                                     JSBool OKIfNotInitialized)
+void DEBUG_CheckForComponentsInScope(JSContext* cx, JSObject* obj,
+                                     JSBool OKIfNotInitialized,
+                                     XPCJSRuntime* runtime)
 {
     if(OKIfNotInitialized)
         return;
 
-    if(!(JS_GetOptions(ccx) & JSOPTION_PRIVATE_IS_NSISUPPORTS))
+    if(!(JS_GetOptions(cx) & JSOPTION_PRIVATE_IS_NSISUPPORTS))
         return;
 
-    const char* name = ccx.GetRuntime()->GetStringName(XPCJSRuntime::IDX_COMPONENTS);
+    const char* name = runtime->GetStringName(XPCJSRuntime::IDX_COMPONENTS);
     jsval prop;
-    if(JS_LookupProperty(ccx, obj, name, &prop) && !JSVAL_IS_PRIMITIVE(prop))
+    if(JS_LookupProperty(cx, obj, name, &prop) && !JSVAL_IS_PRIMITIVE(prop))
         return;
 
     // This is pretty much always bad. It usually means that native code is
@@ -764,13 +765,15 @@ void DEBUG_CheckForComponentsInScope(XPCCallContext& ccx, JSObject* obj,
 #endif
 }
 #else
-#define DEBUG_CheckForComponentsInScope(ccx, obj, OKIfNotInitialized) ((void)0)
+#define DEBUG_CheckForComponentsInScope(ccx, obj, OKIfNotInitialized, runtime) \
+    ((void)0)
 #endif
 
 // static
 XPCWrappedNativeScope*
-XPCWrappedNativeScope::FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
-                                           JSBool OKIfNotInitialized)
+XPCWrappedNativeScope::FindInJSObjectScope(JSContext* cx, JSObject* obj,
+                                           JSBool OKIfNotInitialized,
+                                           XPCJSRuntime* runtime)
 {
     XPCWrappedNativeScope* scope;
 
@@ -786,13 +789,19 @@ XPCWrappedNativeScope::FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
 
     // Else we'll have to look up the parent chain to get the scope
 
-    obj = JS_GetGlobalForObject(ccx, obj);
+    obj = JS_GetGlobalForObject(cx, obj);
+
+    if(!runtime)
+    {
+        runtime = nsXPConnect::GetRuntimeInstance();
+        NS_ASSERTION(runtime, """"This should never be null!"""");
+    }
 
     // XXX We are assuming that the scope count is low enough that traversing
     // the linked list is more reasonable then doing a hashtable lookup.
     XPCWrappedNativeScope* found = nsnull;
     {   // scoped lock
-        XPCAutoLock lock(ccx.GetRuntime()->GetMapLock());
+        XPCAutoLock lock(runtime->GetMapLock());
 
         DEBUG_TrackScopeTraversal();
 
@@ -808,7 +817,7 @@ XPCWrappedNativeScope::FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
 
     if(found) {
         // This cannot be called within the map lock!
-        DEBUG_CheckForComponentsInScope(ccx, obj, OKIfNotInitialized);
+        DEBUG_CheckForComponentsInScope(cx, obj, OKIfNotInitialized, runtime);
         return found;
     }
 
@@ -819,7 +828,6 @@ XPCWrappedNativeScope::FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
     return nsnull;
 }
 
-
 /***************************************************************************/
 
 static JSDHashOperator"""
a83a21a049e8aafb81eca3decac35ff446ef7012,49118,460882,L. David Baron,"Merge backout of changeset 423eea03fb54 (Bug 460882) for being one of the two changesets that may be causing chrome and a11y tests not to start.
",1233982655,"""diff --git a/dom/src/base/nsDOMClassInfo.cpp b/dom/src/base/nsDOMClassInfo.cpp
index 4a87683..890242b 100644
--- a/dom/src/base/nsDOMClassInfo.cpp
+++ b/dom/src/base/nsDOMClassInfo.cpp
@@ -6665,19 +6665,48 @@ nsWindowSH::OuterObject(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
     // never be called when we have no outer. But just in case, return
     // null to prevent leaking an inner window to code in a different
     // window.
+
     *_retval = nsnull;
+
     return NS_ERROR_UNEXPECTED;
   }
 
-  JSObject *winObj = win->GetGlobalJSObject();
-  if (!winObj) {
-    NS_ASSERTION(origWin->IsOuterWindow(), """"What window is this?"""");
-    *_retval = obj;
-    return NS_OK;
+  // Return the outer window.
+
+  // FIXME bug 420372: Our window should always have a JS object here. It
+  // doesn't because of nsJSContext::FindXPCNativeWrapperClass.
+  nsresult rv;
+  if (win->IsChromeWindow()) {
+    // Chrome windows don't get XOW wrapping.
+    JSObject *outerObj = win->GetGlobalJSObject();
+    if (!outerObj) {
+      NS_ASSERTION(origWin->IsOuterWindow(), """"What window is this?"""");
+      *_retval = obj;
+    } else {
+      *_retval = outerObj;
+    }
+
+    rv = NS_OK;
+  } else {
+    JSObject *winObj = win->GetGlobalJSObject();
+    if (!winObj) {
+      NS_ASSERTION(origWin->IsOuterWindow(), """"What window is this?"""");
+      *_retval = obj;
+      rv = NS_OK;
+    } else {
+      JSObject *scope = JS_GetScopeChain(cx);
+      if (!scope) {
+        *_retval = nsnull;
+        return NS_ERROR_FAILURE;
+      }
+      scope = ::JS_GetGlobalForObject(cx, scope);
+      jsval v;
+      rv = sXPConnect->GetXOWForObject(cx, scope, winObj, &v);
+      *_retval = NS_SUCCEEDED(rv) ? JSVAL_TO_OBJECT(v) : nsnull;
+    }
   }
 
-  *_retval = winObj;
-  return NS_OK;
+  return rv;
 }
 
 NS_IMETHODIMP
diff --git a/js/src/jsdbgapi.cpp b/js/src/jsdbgapi.cpp
index 02f230f..8766517 100644
--- a/js/src/jsdbgapi.cpp
+++ b/js/src/jsdbgapi.cpp
@@ -653,7 +653,7 @@ js_watch_set(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
                      ((sprop->attrs & JSPROP_SETTER)
                       ? js_InternalCall(cx, obj, OBJECT_TO_JSVAL(wp->setter),
                                         1, vp, vp)
-                      : wp->setter(cx, obj, userid, vp));
+                      : wp->setter(cx, OBJ_THIS_OBJECT(cx, obj), userid, vp));
                 if (injectFrame) {
                     /* Evil code can cause us to have an arguments object. */
                     if (frame.callobj)
diff --git a/js/src/jsinterp.cpp b/js/src/jsinterp.cpp
index 3dd31fe..4c1d4de 100644
--- a/js/src/jsinterp.cpp
+++ b/js/src/jsinterp.cpp
@@ -855,18 +855,16 @@ ComputeThis(JSContext *cx, JSBool lazy, jsval *argv)
             return js_ComputeGlobalThis(cx, lazy, argv);
         }
 
-        OBJ_TO_OUTER_OBJECT(cx, thisp);
-        if (!thisp)
-            return NULL;
-        argv[-1] = OBJECT_TO_JSVAL(thisp);
-
         if (thisp->map->ops->thisObject) {
             /* Some objects (e.g., With) delegate 'this' to another object. */
             thisp = thisp->map->ops->thisObject(cx, thisp);
             if (!thisp)
                 return NULL;
-            argv[-1] = OBJECT_TO_JSVAL(thisp);
-       }
+        }
+        OBJ_TO_OUTER_OBJECT(cx, thisp);
+        if (!thisp)
+            return NULL;
+        argv[-1] = OBJECT_TO_JSVAL(thisp);
     }
     return thisp;
 }
diff --git a/js/src/jsscope.h b/js/src/jsscope.h
index 69f1d3b..b7d8455 100644
--- a/js/src/jsscope.h
+++ b/js/src/jsscope.h
@@ -336,7 +336,7 @@ struct JSScopeProperty {
      ? js_InternalGetOrSet(cx, obj, (sprop)->id,                              \
                            OBJECT_TO_JSVAL((sprop)->getter), JSACC_READ,      \
                            0, 0, vp)                                          \
-     : (sprop)->getter(cx, obj, SPROP_USERID(sprop), vp))
+     : (sprop)->getter(cx, OBJ_THIS_OBJECT(cx,obj), SPROP_USERID(sprop), vp))
 
 /*
  * NB: SPROP_SET must not be called if (SPROP_HAS_STUB_SETTER(sprop) &&
@@ -350,7 +350,7 @@ struct JSScopeProperty {
      : ((sprop)->attrs & JSPROP_GETTER)                                       \
      ? (JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,                    \
                              JSMSG_GETTER_ONLY, NULL), JS_FALSE)              \
-     : (sprop)->setter(cx, obj, SPROP_USERID(sprop), vp))
+     : (sprop)->setter(cx, OBJ_THIS_OBJECT(cx,obj), SPROP_USERID(sprop), vp))
 
 /* Macro for common expression to test for shared permanent attributes. */
 #define SPROP_IS_SHARED_PERMANENT(sprop)                                      \
diff --git a/js/src/xpconnect/idl/nsIXPConnect.idl b/js/src/xpconnect/idl/nsIXPConnect.idl
index fd280ce..146e0f8 100644
--- a/js/src/xpconnect/idl/nsIXPConnect.idl
+++ b/js/src/xpconnect/idl/nsIXPConnect.idl
@@ -405,7 +405,7 @@ interface nsIXPCFunctionThisTranslator : nsISupports
     { 0xbd, 0xd6, 0x0, 0x0, 0x64, 0x65, 0x73, 0x74 } }
 %}
 
-[uuid(b2ddc328-194b-45d6-95c6-52e487438096)]
+[uuid(f8bf005e-3700-411c-ba0c-e018075f22a4)]
 interface nsIXPConnect : nsISupports
 {
 %{ C++
@@ -785,28 +785,4 @@ interface nsIXPConnect : nsISupports
         in PRUint32 flags,
         in PRUint32 interfaceCount,
         [array, size_is(interfaceCount)] in nsIIDPtr interfaceArray);
-
-    /**
-     * Returns a XPCNativeWrapper, XPCSafeJSObjectWrapper, or
-     * XPCCrossOriginWrapper for the given object based on the principal, scope,
-     * and filename flags that are passed in.
-     *
-     * @param aJSContext
-     *     A JSContext.
-     * @param aObject
-     *     The object to wrap.
-     * @param aScope
-     *     The scope to be used in the event that we create a
-     *     XPCCrossOriginWrapper. Can be null.
-     * @param aPrincipal
-     *     The principal that should be used for the wrapper.
-     * @param aFilenameFlags
-     *     The filename flags from the script that will use this wrapper.
-     */
-    [noscript] JSVal getWrapperForObject(
-        in JSContextPtr aJSContext,
-        in JSObjectPtr aObject,
-        in JSObjectPtr aScope,
-        in nsIPrincipal aPrincipal,
-        in unsigned long aFilenameFlags);
 };
diff --git a/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp b/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp
index c436806..0557125 100644
--- a/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp
+++ b/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp
@@ -472,31 +472,24 @@ XPC_XOW_RewrapIfNeeded(JSContext *cx, JSObject *outerObj, jsval *vp)
 }
 
 JSBool
-XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp,
-                   XPCWrappedNative* wn)
+XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp)
 {
-  NS_ASSERTION(XPCPerThreadData::IsMainThread(cx),
-               """"Can't wrap object on non-main thread!"""");
-
-  // Our argument should be a wrapped native object, but the caller may have
-  // passed it in as an optimization.
+  // Our argument should be a wrapped native object.
   JSObject *wrappedObj;
+  XPCWrappedNative *wn;
   if (!JSVAL_IS_OBJECT(*vp) ||
       !(wrappedObj = JSVAL_TO_OBJECT(*vp)) ||
-      STOBJ_GET_CLASS(wrappedObj) == &sXPC_XOW_JSClass.base) {
-    return JS_TRUE;
-  }
-
-  if (!wn &&
+      STOBJ_GET_CLASS(wrappedObj) == &sXPC_XOW_JSClass.base ||
       !(wn = XPCWrappedNative::GetWrappedNativeOfJSObject(cx, wrappedObj))) {
     return JS_TRUE;
   }
 
   XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
+  XPCCallContext ccx(NATIVE_CALLER, cx);
+  NS_ENSURE_TRUE(ccx.IsValid(), JS_FALSE);
 
   // The parent must be the inner global object for its scope.
   parent = JS_GetGlobalForObject(cx, parent);
-
   JSClass *clasp = STOBJ_GET_CLASS(parent);
   if (clasp->flags & JSCLASS_IS_EXTENDED) {
     JSExtendedClass *xclasp = reinterpret_cast<JSExtendedClass *>(clasp);
@@ -509,7 +502,7 @@ XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp,
   }
 
   XPCWrappedNativeScope *parentScope =
-    XPCWrappedNativeScope::FindInJSObjectScope(cx, parent, nsnull, rt);
+    XPCWrappedNativeScope::FindInJSObjectScope(ccx, parent);
 
 #ifdef DEBUG_mrbkap_off
   printf(""""Wrapping object at %p (%s) [%p]\n"""",
@@ -520,7 +513,11 @@ XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp,
   JSObject *outerObj = nsnull;
   WrappedNative2WrapperMap *map = parentScope->GetWrapperMap();
 
-  outerObj = map->Find(wrappedObj);
+  { // Scoped lock
+    XPCAutoLock al(rt->GetMapLock());
+    outerObj = map->Find(wrappedObj);
+  }
+
   if (outerObj) {
     NS_ASSERTION(STOBJ_GET_CLASS(outerObj) == &sXPC_XOW_JSClass.base,
                               """"What crazy object are we getting here?"""");
@@ -550,7 +547,10 @@ XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp,
 
   *vp = OBJECT_TO_JSVAL(outerObj);
 
-  map->Add(wn->GetScope()->GetWrapperMap(), wrappedObj, outerObj);
+  { // Scoped lock
+    XPCAutoLock al(rt->GetMapLock());
+    map->Add(wn->GetScope()->GetWrapperMap(), wrappedObj, outerObj);
+  }
 
   return JS_TRUE;
 }
diff --git a/js/src/xpconnect/src/nsXPConnect.cpp b/js/src/xpconnect/src/nsXPConnect.cpp
index c4bb663..9597429 100644
--- a/js/src/xpconnect/src/nsXPConnect.cpp
+++ b/js/src/xpconnect/src/nsXPConnect.cpp
@@ -44,7 +44,6 @@
 
 #include """"xpcprivate.h""""
 #include """"XPCNativeWrapper.h""""
-#include """"XPCWrapper.h""""
 #include """"nsBaseHashtable.h""""
 #include """"nsHashKeys.h""""
 #include """"jsatom.h""""
@@ -2305,71 +2304,6 @@ nsXPConnect::DefineDOMQuickStubs(JSContext * cx,
                                 interfaceCount, interfaceArray);
 }
 
-NS_IMETHODIMP
-nsXPConnect::GetWrapperForObject(JSContext* aJSContext,
-                                 JSObject* aObject,
-                                 JSObject* aScope,
-                                 nsIPrincipal* aPrincipal,
-                                 PRUint32 aFilenameFlags,
-                                 jsval* _retval)
-{
-    NS_ASSERTION(aFilenameFlags != JSFILENAME_NULL, """"Null filename!"""");
-    NS_ASSERTION(XPCPerThreadData::IsMainThread(aJSContext),
-                 """"Must only be called from the main thread as these wrappers """"
-                 """"are not threadsafe!"""");
-
-    JSAutoRequest ar(aJSContext);
-
-    XPCWrappedNative *wrapper =
-        XPCWrappedNative::GetWrappedNativeOfJSObject(aJSContext, aObject);
-    if(!wrapper)
-    {
-        // Couldn't get the wrapped native (maybe a prototype?) so just return
-        // the original object.
-        *_retval = OBJECT_TO_JSVAL(aObject);
-        return NS_OK;
-    }
-
-    XPCWrappedNativeScope *xpcscope =
-        XPCWrappedNativeScope::FindInJSObjectScope(aJSContext, aScope);
-    if(!xpcscope)
-        return NS_ERROR_FAILURE;
-
-    if(STOBJ_IS_SYSTEM(aObject) ||
-       (wrapper->GetScope() == xpcscope &&
-        !XPC_XOW_ClassNeedsXOW(STOBJ_GET_CLASS(aObject)->name)))
-    {
-        *_retval = OBJECT_TO_JSVAL(aObject);
-        return NS_OK;
-    }
-
-    JSObject* wrappedObj = nsnull;
-
-    if(aFilenameFlags & JSFILENAME_PROTECTED)
-    {
-        wrappedObj = XPCNativeWrapper::GetNewOrUsed(aJSContext, wrapper,
-                                                    aPrincipal);
-    }
-    else if(aFilenameFlags & JSFILENAME_SYSTEM)
-    {
-        jsval val = OBJECT_TO_JSVAL(aObject);
-        if(XPC_SJOW_Construct(aJSContext, nsnull, 1, &val, &val))
-            wrappedObj = JSVAL_TO_OBJECT(val);
-    }
-    else
-    {
-        jsval val = OBJECT_TO_JSVAL(aObject);
-        if(XPC_XOW_WrapObject(aJSContext, aScope, &val, wrapper))
-            wrappedObj = JSVAL_TO_OBJECT(val);
-    }
-
-    if(!wrappedObj)
-        return NS_ERROR_FAILURE;
-
-    *_retval = OBJECT_TO_JSVAL(wrappedObj);
-    return NS_OK;
-}
-
 /* attribute JSRuntime runtime; */
 NS_IMETHODIMP
 nsXPConnect::GetRuntime(JSRuntime **runtime)
diff --git a/js/src/xpconnect/src/xpccallcontext.cpp b/js/src/xpconnect/src/xpccallcontext.cpp
index aee3de8..86c572b 100644
--- a/js/src/xpconnect/src/xpccallcontext.cpp
+++ b/js/src/xpconnect/src/xpccallcontext.cpp
@@ -75,6 +75,8 @@ XPCCallContext::XPCCallContext(XPCContext::LangType callerLanguage,
     if(!mXPC)
         return;
 
+    NS_ADDREF(mXPC);
+
     mThreadData = XPCPerThreadData::GetData(mJSContext);
 
     if(!mThreadData)
@@ -128,11 +130,6 @@ XPCCallContext::XPCCallContext(XPCContext::LangType callerLanguage,
     // hook into call context chain for our thread
     mPrevCallContext = mThreadData->SetCallContext(this);
 
-    // We only need to addref xpconnect once so only do it if this is the first
-    // context in the chain.
-    if(!mPrevCallContext)
-        NS_ADDREF(mXPC);
-
     mState = HAVE_CONTEXT;
 
     if(!obj)
@@ -297,8 +294,6 @@ XPCCallContext::~XPCCallContext()
 {
     // do cleanup...
 
-    PRBool shouldReleaseXPC = PR_FALSE;
-
     if(mXPCContext)
     {
         mXPCContext->SetCallingLangType(mPrevCallerLanguage);
@@ -309,8 +304,6 @@ XPCCallContext::~XPCCallContext()
 #else
         (void) mThreadData->SetCallContext(mPrevCallContext);
 #endif
-
-        shouldReleaseXPC = mPrevCallContext == nsnull;
     }
 
     if(mContextPopRequired)
@@ -370,8 +363,7 @@ XPCCallContext::~XPCCallContext()
     }
 #endif
 
-    if(shouldReleaseXPC && mXPC)
-        NS_RELEASE(mXPC);
+    NS_IF_RELEASE(mXPC);
 }
 
 XPCReadableJSStringWrapper *
diff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h
index 49f47f8..bcac67e 100644
--- a/js/src/xpconnect/src/xpcprivate.h
+++ b/js/src/xpconnect/src/xpcprivate.h
@@ -1253,17 +1253,8 @@ public:
     void RemoveWrappedNativeProtos();
 
     static XPCWrappedNativeScope*
-    FindInJSObjectScope(JSContext* cx, JSObject* obj,
-                        JSBool OKIfNotInitialized = JS_FALSE,
-                        XPCJSRuntime* runtime = nsnull);
-
-    static XPCWrappedNativeScope*
     FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
-                        JSBool OKIfNotInitialized = JS_FALSE)
-    {
-        return FindInJSObjectScope(ccx, obj, OKIfNotInitialized,
-                                   ccx.GetRuntime());
-    }
+                        JSBool OKIfNotInitialized = JS_FALSE);
 
     static void
     SystemIsBeingShutDown(JSContext* cx);
@@ -1337,10 +1328,7 @@ private:
     XPCJSRuntime*                    mRuntime;
     Native2WrappedNativeMap*         mWrappedNativeMap;
     ClassInfo2WrappedNativeProtoMap* mWrappedNativeProtoMap;
-
-    // This map should *never* be accessed from a non-main thread!
     WrappedNative2WrapperMap*        mWrapperMap;
-
     nsXPCComponents*                 mComponents;
     XPCWrappedNativeScope*           mNext;
     // The JS global object for this scope.  If non-null, this will be the
@@ -4082,8 +4070,7 @@ XPC_SJOW_AttachNewConstructorObject(XPCCallContext &ccx,
                                     JSObject *aGlobalObject);
 
 JSBool
-XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp,
-                   XPCWrappedNative *wn = nsnull);
+XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp);
 
 #ifdef XPC_IDISPATCH_SUPPORT
 // IDispatch specific classes
diff --git a/js/src/xpconnect/src/xpcwrappednativejsops.cpp b/js/src/xpconnect/src/xpcwrappednativejsops.cpp
index 29785f5..b5c9e2a 100644
--- a/js/src/xpconnect/src/xpcwrappednativejsops.cpp
+++ b/js/src/xpconnect/src/xpcwrappednativejsops.cpp
@@ -43,7 +43,6 @@
 
 #include """"xpcprivate.h""""
 #include """"XPCNativeWrapper.h""""
-#include """"XPCWrapper.h""""
 
 /***************************************************************************/
 
@@ -1276,110 +1275,6 @@ XPC_WN_JSOp_Clear(JSContext *cx, JSObject *obj)
     js_ObjectOps.clear(cx, obj);
 }
 
-namespace {
-
-NS_STACK_CLASS class AutoPopJSContext
-{
-public:
-  AutoPopJSContext(XPCJSContextStack *stack)
-  : mCx(nsnull), mStack(stack)
-  {
-      NS_ASSERTION(stack, """"Null stack!"""");
-  }
-
-  ~AutoPopJSContext()
-  {
-      if(mCx)
-          mStack->Pop(nsnull);
-  }
-
-  void PushIfNotTop(JSContext *cx)
-  {
-      NS_ASSERTION(cx, """"Null context!"""");
-      NS_ASSERTION(!mCx, """"This class is only meant to be used once!"""");
-
-      JSContext *cxTop = nsnull;
-      mStack->Peek(&cxTop);
-
-      if(cxTop != cx && NS_SUCCEEDED(mStack->Push(cx)))
-          mCx = cx;
-  }
-
-private:
-  JSContext *mCx;
-  XPCJSContextStack *mStack;
-};
-
-} // namespace
-
-static JSObject*
-XPC_WN_JSOp_ThisObject(JSContext *cx, JSObject *obj)
-{
-    // None of the wrappers we could potentially hand out are threadsafe so
-    // just hand out the given object.
-    if(!XPCPerThreadData::IsMainThread(cx))
-        return obj;
-
-    JSObject *scope = JS_GetScopeChain(cx);
-    if(!scope)
-    {
-        XPCThrower::Throw(NS_ERROR_FAILURE, cx);
-        return nsnull;
-    }
-
-    scope = JS_GetGlobalForObject(cx, scope);
-
-    XPCPerThreadData *threadData = XPCPerThreadData::GetData(cx);
-    if(!threadData)
-    {
-        XPCThrower::Throw(NS_ERROR_FAILURE, cx);
-        return nsnull;
-    }
-
-    AutoPopJSContext popper(threadData->GetJSContextStack());
-    popper.PushIfNotTop(cx);
-
-    nsIScriptSecurityManager* secMan = XPCWrapper::GetSecurityManager();
-    if(!secMan)
-    {
-        XPCThrower::Throw(NS_ERROR_FAILURE, cx);
-        return nsnull;
-    }
-
-    JSStackFrame *fp;
-    nsIPrincipal *principal = secMan->GetCxSubjectPrincipalAndFrame(cx, &fp);
-
-    jsval retval = OBJECT_TO_JSVAL(obj);
-    JSAutoTempValueRooter atvr(cx, retval);
-
-    if(principal && fp)
-    {
-        JSScript* script = JS_GetFrameScript(cx, fp);
-
-        PRUint32 flags = script ? JS_GetScriptFilenameFlags(script) : 0;
-        NS_ASSERTION(flags != JSFILENAME_NULL, """"Null filename!"""");
-
-        nsXPConnect *xpc = nsXPConnect::GetXPConnect();
-        if(!xpc)
-        {
-            XPCThrower::Throw(NS_ERROR_FAILURE, cx);
-            return nsnull;
-        }
-
-        jsval val = JSVAL_VOID;
-        
-        nsresult rv = xpc->GetWrapperForObject(cx, obj, scope, principal, flags,
-                                               &retval);
-        if(NS_FAILED(rv))
-        {
-            XPCThrower::Throw(rv, cx);
-            return nsnull;
-        }
-    }
-
-    return JSVAL_TO_OBJECT(retval);
-}
-
 JSObjectOps *
 XPC_WN_GetObjectOpsNoCall(JSContext *cx, JSClass *clazz)
 {
@@ -1398,15 +1293,14 @@ JSBool xpc_InitWrappedNativeJSOps()
     {
         memcpy(&XPC_WN_NoCall_JSOps, &js_ObjectOps, sizeof(JSObjectOps));
         XPC_WN_NoCall_JSOps.enumerate = XPC_WN_JSOp_Enumerate;
-        XPC_WN_NoCall_JSOps.call = nsnull;
-        XPC_WN_NoCall_JSOps.construct = nsnull;
-        XPC_WN_NoCall_JSOps.clear = XPC_WN_JSOp_Clear;
-        XPC_WN_NoCall_JSOps.thisObject = XPC_WN_JSOp_ThisObject;
 
         memcpy(&XPC_WN_WithCall_JSOps, &js_ObjectOps, sizeof(JSObjectOps));
         XPC_WN_WithCall_JSOps.enumerate = XPC_WN_JSOp_Enumerate;
         XPC_WN_WithCall_JSOps.clear = XPC_WN_JSOp_Clear;
-        XPC_WN_WithCall_JSOps.thisObject = XPC_WN_JSOp_ThisObject;
+
+        XPC_WN_NoCall_JSOps.call = nsnull;
+        XPC_WN_NoCall_JSOps.construct = nsnull;
+        XPC_WN_NoCall_JSOps.clear = XPC_WN_JSOp_Clear;
     }
     return JS_TRUE;
 }
diff --git a/js/src/xpconnect/src/xpcwrappednativescope.cpp b/js/src/xpconnect/src/xpcwrappednativescope.cpp
index 005fdae..06494db 100644
--- a/js/src/xpconnect/src/xpcwrappednativescope.cpp
+++ b/js/src/xpconnect/src/xpcwrappednativescope.cpp
@@ -737,19 +737,18 @@ GetScopeOfObject(JSObject* obj)
 
 
 #ifdef DEBUG
-void DEBUG_CheckForComponentsInScope(JSContext* cx, JSObject* obj,
-                                     JSBool OKIfNotInitialized,
-                                     XPCJSRuntime* runtime)
+void DEBUG_CheckForComponentsInScope(XPCCallContext& ccx, JSObject* obj,
+                                     JSBool OKIfNotInitialized)
 {
     if(OKIfNotInitialized)
         return;
 
-    if(!(JS_GetOptions(cx) & JSOPTION_PRIVATE_IS_NSISUPPORTS))
+    if(!(JS_GetOptions(ccx) & JSOPTION_PRIVATE_IS_NSISUPPORTS))
         return;
 
-    const char* name = runtime->GetStringName(XPCJSRuntime::IDX_COMPONENTS);
+    const char* name = ccx.GetRuntime()->GetStringName(XPCJSRuntime::IDX_COMPONENTS);
     jsval prop;
-    if(JS_LookupProperty(cx, obj, name, &prop) && !JSVAL_IS_PRIMITIVE(prop))
+    if(JS_LookupProperty(ccx, obj, name, &prop) && !JSVAL_IS_PRIMITIVE(prop))
         return;
 
     // This is pretty much always bad. It usually means that native code is
@@ -765,15 +764,13 @@ void DEBUG_CheckForComponentsInScope(JSContext* cx, JSObject* obj,
 #endif
 }
 #else
-#define DEBUG_CheckForComponentsInScope(ccx, obj, OKIfNotInitialized, runtime) \
-    ((void)0)
+#define DEBUG_CheckForComponentsInScope(ccx, obj, OKIfNotInitialized) ((void)0)
 #endif
 
 // static
 XPCWrappedNativeScope*
-XPCWrappedNativeScope::FindInJSObjectScope(JSContext* cx, JSObject* obj,
-                                           JSBool OKIfNotInitialized,
-                                           XPCJSRuntime* runtime)
+XPCWrappedNativeScope::FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
+                                           JSBool OKIfNotInitialized)
 {
     XPCWrappedNativeScope* scope;
 
@@ -789,19 +786,13 @@ XPCWrappedNativeScope::FindInJSObjectScope(JSContext* cx, JSObject* obj,
 
     // Else we'll have to look up the parent chain to get the scope
 
-    obj = JS_GetGlobalForObject(cx, obj);
-
-    if(!runtime)
-    {
-        runtime = nsXPConnect::GetRuntimeInstance();
-        NS_ASSERTION(runtime, """"This should never be null!"""");
-    }
+    obj = JS_GetGlobalForObject(ccx, obj);
 
     // XXX We are assuming that the scope count is low enough that traversing
     // the linked list is more reasonable then doing a hashtable lookup.
     XPCWrappedNativeScope* found = nsnull;
     {   // scoped lock
-        XPCAutoLock lock(runtime->GetMapLock());
+        XPCAutoLock lock(ccx.GetRuntime()->GetMapLock());
 
         DEBUG_TrackScopeTraversal();
 
@@ -817,7 +808,7 @@ XPCWrappedNativeScope::FindInJSObjectScope(JSContext* cx, JSObject* obj,
 
     if(found) {
         // This cannot be called within the map lock!
-        DEBUG_CheckForComponentsInScope(cx, obj, OKIfNotInitialized, runtime);
+        DEBUG_CheckForComponentsInScope(ccx, obj, OKIfNotInitialized);
         return found;
     }
 
@@ -828,6 +819,7 @@ XPCWrappedNativeScope::FindInJSObjectScope(JSContext* cx, JSObject* obj,
     return nsnull;
 }
 
+
 /***************************************************************************/
 
 static JSDHashOperator"""
354f3359c3dafd3582d93c921397bf3b677e38cb,49119,460882,L. David Baron,"Backed out changeset 423eea03fb54 (Bug 460882) for being one of the two changesets that's causing chrome and a11y tests not to start.
",1233982631,"""diff --git a/dom/src/base/nsDOMClassInfo.cpp b/dom/src/base/nsDOMClassInfo.cpp
index 4a87683..890242b 100644
--- a/dom/src/base/nsDOMClassInfo.cpp
+++ b/dom/src/base/nsDOMClassInfo.cpp
@@ -6665,19 +6665,48 @@ nsWindowSH::OuterObject(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
     // never be called when we have no outer. But just in case, return
     // null to prevent leaking an inner window to code in a different
     // window.
+
     *_retval = nsnull;
+
     return NS_ERROR_UNEXPECTED;
   }
 
-  JSObject *winObj = win->GetGlobalJSObject();
-  if (!winObj) {
-    NS_ASSERTION(origWin->IsOuterWindow(), """"What window is this?"""");
-    *_retval = obj;
-    return NS_OK;
+  // Return the outer window.
+
+  // FIXME bug 420372: Our window should always have a JS object here. It
+  // doesn't because of nsJSContext::FindXPCNativeWrapperClass.
+  nsresult rv;
+  if (win->IsChromeWindow()) {
+    // Chrome windows don't get XOW wrapping.
+    JSObject *outerObj = win->GetGlobalJSObject();
+    if (!outerObj) {
+      NS_ASSERTION(origWin->IsOuterWindow(), """"What window is this?"""");
+      *_retval = obj;
+    } else {
+      *_retval = outerObj;
+    }
+
+    rv = NS_OK;
+  } else {
+    JSObject *winObj = win->GetGlobalJSObject();
+    if (!winObj) {
+      NS_ASSERTION(origWin->IsOuterWindow(), """"What window is this?"""");
+      *_retval = obj;
+      rv = NS_OK;
+    } else {
+      JSObject *scope = JS_GetScopeChain(cx);
+      if (!scope) {
+        *_retval = nsnull;
+        return NS_ERROR_FAILURE;
+      }
+      scope = ::JS_GetGlobalForObject(cx, scope);
+      jsval v;
+      rv = sXPConnect->GetXOWForObject(cx, scope, winObj, &v);
+      *_retval = NS_SUCCEEDED(rv) ? JSVAL_TO_OBJECT(v) : nsnull;
+    }
   }
 
-  *_retval = winObj;
-  return NS_OK;
+  return rv;
 }
 
 NS_IMETHODIMP
diff --git a/js/src/jsdbgapi.cpp b/js/src/jsdbgapi.cpp
index 02f230f..8766517 100644
--- a/js/src/jsdbgapi.cpp
+++ b/js/src/jsdbgapi.cpp
@@ -653,7 +653,7 @@ js_watch_set(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
                      ((sprop->attrs & JSPROP_SETTER)
                       ? js_InternalCall(cx, obj, OBJECT_TO_JSVAL(wp->setter),
                                         1, vp, vp)
-                      : wp->setter(cx, obj, userid, vp));
+                      : wp->setter(cx, OBJ_THIS_OBJECT(cx, obj), userid, vp));
                 if (injectFrame) {
                     /* Evil code can cause us to have an arguments object. */
                     if (frame.callobj)
diff --git a/js/src/jsinterp.cpp b/js/src/jsinterp.cpp
index 3dd31fe..4c1d4de 100644
--- a/js/src/jsinterp.cpp
+++ b/js/src/jsinterp.cpp
@@ -855,18 +855,16 @@ ComputeThis(JSContext *cx, JSBool lazy, jsval *argv)
             return js_ComputeGlobalThis(cx, lazy, argv);
         }
 
-        OBJ_TO_OUTER_OBJECT(cx, thisp);
-        if (!thisp)
-            return NULL;
-        argv[-1] = OBJECT_TO_JSVAL(thisp);
-
         if (thisp->map->ops->thisObject) {
             /* Some objects (e.g., With) delegate 'this' to another object. */
             thisp = thisp->map->ops->thisObject(cx, thisp);
             if (!thisp)
                 return NULL;
-            argv[-1] = OBJECT_TO_JSVAL(thisp);
-       }
+        }
+        OBJ_TO_OUTER_OBJECT(cx, thisp);
+        if (!thisp)
+            return NULL;
+        argv[-1] = OBJECT_TO_JSVAL(thisp);
     }
     return thisp;
 }
diff --git a/js/src/jsscope.h b/js/src/jsscope.h
index 69f1d3b..b7d8455 100644
--- a/js/src/jsscope.h
+++ b/js/src/jsscope.h
@@ -336,7 +336,7 @@ struct JSScopeProperty {
      ? js_InternalGetOrSet(cx, obj, (sprop)->id,                              \
                            OBJECT_TO_JSVAL((sprop)->getter), JSACC_READ,      \
                            0, 0, vp)                                          \
-     : (sprop)->getter(cx, obj, SPROP_USERID(sprop), vp))
+     : (sprop)->getter(cx, OBJ_THIS_OBJECT(cx,obj), SPROP_USERID(sprop), vp))
 
 /*
  * NB: SPROP_SET must not be called if (SPROP_HAS_STUB_SETTER(sprop) &&
@@ -350,7 +350,7 @@ struct JSScopeProperty {
      : ((sprop)->attrs & JSPROP_GETTER)                                       \
      ? (JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,                    \
                              JSMSG_GETTER_ONLY, NULL), JS_FALSE)              \
-     : (sprop)->setter(cx, obj, SPROP_USERID(sprop), vp))
+     : (sprop)->setter(cx, OBJ_THIS_OBJECT(cx,obj), SPROP_USERID(sprop), vp))
 
 /* Macro for common expression to test for shared permanent attributes. */
 #define SPROP_IS_SHARED_PERMANENT(sprop)                                      \
diff --git a/js/src/xpconnect/idl/nsIXPConnect.idl b/js/src/xpconnect/idl/nsIXPConnect.idl
index fd280ce..146e0f8 100644
--- a/js/src/xpconnect/idl/nsIXPConnect.idl
+++ b/js/src/xpconnect/idl/nsIXPConnect.idl
@@ -405,7 +405,7 @@ interface nsIXPCFunctionThisTranslator : nsISupports
     { 0xbd, 0xd6, 0x0, 0x0, 0x64, 0x65, 0x73, 0x74 } }
 %}
 
-[uuid(b2ddc328-194b-45d6-95c6-52e487438096)]
+[uuid(f8bf005e-3700-411c-ba0c-e018075f22a4)]
 interface nsIXPConnect : nsISupports
 {
 %{ C++
@@ -785,28 +785,4 @@ interface nsIXPConnect : nsISupports
         in PRUint32 flags,
         in PRUint32 interfaceCount,
         [array, size_is(interfaceCount)] in nsIIDPtr interfaceArray);
-
-    /**
-     * Returns a XPCNativeWrapper, XPCSafeJSObjectWrapper, or
-     * XPCCrossOriginWrapper for the given object based on the principal, scope,
-     * and filename flags that are passed in.
-     *
-     * @param aJSContext
-     *     A JSContext.
-     * @param aObject
-     *     The object to wrap.
-     * @param aScope
-     *     The scope to be used in the event that we create a
-     *     XPCCrossOriginWrapper. Can be null.
-     * @param aPrincipal
-     *     The principal that should be used for the wrapper.
-     * @param aFilenameFlags
-     *     The filename flags from the script that will use this wrapper.
-     */
-    [noscript] JSVal getWrapperForObject(
-        in JSContextPtr aJSContext,
-        in JSObjectPtr aObject,
-        in JSObjectPtr aScope,
-        in nsIPrincipal aPrincipal,
-        in unsigned long aFilenameFlags);
 };
diff --git a/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp b/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp
index c436806..0557125 100644
--- a/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp
+++ b/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp
@@ -472,31 +472,24 @@ XPC_XOW_RewrapIfNeeded(JSContext *cx, JSObject *outerObj, jsval *vp)
 }
 
 JSBool
-XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp,
-                   XPCWrappedNative* wn)
+XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp)
 {
-  NS_ASSERTION(XPCPerThreadData::IsMainThread(cx),
-               """"Can't wrap object on non-main thread!"""");
-
-  // Our argument should be a wrapped native object, but the caller may have
-  // passed it in as an optimization.
+  // Our argument should be a wrapped native object.
   JSObject *wrappedObj;
+  XPCWrappedNative *wn;
   if (!JSVAL_IS_OBJECT(*vp) ||
       !(wrappedObj = JSVAL_TO_OBJECT(*vp)) ||
-      STOBJ_GET_CLASS(wrappedObj) == &sXPC_XOW_JSClass.base) {
-    return JS_TRUE;
-  }
-
-  if (!wn &&
+      STOBJ_GET_CLASS(wrappedObj) == &sXPC_XOW_JSClass.base ||
       !(wn = XPCWrappedNative::GetWrappedNativeOfJSObject(cx, wrappedObj))) {
     return JS_TRUE;
   }
 
   XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
+  XPCCallContext ccx(NATIVE_CALLER, cx);
+  NS_ENSURE_TRUE(ccx.IsValid(), JS_FALSE);
 
   // The parent must be the inner global object for its scope.
   parent = JS_GetGlobalForObject(cx, parent);
-
   JSClass *clasp = STOBJ_GET_CLASS(parent);
   if (clasp->flags & JSCLASS_IS_EXTENDED) {
     JSExtendedClass *xclasp = reinterpret_cast<JSExtendedClass *>(clasp);
@@ -509,7 +502,7 @@ XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp,
   }
 
   XPCWrappedNativeScope *parentScope =
-    XPCWrappedNativeScope::FindInJSObjectScope(cx, parent, nsnull, rt);
+    XPCWrappedNativeScope::FindInJSObjectScope(ccx, parent);
 
 #ifdef DEBUG_mrbkap_off
   printf(""""Wrapping object at %p (%s) [%p]\n"""",
@@ -520,7 +513,11 @@ XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp,
   JSObject *outerObj = nsnull;
   WrappedNative2WrapperMap *map = parentScope->GetWrapperMap();
 
-  outerObj = map->Find(wrappedObj);
+  { // Scoped lock
+    XPCAutoLock al(rt->GetMapLock());
+    outerObj = map->Find(wrappedObj);
+  }
+
   if (outerObj) {
     NS_ASSERTION(STOBJ_GET_CLASS(outerObj) == &sXPC_XOW_JSClass.base,
                               """"What crazy object are we getting here?"""");
@@ -550,7 +547,10 @@ XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp,
 
   *vp = OBJECT_TO_JSVAL(outerObj);
 
-  map->Add(wn->GetScope()->GetWrapperMap(), wrappedObj, outerObj);
+  { // Scoped lock
+    XPCAutoLock al(rt->GetMapLock());
+    map->Add(wn->GetScope()->GetWrapperMap(), wrappedObj, outerObj);
+  }
 
   return JS_TRUE;
 }
diff --git a/js/src/xpconnect/src/nsXPConnect.cpp b/js/src/xpconnect/src/nsXPConnect.cpp
index c4bb663..9597429 100644
--- a/js/src/xpconnect/src/nsXPConnect.cpp
+++ b/js/src/xpconnect/src/nsXPConnect.cpp
@@ -44,7 +44,6 @@
 
 #include """"xpcprivate.h""""
 #include """"XPCNativeWrapper.h""""
-#include """"XPCWrapper.h""""
 #include """"nsBaseHashtable.h""""
 #include """"nsHashKeys.h""""
 #include """"jsatom.h""""
@@ -2305,71 +2304,6 @@ nsXPConnect::DefineDOMQuickStubs(JSContext * cx,
                                 interfaceCount, interfaceArray);
 }
 
-NS_IMETHODIMP
-nsXPConnect::GetWrapperForObject(JSContext* aJSContext,
-                                 JSObject* aObject,
-                                 JSObject* aScope,
-                                 nsIPrincipal* aPrincipal,
-                                 PRUint32 aFilenameFlags,
-                                 jsval* _retval)
-{
-    NS_ASSERTION(aFilenameFlags != JSFILENAME_NULL, """"Null filename!"""");
-    NS_ASSERTION(XPCPerThreadData::IsMainThread(aJSContext),
-                 """"Must only be called from the main thread as these wrappers """"
-                 """"are not threadsafe!"""");
-
-    JSAutoRequest ar(aJSContext);
-
-    XPCWrappedNative *wrapper =
-        XPCWrappedNative::GetWrappedNativeOfJSObject(aJSContext, aObject);
-    if(!wrapper)
-    {
-        // Couldn't get the wrapped native (maybe a prototype?) so just return
-        // the original object.
-        *_retval = OBJECT_TO_JSVAL(aObject);
-        return NS_OK;
-    }
-
-    XPCWrappedNativeScope *xpcscope =
-        XPCWrappedNativeScope::FindInJSObjectScope(aJSContext, aScope);
-    if(!xpcscope)
-        return NS_ERROR_FAILURE;
-
-    if(STOBJ_IS_SYSTEM(aObject) ||
-       (wrapper->GetScope() == xpcscope &&
-        !XPC_XOW_ClassNeedsXOW(STOBJ_GET_CLASS(aObject)->name)))
-    {
-        *_retval = OBJECT_TO_JSVAL(aObject);
-        return NS_OK;
-    }
-
-    JSObject* wrappedObj = nsnull;
-
-    if(aFilenameFlags & JSFILENAME_PROTECTED)
-    {
-        wrappedObj = XPCNativeWrapper::GetNewOrUsed(aJSContext, wrapper,
-                                                    aPrincipal);
-    }
-    else if(aFilenameFlags & JSFILENAME_SYSTEM)
-    {
-        jsval val = OBJECT_TO_JSVAL(aObject);
-        if(XPC_SJOW_Construct(aJSContext, nsnull, 1, &val, &val))
-            wrappedObj = JSVAL_TO_OBJECT(val);
-    }
-    else
-    {
-        jsval val = OBJECT_TO_JSVAL(aObject);
-        if(XPC_XOW_WrapObject(aJSContext, aScope, &val, wrapper))
-            wrappedObj = JSVAL_TO_OBJECT(val);
-    }
-
-    if(!wrappedObj)
-        return NS_ERROR_FAILURE;
-
-    *_retval = OBJECT_TO_JSVAL(wrappedObj);
-    return NS_OK;
-}
-
 /* attribute JSRuntime runtime; */
 NS_IMETHODIMP
 nsXPConnect::GetRuntime(JSRuntime **runtime)
diff --git a/js/src/xpconnect/src/xpccallcontext.cpp b/js/src/xpconnect/src/xpccallcontext.cpp
index aee3de8..86c572b 100644
--- a/js/src/xpconnect/src/xpccallcontext.cpp
+++ b/js/src/xpconnect/src/xpccallcontext.cpp
@@ -75,6 +75,8 @@ XPCCallContext::XPCCallContext(XPCContext::LangType callerLanguage,
     if(!mXPC)
         return;
 
+    NS_ADDREF(mXPC);
+
     mThreadData = XPCPerThreadData::GetData(mJSContext);
 
     if(!mThreadData)
@@ -128,11 +130,6 @@ XPCCallContext::XPCCallContext(XPCContext::LangType callerLanguage,
     // hook into call context chain for our thread
     mPrevCallContext = mThreadData->SetCallContext(this);
 
-    // We only need to addref xpconnect once so only do it if this is the first
-    // context in the chain.
-    if(!mPrevCallContext)
-        NS_ADDREF(mXPC);
-
     mState = HAVE_CONTEXT;
 
     if(!obj)
@@ -297,8 +294,6 @@ XPCCallContext::~XPCCallContext()
 {
     // do cleanup...
 
-    PRBool shouldReleaseXPC = PR_FALSE;
-
     if(mXPCContext)
     {
         mXPCContext->SetCallingLangType(mPrevCallerLanguage);
@@ -309,8 +304,6 @@ XPCCallContext::~XPCCallContext()
 #else
         (void) mThreadData->SetCallContext(mPrevCallContext);
 #endif
-
-        shouldReleaseXPC = mPrevCallContext == nsnull;
     }
 
     if(mContextPopRequired)
@@ -370,8 +363,7 @@ XPCCallContext::~XPCCallContext()
     }
 #endif
 
-    if(shouldReleaseXPC && mXPC)
-        NS_RELEASE(mXPC);
+    NS_IF_RELEASE(mXPC);
 }
 
 XPCReadableJSStringWrapper *
diff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h
index 49f47f8..bcac67e 100644
--- a/js/src/xpconnect/src/xpcprivate.h
+++ b/js/src/xpconnect/src/xpcprivate.h
@@ -1253,17 +1253,8 @@ public:
     void RemoveWrappedNativeProtos();
 
     static XPCWrappedNativeScope*
-    FindInJSObjectScope(JSContext* cx, JSObject* obj,
-                        JSBool OKIfNotInitialized = JS_FALSE,
-                        XPCJSRuntime* runtime = nsnull);
-
-    static XPCWrappedNativeScope*
     FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
-                        JSBool OKIfNotInitialized = JS_FALSE)
-    {
-        return FindInJSObjectScope(ccx, obj, OKIfNotInitialized,
-                                   ccx.GetRuntime());
-    }
+                        JSBool OKIfNotInitialized = JS_FALSE);
 
     static void
     SystemIsBeingShutDown(JSContext* cx);
@@ -1337,10 +1328,7 @@ private:
     XPCJSRuntime*                    mRuntime;
     Native2WrappedNativeMap*         mWrappedNativeMap;
     ClassInfo2WrappedNativeProtoMap* mWrappedNativeProtoMap;
-
-    // This map should *never* be accessed from a non-main thread!
     WrappedNative2WrapperMap*        mWrapperMap;
-
     nsXPCComponents*                 mComponents;
     XPCWrappedNativeScope*           mNext;
     // The JS global object for this scope.  If non-null, this will be the
@@ -4082,8 +4070,7 @@ XPC_SJOW_AttachNewConstructorObject(XPCCallContext &ccx,
                                     JSObject *aGlobalObject);
 
 JSBool
-XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp,
-                   XPCWrappedNative *wn = nsnull);
+XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp);
 
 #ifdef XPC_IDISPATCH_SUPPORT
 // IDispatch specific classes
diff --git a/js/src/xpconnect/src/xpcwrappednativejsops.cpp b/js/src/xpconnect/src/xpcwrappednativejsops.cpp
index 29785f5..b5c9e2a 100644
--- a/js/src/xpconnect/src/xpcwrappednativejsops.cpp
+++ b/js/src/xpconnect/src/xpcwrappednativejsops.cpp
@@ -43,7 +43,6 @@
 
 #include """"xpcprivate.h""""
 #include """"XPCNativeWrapper.h""""
-#include """"XPCWrapper.h""""
 
 /***************************************************************************/
 
@@ -1276,110 +1275,6 @@ XPC_WN_JSOp_Clear(JSContext *cx, JSObject *obj)
     js_ObjectOps.clear(cx, obj);
 }
 
-namespace {
-
-NS_STACK_CLASS class AutoPopJSContext
-{
-public:
-  AutoPopJSContext(XPCJSContextStack *stack)
-  : mCx(nsnull), mStack(stack)
-  {
-      NS_ASSERTION(stack, """"Null stack!"""");
-  }
-
-  ~AutoPopJSContext()
-  {
-      if(mCx)
-          mStack->Pop(nsnull);
-  }
-
-  void PushIfNotTop(JSContext *cx)
-  {
-      NS_ASSERTION(cx, """"Null context!"""");
-      NS_ASSERTION(!mCx, """"This class is only meant to be used once!"""");
-
-      JSContext *cxTop = nsnull;
-      mStack->Peek(&cxTop);
-
-      if(cxTop != cx && NS_SUCCEEDED(mStack->Push(cx)))
-          mCx = cx;
-  }
-
-private:
-  JSContext *mCx;
-  XPCJSContextStack *mStack;
-};
-
-} // namespace
-
-static JSObject*
-XPC_WN_JSOp_ThisObject(JSContext *cx, JSObject *obj)
-{
-    // None of the wrappers we could potentially hand out are threadsafe so
-    // just hand out the given object.
-    if(!XPCPerThreadData::IsMainThread(cx))
-        return obj;
-
-    JSObject *scope = JS_GetScopeChain(cx);
-    if(!scope)
-    {
-        XPCThrower::Throw(NS_ERROR_FAILURE, cx);
-        return nsnull;
-    }
-
-    scope = JS_GetGlobalForObject(cx, scope);
-
-    XPCPerThreadData *threadData = XPCPerThreadData::GetData(cx);
-    if(!threadData)
-    {
-        XPCThrower::Throw(NS_ERROR_FAILURE, cx);
-        return nsnull;
-    }
-
-    AutoPopJSContext popper(threadData->GetJSContextStack());
-    popper.PushIfNotTop(cx);
-
-    nsIScriptSecurityManager* secMan = XPCWrapper::GetSecurityManager();
-    if(!secMan)
-    {
-        XPCThrower::Throw(NS_ERROR_FAILURE, cx);
-        return nsnull;
-    }
-
-    JSStackFrame *fp;
-    nsIPrincipal *principal = secMan->GetCxSubjectPrincipalAndFrame(cx, &fp);
-
-    jsval retval = OBJECT_TO_JSVAL(obj);
-    JSAutoTempValueRooter atvr(cx, retval);
-
-    if(principal && fp)
-    {
-        JSScript* script = JS_GetFrameScript(cx, fp);
-
-        PRUint32 flags = script ? JS_GetScriptFilenameFlags(script) : 0;
-        NS_ASSERTION(flags != JSFILENAME_NULL, """"Null filename!"""");
-
-        nsXPConnect *xpc = nsXPConnect::GetXPConnect();
-        if(!xpc)
-        {
-            XPCThrower::Throw(NS_ERROR_FAILURE, cx);
-            return nsnull;
-        }
-
-        jsval val = JSVAL_VOID;
-        
-        nsresult rv = xpc->GetWrapperForObject(cx, obj, scope, principal, flags,
-                                               &retval);
-        if(NS_FAILED(rv))
-        {
-            XPCThrower::Throw(rv, cx);
-            return nsnull;
-        }
-    }
-
-    return JSVAL_TO_OBJECT(retval);
-}
-
 JSObjectOps *
 XPC_WN_GetObjectOpsNoCall(JSContext *cx, JSClass *clazz)
 {
@@ -1398,15 +1293,14 @@ JSBool xpc_InitWrappedNativeJSOps()
     {
         memcpy(&XPC_WN_NoCall_JSOps, &js_ObjectOps, sizeof(JSObjectOps));
         XPC_WN_NoCall_JSOps.enumerate = XPC_WN_JSOp_Enumerate;
-        XPC_WN_NoCall_JSOps.call = nsnull;
-        XPC_WN_NoCall_JSOps.construct = nsnull;
-        XPC_WN_NoCall_JSOps.clear = XPC_WN_JSOp_Clear;
-        XPC_WN_NoCall_JSOps.thisObject = XPC_WN_JSOp_ThisObject;
 
         memcpy(&XPC_WN_WithCall_JSOps, &js_ObjectOps, sizeof(JSObjectOps));
         XPC_WN_WithCall_JSOps.enumerate = XPC_WN_JSOp_Enumerate;
         XPC_WN_WithCall_JSOps.clear = XPC_WN_JSOp_Clear;
-        XPC_WN_WithCall_JSOps.thisObject = XPC_WN_JSOp_ThisObject;
+
+        XPC_WN_NoCall_JSOps.call = nsnull;
+        XPC_WN_NoCall_JSOps.construct = nsnull;
+        XPC_WN_NoCall_JSOps.clear = XPC_WN_JSOp_Clear;
     }
     return JS_TRUE;
 }
diff --git a/js/src/xpconnect/src/xpcwrappednativescope.cpp b/js/src/xpconnect/src/xpcwrappednativescope.cpp
index 005fdae..06494db 100644
--- a/js/src/xpconnect/src/xpcwrappednativescope.cpp
+++ b/js/src/xpconnect/src/xpcwrappednativescope.cpp
@@ -737,19 +737,18 @@ GetScopeOfObject(JSObject* obj)
 
 
 #ifdef DEBUG
-void DEBUG_CheckForComponentsInScope(JSContext* cx, JSObject* obj,
-                                     JSBool OKIfNotInitialized,
-                                     XPCJSRuntime* runtime)
+void DEBUG_CheckForComponentsInScope(XPCCallContext& ccx, JSObject* obj,
+                                     JSBool OKIfNotInitialized)
 {
     if(OKIfNotInitialized)
         return;
 
-    if(!(JS_GetOptions(cx) & JSOPTION_PRIVATE_IS_NSISUPPORTS))
+    if(!(JS_GetOptions(ccx) & JSOPTION_PRIVATE_IS_NSISUPPORTS))
         return;
 
-    const char* name = runtime->GetStringName(XPCJSRuntime::IDX_COMPONENTS);
+    const char* name = ccx.GetRuntime()->GetStringName(XPCJSRuntime::IDX_COMPONENTS);
     jsval prop;
-    if(JS_LookupProperty(cx, obj, name, &prop) && !JSVAL_IS_PRIMITIVE(prop))
+    if(JS_LookupProperty(ccx, obj, name, &prop) && !JSVAL_IS_PRIMITIVE(prop))
         return;
 
     // This is pretty much always bad. It usually means that native code is
@@ -765,15 +764,13 @@ void DEBUG_CheckForComponentsInScope(JSContext* cx, JSObject* obj,
 #endif
 }
 #else
-#define DEBUG_CheckForComponentsInScope(ccx, obj, OKIfNotInitialized, runtime) \
-    ((void)0)
+#define DEBUG_CheckForComponentsInScope(ccx, obj, OKIfNotInitialized) ((void)0)
 #endif
 
 // static
 XPCWrappedNativeScope*
-XPCWrappedNativeScope::FindInJSObjectScope(JSContext* cx, JSObject* obj,
-                                           JSBool OKIfNotInitialized,
-                                           XPCJSRuntime* runtime)
+XPCWrappedNativeScope::FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
+                                           JSBool OKIfNotInitialized)
 {
     XPCWrappedNativeScope* scope;
 
@@ -789,19 +786,13 @@ XPCWrappedNativeScope::FindInJSObjectScope(JSContext* cx, JSObject* obj,
 
     // Else we'll have to look up the parent chain to get the scope
 
-    obj = JS_GetGlobalForObject(cx, obj);
-
-    if(!runtime)
-    {
-        runtime = nsXPConnect::GetRuntimeInstance();
-        NS_ASSERTION(runtime, """"This should never be null!"""");
-    }
+    obj = JS_GetGlobalForObject(ccx, obj);
 
     // XXX We are assuming that the scope count is low enough that traversing
     // the linked list is more reasonable then doing a hashtable lookup.
     XPCWrappedNativeScope* found = nsnull;
     {   // scoped lock
-        XPCAutoLock lock(runtime->GetMapLock());
+        XPCAutoLock lock(ccx.GetRuntime()->GetMapLock());
 
         DEBUG_TrackScopeTraversal();
 
@@ -817,7 +808,7 @@ XPCWrappedNativeScope::FindInJSObjectScope(JSContext* cx, JSObject* obj,
 
     if(found) {
         // This cannot be called within the map lock!
-        DEBUG_CheckForComponentsInScope(cx, obj, OKIfNotInitialized, runtime);
+        DEBUG_CheckForComponentsInScope(ccx, obj, OKIfNotInitialized);
         return found;
     }
 
@@ -828,6 +819,7 @@ XPCWrappedNativeScope::FindInJSObjectScope(JSContext* cx, JSObject* obj,
     return nsnull;
 }
 
+
 /***************************************************************************/
 
 static JSDHashOperator"""
e4e9376fa8e80b2668736a1b41ae99994e2ddea6,49123,460882,Ben Turner,"Bug 460882. r+sr=mrbkap, a=blocking1.9.1
",1233964876,"""diff --git a/dom/src/base/nsDOMClassInfo.cpp b/dom/src/base/nsDOMClassInfo.cpp
index 890242b..4a87683 100644
--- a/dom/src/base/nsDOMClassInfo.cpp
+++ b/dom/src/base/nsDOMClassInfo.cpp
@@ -6665,48 +6665,19 @@ nsWindowSH::OuterObject(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
     // never be called when we have no outer. But just in case, return
     // null to prevent leaking an inner window to code in a different
     // window.
-
     *_retval = nsnull;
-
     return NS_ERROR_UNEXPECTED;
   }
 
-  // Return the outer window.
-
-  // FIXME bug 420372: Our window should always have a JS object here. It
-  // doesn't because of nsJSContext::FindXPCNativeWrapperClass.
-  nsresult rv;
-  if (win->IsChromeWindow()) {
-    // Chrome windows don't get XOW wrapping.
-    JSObject *outerObj = win->GetGlobalJSObject();
-    if (!outerObj) {
-      NS_ASSERTION(origWin->IsOuterWindow(), """"What window is this?"""");
-      *_retval = obj;
-    } else {
-      *_retval = outerObj;
-    }
-
-    rv = NS_OK;
-  } else {
-    JSObject *winObj = win->GetGlobalJSObject();
-    if (!winObj) {
-      NS_ASSERTION(origWin->IsOuterWindow(), """"What window is this?"""");
-      *_retval = obj;
-      rv = NS_OK;
-    } else {
-      JSObject *scope = JS_GetScopeChain(cx);
-      if (!scope) {
-        *_retval = nsnull;
-        return NS_ERROR_FAILURE;
-      }
-      scope = ::JS_GetGlobalForObject(cx, scope);
-      jsval v;
-      rv = sXPConnect->GetXOWForObject(cx, scope, winObj, &v);
-      *_retval = NS_SUCCEEDED(rv) ? JSVAL_TO_OBJECT(v) : nsnull;
-    }
+  JSObject *winObj = win->GetGlobalJSObject();
+  if (!winObj) {
+    NS_ASSERTION(origWin->IsOuterWindow(), """"What window is this?"""");
+    *_retval = obj;
+    return NS_OK;
   }
 
-  return rv;
+  *_retval = winObj;
+  return NS_OK;
 }
 
 NS_IMETHODIMP
diff --git a/js/src/jsdbgapi.cpp b/js/src/jsdbgapi.cpp
index 8766517..02f230f 100644
--- a/js/src/jsdbgapi.cpp
+++ b/js/src/jsdbgapi.cpp
@@ -653,7 +653,7 @@ js_watch_set(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
                      ((sprop->attrs & JSPROP_SETTER)
                       ? js_InternalCall(cx, obj, OBJECT_TO_JSVAL(wp->setter),
                                         1, vp, vp)
-                      : wp->setter(cx, OBJ_THIS_OBJECT(cx, obj), userid, vp));
+                      : wp->setter(cx, obj, userid, vp));
                 if (injectFrame) {
                     /* Evil code can cause us to have an arguments object. */
                     if (frame.callobj)
diff --git a/js/src/jsinterp.cpp b/js/src/jsinterp.cpp
index 4c1d4de..3dd31fe 100644
--- a/js/src/jsinterp.cpp
+++ b/js/src/jsinterp.cpp
@@ -855,16 +855,18 @@ ComputeThis(JSContext *cx, JSBool lazy, jsval *argv)
             return js_ComputeGlobalThis(cx, lazy, argv);
         }
 
+        OBJ_TO_OUTER_OBJECT(cx, thisp);
+        if (!thisp)
+            return NULL;
+        argv[-1] = OBJECT_TO_JSVAL(thisp);
+
         if (thisp->map->ops->thisObject) {
             /* Some objects (e.g., With) delegate 'this' to another object. */
             thisp = thisp->map->ops->thisObject(cx, thisp);
             if (!thisp)
                 return NULL;
-        }
-        OBJ_TO_OUTER_OBJECT(cx, thisp);
-        if (!thisp)
-            return NULL;
-        argv[-1] = OBJECT_TO_JSVAL(thisp);
+            argv[-1] = OBJECT_TO_JSVAL(thisp);
+       }
     }
     return thisp;
 }
diff --git a/js/src/jsscope.h b/js/src/jsscope.h
index b7d8455..69f1d3b 100644
--- a/js/src/jsscope.h
+++ b/js/src/jsscope.h
@@ -336,7 +336,7 @@ struct JSScopeProperty {
      ? js_InternalGetOrSet(cx, obj, (sprop)->id,                              \
                            OBJECT_TO_JSVAL((sprop)->getter), JSACC_READ,      \
                            0, 0, vp)                                          \
-     : (sprop)->getter(cx, OBJ_THIS_OBJECT(cx,obj), SPROP_USERID(sprop), vp))
+     : (sprop)->getter(cx, obj, SPROP_USERID(sprop), vp))
 
 /*
  * NB: SPROP_SET must not be called if (SPROP_HAS_STUB_SETTER(sprop) &&
@@ -350,7 +350,7 @@ struct JSScopeProperty {
      : ((sprop)->attrs & JSPROP_GETTER)                                       \
      ? (JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,                    \
                              JSMSG_GETTER_ONLY, NULL), JS_FALSE)              \
-     : (sprop)->setter(cx, OBJ_THIS_OBJECT(cx,obj), SPROP_USERID(sprop), vp))
+     : (sprop)->setter(cx, obj, SPROP_USERID(sprop), vp))
 
 /* Macro for common expression to test for shared permanent attributes. */
 #define SPROP_IS_SHARED_PERMANENT(sprop)                                      \
diff --git a/js/src/xpconnect/idl/nsIXPConnect.idl b/js/src/xpconnect/idl/nsIXPConnect.idl
index 146e0f8..fd280ce 100644
--- a/js/src/xpconnect/idl/nsIXPConnect.idl
+++ b/js/src/xpconnect/idl/nsIXPConnect.idl
@@ -405,7 +405,7 @@ interface nsIXPCFunctionThisTranslator : nsISupports
     { 0xbd, 0xd6, 0x0, 0x0, 0x64, 0x65, 0x73, 0x74 } }
 %}
 
-[uuid(f8bf005e-3700-411c-ba0c-e018075f22a4)]
+[uuid(b2ddc328-194b-45d6-95c6-52e487438096)]
 interface nsIXPConnect : nsISupports
 {
 %{ C++
@@ -785,4 +785,28 @@ interface nsIXPConnect : nsISupports
         in PRUint32 flags,
         in PRUint32 interfaceCount,
         [array, size_is(interfaceCount)] in nsIIDPtr interfaceArray);
+
+    /**
+     * Returns a XPCNativeWrapper, XPCSafeJSObjectWrapper, or
+     * XPCCrossOriginWrapper for the given object based on the principal, scope,
+     * and filename flags that are passed in.
+     *
+     * @param aJSContext
+     *     A JSContext.
+     * @param aObject
+     *     The object to wrap.
+     * @param aScope
+     *     The scope to be used in the event that we create a
+     *     XPCCrossOriginWrapper. Can be null.
+     * @param aPrincipal
+     *     The principal that should be used for the wrapper.
+     * @param aFilenameFlags
+     *     The filename flags from the script that will use this wrapper.
+     */
+    [noscript] JSVal getWrapperForObject(
+        in JSContextPtr aJSContext,
+        in JSObjectPtr aObject,
+        in JSObjectPtr aScope,
+        in nsIPrincipal aPrincipal,
+        in unsigned long aFilenameFlags);
 };
diff --git a/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp b/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp
index 0557125..c436806 100644
--- a/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp
+++ b/js/src/xpconnect/src/XPCCrossOriginWrapper.cpp
@@ -472,24 +472,31 @@ XPC_XOW_RewrapIfNeeded(JSContext *cx, JSObject *outerObj, jsval *vp)
 }
 
 JSBool
-XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp)
+XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp,
+                   XPCWrappedNative* wn)
 {
-  // Our argument should be a wrapped native object.
+  NS_ASSERTION(XPCPerThreadData::IsMainThread(cx),
+               """"Can't wrap object on non-main thread!"""");
+
+  // Our argument should be a wrapped native object, but the caller may have
+  // passed it in as an optimization.
   JSObject *wrappedObj;
-  XPCWrappedNative *wn;
   if (!JSVAL_IS_OBJECT(*vp) ||
       !(wrappedObj = JSVAL_TO_OBJECT(*vp)) ||
-      STOBJ_GET_CLASS(wrappedObj) == &sXPC_XOW_JSClass.base ||
+      STOBJ_GET_CLASS(wrappedObj) == &sXPC_XOW_JSClass.base) {
+    return JS_TRUE;
+  }
+
+  if (!wn &&
       !(wn = XPCWrappedNative::GetWrappedNativeOfJSObject(cx, wrappedObj))) {
     return JS_TRUE;
   }
 
   XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
-  XPCCallContext ccx(NATIVE_CALLER, cx);
-  NS_ENSURE_TRUE(ccx.IsValid(), JS_FALSE);
 
   // The parent must be the inner global object for its scope.
   parent = JS_GetGlobalForObject(cx, parent);
+
   JSClass *clasp = STOBJ_GET_CLASS(parent);
   if (clasp->flags & JSCLASS_IS_EXTENDED) {
     JSExtendedClass *xclasp = reinterpret_cast<JSExtendedClass *>(clasp);
@@ -502,7 +509,7 @@ XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp)
   }
 
   XPCWrappedNativeScope *parentScope =
-    XPCWrappedNativeScope::FindInJSObjectScope(ccx, parent);
+    XPCWrappedNativeScope::FindInJSObjectScope(cx, parent, nsnull, rt);
 
 #ifdef DEBUG_mrbkap_off
   printf(""""Wrapping object at %p (%s) [%p]\n"""",
@@ -513,11 +520,7 @@ XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp)
   JSObject *outerObj = nsnull;
   WrappedNative2WrapperMap *map = parentScope->GetWrapperMap();
 
-  { // Scoped lock
-    XPCAutoLock al(rt->GetMapLock());
-    outerObj = map->Find(wrappedObj);
-  }
-
+  outerObj = map->Find(wrappedObj);
   if (outerObj) {
     NS_ASSERTION(STOBJ_GET_CLASS(outerObj) == &sXPC_XOW_JSClass.base,
                               """"What crazy object are we getting here?"""");
@@ -547,10 +550,7 @@ XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp)
 
   *vp = OBJECT_TO_JSVAL(outerObj);
 
-  { // Scoped lock
-    XPCAutoLock al(rt->GetMapLock());
-    map->Add(wn->GetScope()->GetWrapperMap(), wrappedObj, outerObj);
-  }
+  map->Add(wn->GetScope()->GetWrapperMap(), wrappedObj, outerObj);
 
   return JS_TRUE;
 }
diff --git a/js/src/xpconnect/src/nsXPConnect.cpp b/js/src/xpconnect/src/nsXPConnect.cpp
index 9597429..c4bb663 100644
--- a/js/src/xpconnect/src/nsXPConnect.cpp
+++ b/js/src/xpconnect/src/nsXPConnect.cpp
@@ -44,6 +44,7 @@
 
 #include """"xpcprivate.h""""
 #include """"XPCNativeWrapper.h""""
+#include """"XPCWrapper.h""""
 #include """"nsBaseHashtable.h""""
 #include """"nsHashKeys.h""""
 #include """"jsatom.h""""
@@ -2304,6 +2305,71 @@ nsXPConnect::DefineDOMQuickStubs(JSContext * cx,
                                 interfaceCount, interfaceArray);
 }
 
+NS_IMETHODIMP
+nsXPConnect::GetWrapperForObject(JSContext* aJSContext,
+                                 JSObject* aObject,
+                                 JSObject* aScope,
+                                 nsIPrincipal* aPrincipal,
+                                 PRUint32 aFilenameFlags,
+                                 jsval* _retval)
+{
+    NS_ASSERTION(aFilenameFlags != JSFILENAME_NULL, """"Null filename!"""");
+    NS_ASSERTION(XPCPerThreadData::IsMainThread(aJSContext),
+                 """"Must only be called from the main thread as these wrappers """"
+                 """"are not threadsafe!"""");
+
+    JSAutoRequest ar(aJSContext);
+
+    XPCWrappedNative *wrapper =
+        XPCWrappedNative::GetWrappedNativeOfJSObject(aJSContext, aObject);
+    if(!wrapper)
+    {
+        // Couldn't get the wrapped native (maybe a prototype?) so just return
+        // the original object.
+        *_retval = OBJECT_TO_JSVAL(aObject);
+        return NS_OK;
+    }
+
+    XPCWrappedNativeScope *xpcscope =
+        XPCWrappedNativeScope::FindInJSObjectScope(aJSContext, aScope);
+    if(!xpcscope)
+        return NS_ERROR_FAILURE;
+
+    if(STOBJ_IS_SYSTEM(aObject) ||
+       (wrapper->GetScope() == xpcscope &&
+        !XPC_XOW_ClassNeedsXOW(STOBJ_GET_CLASS(aObject)->name)))
+    {
+        *_retval = OBJECT_TO_JSVAL(aObject);
+        return NS_OK;
+    }
+
+    JSObject* wrappedObj = nsnull;
+
+    if(aFilenameFlags & JSFILENAME_PROTECTED)
+    {
+        wrappedObj = XPCNativeWrapper::GetNewOrUsed(aJSContext, wrapper,
+                                                    aPrincipal);
+    }
+    else if(aFilenameFlags & JSFILENAME_SYSTEM)
+    {
+        jsval val = OBJECT_TO_JSVAL(aObject);
+        if(XPC_SJOW_Construct(aJSContext, nsnull, 1, &val, &val))
+            wrappedObj = JSVAL_TO_OBJECT(val);
+    }
+    else
+    {
+        jsval val = OBJECT_TO_JSVAL(aObject);
+        if(XPC_XOW_WrapObject(aJSContext, aScope, &val, wrapper))
+            wrappedObj = JSVAL_TO_OBJECT(val);
+    }
+
+    if(!wrappedObj)
+        return NS_ERROR_FAILURE;
+
+    *_retval = OBJECT_TO_JSVAL(wrappedObj);
+    return NS_OK;
+}
+
 /* attribute JSRuntime runtime; */
 NS_IMETHODIMP
 nsXPConnect::GetRuntime(JSRuntime **runtime)
diff --git a/js/src/xpconnect/src/xpccallcontext.cpp b/js/src/xpconnect/src/xpccallcontext.cpp
index 86c572b..aee3de8 100644
--- a/js/src/xpconnect/src/xpccallcontext.cpp
+++ b/js/src/xpconnect/src/xpccallcontext.cpp
@@ -75,8 +75,6 @@ XPCCallContext::XPCCallContext(XPCContext::LangType callerLanguage,
     if(!mXPC)
         return;
 
-    NS_ADDREF(mXPC);
-
     mThreadData = XPCPerThreadData::GetData(mJSContext);
 
     if(!mThreadData)
@@ -130,6 +128,11 @@ XPCCallContext::XPCCallContext(XPCContext::LangType callerLanguage,
     // hook into call context chain for our thread
     mPrevCallContext = mThreadData->SetCallContext(this);
 
+    // We only need to addref xpconnect once so only do it if this is the first
+    // context in the chain.
+    if(!mPrevCallContext)
+        NS_ADDREF(mXPC);
+
     mState = HAVE_CONTEXT;
 
     if(!obj)
@@ -294,6 +297,8 @@ XPCCallContext::~XPCCallContext()
 {
     // do cleanup...
 
+    PRBool shouldReleaseXPC = PR_FALSE;
+
     if(mXPCContext)
     {
         mXPCContext->SetCallingLangType(mPrevCallerLanguage);
@@ -304,6 +309,8 @@ XPCCallContext::~XPCCallContext()
 #else
         (void) mThreadData->SetCallContext(mPrevCallContext);
 #endif
+
+        shouldReleaseXPC = mPrevCallContext == nsnull;
     }
 
     if(mContextPopRequired)
@@ -363,7 +370,8 @@ XPCCallContext::~XPCCallContext()
     }
 #endif
 
-    NS_IF_RELEASE(mXPC);
+    if(shouldReleaseXPC && mXPC)
+        NS_RELEASE(mXPC);
 }
 
 XPCReadableJSStringWrapper *
diff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h
index bcac67e..49f47f8 100644
--- a/js/src/xpconnect/src/xpcprivate.h
+++ b/js/src/xpconnect/src/xpcprivate.h
@@ -1253,8 +1253,17 @@ public:
     void RemoveWrappedNativeProtos();
 
     static XPCWrappedNativeScope*
+    FindInJSObjectScope(JSContext* cx, JSObject* obj,
+                        JSBool OKIfNotInitialized = JS_FALSE,
+                        XPCJSRuntime* runtime = nsnull);
+
+    static XPCWrappedNativeScope*
     FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
-                        JSBool OKIfNotInitialized = JS_FALSE);
+                        JSBool OKIfNotInitialized = JS_FALSE)
+    {
+        return FindInJSObjectScope(ccx, obj, OKIfNotInitialized,
+                                   ccx.GetRuntime());
+    }
 
     static void
     SystemIsBeingShutDown(JSContext* cx);
@@ -1328,7 +1337,10 @@ private:
     XPCJSRuntime*                    mRuntime;
     Native2WrappedNativeMap*         mWrappedNativeMap;
     ClassInfo2WrappedNativeProtoMap* mWrappedNativeProtoMap;
+
+    // This map should *never* be accessed from a non-main thread!
     WrappedNative2WrapperMap*        mWrapperMap;
+
     nsXPCComponents*                 mComponents;
     XPCWrappedNativeScope*           mNext;
     // The JS global object for this scope.  If non-null, this will be the
@@ -4070,7 +4082,8 @@ XPC_SJOW_AttachNewConstructorObject(XPCCallContext &ccx,
                                     JSObject *aGlobalObject);
 
 JSBool
-XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp);
+XPC_XOW_WrapObject(JSContext *cx, JSObject *parent, jsval *vp,
+                   XPCWrappedNative *wn = nsnull);
 
 #ifdef XPC_IDISPATCH_SUPPORT
 // IDispatch specific classes
diff --git a/js/src/xpconnect/src/xpcwrappednativejsops.cpp b/js/src/xpconnect/src/xpcwrappednativejsops.cpp
index b5c9e2a..29785f5 100644
--- a/js/src/xpconnect/src/xpcwrappednativejsops.cpp
+++ b/js/src/xpconnect/src/xpcwrappednativejsops.cpp
@@ -43,6 +43,7 @@
 
 #include """"xpcprivate.h""""
 #include """"XPCNativeWrapper.h""""
+#include """"XPCWrapper.h""""
 
 /***************************************************************************/
 
@@ -1275,6 +1276,110 @@ XPC_WN_JSOp_Clear(JSContext *cx, JSObject *obj)
     js_ObjectOps.clear(cx, obj);
 }
 
+namespace {
+
+NS_STACK_CLASS class AutoPopJSContext
+{
+public:
+  AutoPopJSContext(XPCJSContextStack *stack)
+  : mCx(nsnull), mStack(stack)
+  {
+      NS_ASSERTION(stack, """"Null stack!"""");
+  }
+
+  ~AutoPopJSContext()
+  {
+      if(mCx)
+          mStack->Pop(nsnull);
+  }
+
+  void PushIfNotTop(JSContext *cx)
+  {
+      NS_ASSERTION(cx, """"Null context!"""");
+      NS_ASSERTION(!mCx, """"This class is only meant to be used once!"""");
+
+      JSContext *cxTop = nsnull;
+      mStack->Peek(&cxTop);
+
+      if(cxTop != cx && NS_SUCCEEDED(mStack->Push(cx)))
+          mCx = cx;
+  }
+
+private:
+  JSContext *mCx;
+  XPCJSContextStack *mStack;
+};
+
+} // namespace
+
+static JSObject*
+XPC_WN_JSOp_ThisObject(JSContext *cx, JSObject *obj)
+{
+    // None of the wrappers we could potentially hand out are threadsafe so
+    // just hand out the given object.
+    if(!XPCPerThreadData::IsMainThread(cx))
+        return obj;
+
+    JSObject *scope = JS_GetScopeChain(cx);
+    if(!scope)
+    {
+        XPCThrower::Throw(NS_ERROR_FAILURE, cx);
+        return nsnull;
+    }
+
+    scope = JS_GetGlobalForObject(cx, scope);
+
+    XPCPerThreadData *threadData = XPCPerThreadData::GetData(cx);
+    if(!threadData)
+    {
+        XPCThrower::Throw(NS_ERROR_FAILURE, cx);
+        return nsnull;
+    }
+
+    AutoPopJSContext popper(threadData->GetJSContextStack());
+    popper.PushIfNotTop(cx);
+
+    nsIScriptSecurityManager* secMan = XPCWrapper::GetSecurityManager();
+    if(!secMan)
+    {
+        XPCThrower::Throw(NS_ERROR_FAILURE, cx);
+        return nsnull;
+    }
+
+    JSStackFrame *fp;
+    nsIPrincipal *principal = secMan->GetCxSubjectPrincipalAndFrame(cx, &fp);
+
+    jsval retval = OBJECT_TO_JSVAL(obj);
+    JSAutoTempValueRooter atvr(cx, retval);
+
+    if(principal && fp)
+    {
+        JSScript* script = JS_GetFrameScript(cx, fp);
+
+        PRUint32 flags = script ? JS_GetScriptFilenameFlags(script) : 0;
+        NS_ASSERTION(flags != JSFILENAME_NULL, """"Null filename!"""");
+
+        nsXPConnect *xpc = nsXPConnect::GetXPConnect();
+        if(!xpc)
+        {
+            XPCThrower::Throw(NS_ERROR_FAILURE, cx);
+            return nsnull;
+        }
+
+        jsval val = JSVAL_VOID;
+        
+        nsresult rv = xpc->GetWrapperForObject(cx, obj, scope, principal, flags,
+                                               &retval);
+        if(NS_FAILED(rv))
+        {
+            XPCThrower::Throw(rv, cx);
+            return nsnull;
+        }
+    }
+
+    return JSVAL_TO_OBJECT(retval);
+}
+
 JSObjectOps *
 XPC_WN_GetObjectOpsNoCall(JSContext *cx, JSClass *clazz)
 {
@@ -1293,14 +1398,15 @@ JSBool xpc_InitWrappedNativeJSOps()
     {
         memcpy(&XPC_WN_NoCall_JSOps, &js_ObjectOps, sizeof(JSObjectOps));
         XPC_WN_NoCall_JSOps.enumerate = XPC_WN_JSOp_Enumerate;
+        XPC_WN_NoCall_JSOps.call = nsnull;
+        XPC_WN_NoCall_JSOps.construct = nsnull;
+        XPC_WN_NoCall_JSOps.clear = XPC_WN_JSOp_Clear;
+        XPC_WN_NoCall_JSOps.thisObject = XPC_WN_JSOp_ThisObject;
 
         memcpy(&XPC_WN_WithCall_JSOps, &js_ObjectOps, sizeof(JSObjectOps));
         XPC_WN_WithCall_JSOps.enumerate = XPC_WN_JSOp_Enumerate;
         XPC_WN_WithCall_JSOps.clear = XPC_WN_JSOp_Clear;
-
-        XPC_WN_NoCall_JSOps.call = nsnull;
-        XPC_WN_NoCall_JSOps.construct = nsnull;
-        XPC_WN_NoCall_JSOps.clear = XPC_WN_JSOp_Clear;
+        XPC_WN_WithCall_JSOps.thisObject = XPC_WN_JSOp_ThisObject;
     }
     return JS_TRUE;
 }
diff --git a/js/src/xpconnect/src/xpcwrappednativescope.cpp b/js/src/xpconnect/src/xpcwrappednativescope.cpp
index 06494db..005fdae 100644
--- a/js/src/xpconnect/src/xpcwrappednativescope.cpp
+++ b/js/src/xpconnect/src/xpcwrappednativescope.cpp
@@ -737,18 +737,19 @@ GetScopeOfObject(JSObject* obj)
 
 
 #ifdef DEBUG
-void DEBUG_CheckForComponentsInScope(XPCCallContext& ccx, JSObject* obj,
-                                     JSBool OKIfNotInitialized)
+void DEBUG_CheckForComponentsInScope(JSContext* cx, JSObject* obj,
+                                     JSBool OKIfNotInitialized,
+                                     XPCJSRuntime* runtime)
 {
     if(OKIfNotInitialized)
         return;
 
-    if(!(JS_GetOptions(ccx) & JSOPTION_PRIVATE_IS_NSISUPPORTS))
+    if(!(JS_GetOptions(cx) & JSOPTION_PRIVATE_IS_NSISUPPORTS))
         return;
 
-    const char* name = ccx.GetRuntime()->GetStringName(XPCJSRuntime::IDX_COMPONENTS);
+    const char* name = runtime->GetStringName(XPCJSRuntime::IDX_COMPONENTS);
     jsval prop;
-    if(JS_LookupProperty(ccx, obj, name, &prop) && !JSVAL_IS_PRIMITIVE(prop))
+    if(JS_LookupProperty(cx, obj, name, &prop) && !JSVAL_IS_PRIMITIVE(prop))
         return;
 
     // This is pretty much always bad. It usually means that native code is
@@ -764,13 +765,15 @@ void DEBUG_CheckForComponentsInScope(XPCCallContext& ccx, JSObject* obj,
 #endif
 }
 #else
-#define DEBUG_CheckForComponentsInScope(ccx, obj, OKIfNotInitialized) ((void)0)
+#define DEBUG_CheckForComponentsInScope(ccx, obj, OKIfNotInitialized, runtime) \
+    ((void)0)
 #endif
 
 // static
 XPCWrappedNativeScope*
-XPCWrappedNativeScope::FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
-                                           JSBool OKIfNotInitialized)
+XPCWrappedNativeScope::FindInJSObjectScope(JSContext* cx, JSObject* obj,
+                                           JSBool OKIfNotInitialized,
+                                           XPCJSRuntime* runtime)
 {
     XPCWrappedNativeScope* scope;
 
@@ -786,13 +789,19 @@ XPCWrappedNativeScope::FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
 
     // Else we'll have to look up the parent chain to get the scope
 
-    obj = JS_GetGlobalForObject(ccx, obj);
+    obj = JS_GetGlobalForObject(cx, obj);
+
+    if(!runtime)
+    {
+        runtime = nsXPConnect::GetRuntimeInstance();
+        NS_ASSERTION(runtime, """"This should never be null!"""");
+    }
 
     // XXX We are assuming that the scope count is low enough that traversing
     // the linked list is more reasonable then doing a hashtable lookup.
     XPCWrappedNativeScope* found = nsnull;
     {   // scoped lock
-        XPCAutoLock lock(ccx.GetRuntime()->GetMapLock());
+        XPCAutoLock lock(runtime->GetMapLock());
 
         DEBUG_TrackScopeTraversal();
 
@@ -808,7 +817,7 @@ XPCWrappedNativeScope::FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
 
     if(found) {
         // This cannot be called within the map lock!
-        DEBUG_CheckForComponentsInScope(ccx, obj, OKIfNotInitialized);
+        DEBUG_CheckForComponentsInScope(cx, obj, OKIfNotInitialized, runtime);
         return found;
     }
 
@@ -819,7 +828,6 @@ XPCWrappedNativeScope::FindInJSObjectScope(XPCCallContext& ccx, JSObject* obj,
     return nsnull;
 }
 
-
 /***************************************************************************/
 
 static JSDHashOperator"""
ecda6b0378bd7b9d0a242c8bcab5c11469e2f098,49165,474456,Peter Van der Beken,"Fix for bug 474456. r/sr=bz.
",1233826975,"""diff --git a/content/base/src/nsGenericElement.cpp b/content/base/src/nsGenericElement.cpp
index bcbdc4b..471108e 100644
--- a/content/base/src/nsGenericElement.cpp
+++ b/content/base/src/nsGenericElement.cpp
@@ -2658,6 +2658,9 @@ nsGenericElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
   // Make sure to unbind this node before doing the kids
   nsIDocument *document =
     HasFlag(NODE_FORCE_XBL_BINDINGS) ? GetOwnerDoc() : GetCurrentDoc();
+
+  mParentPtrBits = aNullParent ? 0 : mParentPtrBits & ~PARENT_BIT_INDOCUMENT;
+
   if (document) {
     // Notify XBL- & nsIAnonymousContentCreator-generated
     // anonymous content that the document is changing.
@@ -2670,9 +2673,6 @@ nsGenericElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
     document->ClearBoxObjectFor(this);
   }
 
-  // Unset things in the reverse order from how we set them in BindToTree
-  mParentPtrBits = aNullParent ? 0 : mParentPtrBits & ~PARENT_BIT_INDOCUMENT;
-
   // Unset this since that's what the old code effectively did.
   UnsetFlags(NODE_FORCE_XBL_BINDINGS);
   """
0f59a10a1f2fbcad91bec72849f8498c9743eaec,49291,414540,Benjamin Smedberg,"Bug 414540 - RDFXMLDataSource should reject cross-domain redirects. Original patch by Neil Deakin, fixed up with better testing, r+sr=bz
",1233247550,"""diff --git a/rdf/base/src/Makefile.in b/rdf/base/src/Makefile.in
index c49b31c..db28ff5 100644
--- a/rdf/base/src/Makefile.in
+++ b/rdf/base/src/Makefile.in
@@ -49,6 +49,8 @@ LIBXUL_LIBRARY  = 1
 REQUIRES	= xpcom \
 		  string \
 		  rdfutil \
+		  js \
+		  caps \
 		  necko \
 		  content \
 		  htmlparser \
diff --git a/rdf/base/src/nsRDFXMLDataSource.cpp b/rdf/base/src/nsRDFXMLDataSource.cpp
index d269b91..974d838 100644
--- a/rdf/base/src/nsRDFXMLDataSource.cpp
+++ b/rdf/base/src/nsRDFXMLDataSource.cpp
@@ -123,6 +123,9 @@
 #include """"nsNameSpaceMap.h""""
 #include """"nsCRT.h""""
 #include """"nsCycleCollectionParticipant.h""""
+#include """"nsIScriptSecurityManager.h""""
+#include """"nsIChannelEventSink.h""""
+#include """"nsNetUtil.h""""
 
 #include """"rdfIDataSource.h""""
 
@@ -145,7 +148,9 @@ class RDFXMLDataSourceImpl : public nsIRDFDataSource,
                              public nsIRDFXMLSink,
                              public nsIRDFXMLSource,
                              public nsIStreamListener,
-                             public rdfIDataSource
+                             public rdfIDataSource,
+                             public nsIInterfaceRequestor,
+                             public nsIChannelEventSink
 {
 protected:
     enum LoadState {
@@ -318,6 +323,12 @@ public:
     // nsIStreamListener
     NS_DECL_NSISTREAMLISTENER
 
+    // nsIInterfaceRequestor
+    NS_DECL_NSIINTERFACEREQUESTOR
+
+    // nsIChannelEventSink
+    NS_DECL_NSICHANNELEVENTSINK
+
     // rdfIDataSource
     NS_IMETHOD VisitAllSubjects(rdfITripleVisitor *aVisitor) {
         nsresult rv;
@@ -481,9 +492,17 @@ NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(RDFXMLDataSourceImpl)
     NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
     NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
     NS_INTERFACE_MAP_ENTRY(rdfIDataSource)
+    NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
+    NS_INTERFACE_MAP_ENTRY(nsIChannelEventSink)
     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIRDFDataSource)
 NS_INTERFACE_MAP_END
 
+// nsIInterfaceRequestor
+NS_IMETHODIMP
+RDFXMLDataSourceImpl::GetInterface(const nsIID& aIID, void** aSink)
+{
+  return QueryInterface(aIID, aSink);
+}
 
 nsresult
 RDFXMLDataSourceImpl::BlockingParse(nsIURI* aURL, nsIStreamListener* aConsumer)
@@ -877,6 +896,39 @@ RDFXMLDataSourceImpl::SetReadOnly(PRBool aIsReadOnly)
 
 #include """"nsITimelineService.h""""
 
+// nsIChannelEventSink
+
+// This code is copied from nsSameOriginChecker::OnChannelRedirect. See
+// bug 475940 on providing this code in a shared location.
+NS_IMETHODIMP
+RDFXMLDataSourceImpl::OnChannelRedirect(nsIChannel *aOldChannel,
+                                        nsIChannel *aNewChannel,
+                                        PRUint32 aFlags)
+{
+  NS_PRECONDITION(aNewChannel, """"Redirecting to null channel?"""");
+
+  nsresult rv;
+  nsCOMPtr<nsIScriptSecurityManager> secMan =
+      do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIPrincipal> oldPrincipal;
+  secMan->GetChannelPrincipal(aOldChannel, getter_AddRefs(oldPrincipal));
+
+  nsCOMPtr<nsIURI> newURI;
+  aNewChannel->GetURI(getter_AddRefs(newURI));
+  nsCOMPtr<nsIURI> newOriginalURI;
+  aNewChannel->GetOriginalURI(getter_AddRefs(newOriginalURI));
+
+  NS_ENSURE_STATE(oldPrincipal && newURI && newOriginalURI);
+
+  rv = oldPrincipal->CheckMayLoad(newURI, PR_FALSE);
+  if (NS_SUCCEEDED(rv) && newOriginalURI != newURI) {
+    rv = oldPrincipal->CheckMayLoad(newOriginalURI, PR_FALSE);
+  }
+  return rv;
+}
+
 NS_IMETHODIMP
 RDFXMLDataSourceImpl::Refresh(PRBool aBlocking)
 {
@@ -925,7 +977,7 @@ RDFXMLDataSourceImpl::Refresh(PRBool aBlocking)
     }
     else {
         // Null LoadGroup ?
-        rv = NS_OpenURI(this, nsnull, mURL, nsnull);
+        rv = NS_OpenURI(this, nsnull, mURL, nsnull, nsnull, this);
         if (NS_FAILED(rv)) return rv;
 
         // So we don't try to issue two asynchronous loads at once.
diff --git a/rdf/tests/Makefile.in b/rdf/tests/Makefile.in
index 9f07f56..8c67e0e 100644
--- a/rdf/tests/Makefile.in
+++ b/rdf/tests/Makefile.in
@@ -40,9 +40,13 @@ topsrcdir	= @top_srcdir@
 srcdir		= @srcdir@
 VPATH		= @srcdir@
 
+MODULE = test_rdf
+
 include $(DEPTH)/config/autoconf.mk
 
 DIRS		= rdfcat rdfpoll triplescat
 
+XPCSHELL_TESTS = unit
+
 include $(topsrcdir)/config/rules.mk
 
diff --git a/rdf/tests/unit/sample.rdf b/rdf/tests/unit/sample.rdf
new file mode 100755
index 0000000..42de8cd
--- /dev/null
+++ b/rdf/tests/unit/sample.rdf
@@ -0,0 +1,9 @@
+<?xml version=""""1.0""""?>
+
+<rdf:RDF xmlns:rdf=""""http://www.w3.org/1999/02/22-rdf-syntax-ns#""""
+         xmlns:dc=""""http://purl.org/dc/elements/1.1/"""">
+
+  <rdf:Description about=""""urn:mozilla:sample-data""""
+    dc:title=""""Sample"""" />
+
+</rdf:RDF>
diff --git a/rdf/tests/unit/test_rdfredirect.js b/rdf/tests/unit/test_rdfredirect.js
new file mode 100644
index 0000000..b043497
--- /dev/null
+++ b/rdf/tests/unit/test_rdfredirect.js
@@ -0,0 +1,90 @@
+do_import_script(""""netwerk/test/httpserver/httpd.js"""");
+
+function getRDFService()
+{
+  return Components.classes[""""@mozilla.org/rdf/rdf-service;1""""].
+    getService(Components.interfaces.nsIRDFService);
+}
+
+var server1, server2;
+
+function run_test()
+{
+  var samplefile = do_get_file('rdf/tests/unit/sample.rdf');
+  
+  server1 = new nsHttpServer();
+  server1.registerPathHandler(""""/sample-xs.rdf"""", xsRedirect);
+  server1.registerPathHandler(""""/sample-local.rdf"""", localRedirect);
+  server1.registerFile('/sample.rdf', samplefile);
+  server1.start(4444);
+
+  server2 = new nsHttpServer();
+  server2.registerFile('/sample.rdf', samplefile);
+  server2.start(4445);
+
+  do_test_pending();
+
+  new rdfLoadObserver('http://localhost:4444/sample.rdf', true);
+  new rdfLoadObserver('http://localhost:4445/sample.rdf', true);
+  new rdfLoadObserver('http://localhost:4444/sample-xs.rdf', false);
+  new rdfLoadObserver('http://localhost:4444/sample-local.rdf', true);
+}
+
+var gPending = 0;
+
+function rdfLoadObserver(uri, shouldPass)
+{
+  this.shouldPass = shouldPass;
+  this.uri = uri;
+  
+  ++gPending;
+  
+  var rdfService = getRDFService();
+  this.ds = rdfService.GetDataSource(uri).
+    QueryInterface(Components.interfaces.nsIRDFXMLSink);
+  this.ds.addXMLSinkObserver(this);
+}
+
+rdfLoadObserver.prototype =
+{
+  onBeginLoad : function() { },
+  onInterrupt : function() { },
+  onResume : function() { },
+  onEndLoad : function() {
+    print(""""Testing results of loading """" + this.uri);
+    
+    var rdfs = getRDFService();
+    var res = rdfs.GetResource(""""urn:mozilla:sample-data"""");
+    var arc = rdfs.GetResource(""""http://purl.org/dc/elements/1.1/title"""");
+    var answer = this.ds.GetTarget(res, arc, true);
+    if (answer !== null) {
+      do_check_true(this.shouldPass);
+      do_check_true(answer instanceof Components.interfaces.nsIRDFLiteral);
+      do_check_eq(answer.Value, """"Sample"""");
+    }
+    else {
+      do_check_false(this.shouldPass);
+    }
+      
+    gPending -= 1;
+
+    if (gPending == 0) {
+      server1.stop();
+      server2.stop();
+      do_test_finished();
+    }
+  },
+  onError : function() { }
+}
+
+function xsRedirect(metadata, response)
+{
+  response.setStatusLine(metadata.httpVersion, 301, """"Moved Permanently"""");
+  response.setHeader(""""Location"""", """"http://localhost:4445/sample.rdf"""", false);
+}
+
+function localRedirect(metadata, response)
+{
+  response.setStatusLine(metadata.httpVersion, 301, """"Moved Permanently"""");
+  response.setHeader(""""Location"""", """"http://localhost:4444/sample.rdf"""", false);
+}"""
b6df91f361a029124f875575c1cce1642383a6ad,49319,458679,Bob Clary,"bug 458679 - record failures.
",1233160450,"""diff --git a/js/tests/public-failures.txt b/js/tests/public-failures.txt
index 8e5a8b8..d820a59d 100644
--- a/js/tests/public-failures.txt
+++ b/js/tests/public-failures.txt
@@ -622,9 +622,16 @@ TEST_ID=js1_7/extensions/regress-455982-01.js, TEST_BRANCH=1.9.2, TEST_REPO=.*,
 TEST_ID=js1_7/extensions/regress-455982-01.js, TEST_BRANCH=1.9.2, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=shell, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=intel32, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=CRASHED signal 5 SIGTRAP, TEST_DESCRIPTION=`.``*`Assertion failure: JS_ON_TRACE(cx), at `.``*`jsbuiltins.cpp:
 TEST_ID=js1_7/extensions/regress-455982-01.js, TEST_BRANCH=1.9.2, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=shell, TEST_OS=nt, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=-.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=ABNORMAL 3, TEST_DESCRIPTION=
 TEST_ID=js1_7/extensions/regress-455982-01.js, TEST_BRANCH=1.9.2, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=shell, TEST_OS=nt, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=ABNORMAL 3, TEST_DESCRIPTION=
-TEST_ID=js1_7/extensions/regress-458679.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=browser, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
-TEST_ID=js1_7/extensions/regress-458679.js, TEST_BRANCH=1.9.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=browser, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
-TEST_ID=js1_7/extensions/regress-458679.js, TEST_BRANCH=1.9.2, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=browser, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
+TEST_ID=js1_7/extensions/regress-458679.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=.*, TEST_OS=nt, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
+TEST_ID=js1_7/extensions/regress-458679.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=.*, TEST_OS=nt, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
+TEST_ID=js1_7/extensions/regress-458679.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=browser, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
+TEST_ID=js1_7/extensions/regress-458679.js, TEST_BRANCH=1.9.0, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=browser, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
+TEST_ID=js1_7/extensions/regress-458679.js, TEST_BRANCH=1.9.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=.*, TEST_OS=nt, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
+TEST_ID=js1_7/extensions/regress-458679.js, TEST_BRANCH=1.9.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=browser, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
+TEST_ID=js1_7/extensions/regress-458679.js, TEST_BRANCH=1.9.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=browser, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
+TEST_ID=js1_7/extensions/regress-458679.js, TEST_BRANCH=1.9.2, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=.*, TEST_OS=nt, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
+TEST_ID=js1_7/extensions/regress-458679.js, TEST_BRANCH=1.9.2, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=browser, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
+TEST_ID=js1_7/extensions/regress-458679.js, TEST_BRANCH=1.9.2, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=browser, TEST_OS=linux, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
 TEST_ID=js1_7/geniter/regress-349012-01.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=.*, TEST_TYPE=browser, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=NORMAL, TEST_DESCRIPTION=`.``*`/js1_7/geniter/regress-349012-01.js:`.``*`: yield from closing generator function gen() {try {try {yield 1;} finally {actual += """"Inner finally"""";yield 2;}} finally {actual += """",Outer finally"""";}}
 TEST_ID=js1_7/iterable/regress-341815.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=debug, TEST_TYPE=.*, TEST_OS=darwin, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION=
 TEST_ID=js1_7/iterable/regress-341815.js, TEST_BRANCH=1.8.1, TEST_REPO=.*, TEST_BUILDTYPE=opt, TEST_TYPE=.*, TEST_OS=.*, TEST_KERNEL=.*, TEST_PROCESSORTYPE=.*, TEST_MEMORY=.*, TEST_CPUSPEED=.*, TEST_TIMEZONE=.*, TEST_OPTIONS=.*, TEST_RESULT=FAILED, TEST_EXITSTATUS=TIMED OUT, TEST_DESCRIPTION="""
dd998086185e0f883220443f1120e284c05e3b2d,49935,473709,Blake Kaplan,"Bug 473709 - Protect |str| across the call to js_NewRegExp. r=jwalden
",1232070845,"""diff --git a/js/src/jscntxt.h b/js/src/jscntxt.h
index 676ca3f..9fa4b01 100644
--- a/js/src/jscntxt.h
+++ b/js/src/jscntxt.h
@@ -936,6 +936,10 @@ class JSAutoTempValueRooter
         : mContext(cx) {
         JS_PUSH_SINGLE_TEMP_ROOT(mContext, v, &mTvr);
     }
+    JSAutoTempValueRooter(JSContext *cx, JSString *str)
+        : mContext(cx) {
+        JS_PUSH_TEMP_ROOT_STRING(mContext, str, &mTvr);
+    }
 
     ~JSAutoTempValueRooter() {
         JS_POP_TEMP_ROOT(mContext, &mTvr);
diff --git a/js/src/jsregexp.cpp b/js/src/jsregexp.cpp
index c0f2e98..b28ba93 100644
--- a/js/src/jsregexp.cpp
+++ b/js/src/jsregexp.cpp
@@ -4897,15 +4897,14 @@ js_NewRegExpObject(JSContext *cx, JSTokenStream *ts,
     JSString *str;
     JSObject *obj;
     JSRegExp *re;
-    JSTempValueRooter tvr;
 
     str = js_NewStringCopyN(cx, chars, length);
     if (!str)
         return NULL;
+    JSAutoTempValueRooter tvr(cx, str);
     re = js_NewRegExp(cx, ts,  str, flags, JS_FALSE);
     if (!re)
         return NULL;
-    JS_PUSH_TEMP_ROOT_STRING(cx, str, &tvr);
     obj = js_NewObject(cx, &js_RegExpClass, NULL, NULL, 0);
     if (!obj || !JS_SetPrivate(cx, obj, re)) {
         js_DestroyRegExp(cx, re);
@@ -4913,7 +4912,6 @@ js_NewRegExpObject(JSContext *cx, JSTokenStream *ts,
     }
     if (obj && !js_SetLastIndex(cx, obj, 0))
         obj = NULL;
-    JS_POP_TEMP_ROOT(cx, &tvr);
     return obj;
 }
 """
b3705c15addfd067ae685465a48cec49d397fae6,50229,458679,Bob Clary,"bug 458679 - JavaScript Tests by Igor Bukanov, Jesse Ruderman and Gary Kwong.
",1231946177,"""diff --git a/js/tests/e4x/Regress/regress-458679-01.js b/js/tests/e4x/Regress/regress-458679-01.js
new file mode 100755
index 0000000..695ff53
--- /dev/null
+++ b/js/tests/e4x/Regress/regress-458679-01.js
@@ -0,0 +1,64 @@
+/* -*- Mode: java; tab-width:8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is JavaScript Engine testing utilities.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Igor Bukanov
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+gTestfile = 'regress-458679-01.js';
+
+var summary = 'GetXMLEntity should not assume FastAppendChar is infallible';
+var BUGNUMBER = 458679;
+var actual = '';
+var expect = '';
+
+printBugNumber(BUGNUMBER);
+START(summary);
+
+try
+{
+    var x = """"<"""";
+
+    while (x.length < 12000000)
+        x += x;
+
+    <e4x>{x}</e4x>;
+}
+catch(ex)
+{
+}
+
+TEST(1, expect, actual);
+
+END();
diff --git a/js/tests/e4x/Regress/regress-458679-02.js b/js/tests/e4x/Regress/regress-458679-02.js
new file mode 100755
index 0000000..f947cfc
--- /dev/null
+++ b/js/tests/e4x/Regress/regress-458679-02.js
@@ -0,0 +1,76 @@
+/* -*- Mode: java; tab-width:8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is JavaScript Engine testing utilities.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Jesse Ruderman
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+gTestfile = 'regress-458679-02.js';
+
+var summary = 'GetXMLEntity should not assume FastAppendChar is infallible';
+var BUGNUMBER = 458679;
+var actual = '';
+var expect = '';
+
+printBugNumber(BUGNUMBER);
+START(summary);
+
+function stringOfLength(n)
+{
+    if (n == 0) {
+        return """""""";
+    } else if (n == 1) {
+        return """"<"""";
+    } else {
+        var r = n % 2;
+        var d = (n - r) / 2;
+        var y = stringOfLength(d);
+        return y + y + stringOfLength(r);
+    }    
+}
+
+try
+{
+
+    void stringOfLength(4435455);
+    x = stringOfLength(14435455);
+    <xxx>{x}</xxx>;
+}
+catch(ex)
+{
+}
+
+TEST(1, expect, actual);
+
+END();
diff --git a/js/tests/js1_7/extensions/regress-458679.js b/js/tests/js1_7/extensions/regress-458679.js
new file mode 100755
index 0000000..3e86bd2
--- /dev/null
+++ b/js/tests/js1_7/extensions/regress-458679.js
@@ -0,0 +1,85 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is JavaScript Engine testing utilities.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Gary Kwong
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var gTestfile = 'regress-458679.js';
+//-----------------------------------------------------------------------------
+var BUGNUMBER = 458679;
+var summary = 'Do not assert: nbytes != 0';
+var actual = '';
+var expect = '';
+
+printBugNumber(BUGNUMBER);
+printStatus (summary);
+
+function f()
+{
+  for (var i = 1; i < dps.length; ++i) {
+    var a = """""""";
+    var b = """""""";
+    var c = """""""";
+  }
+}
+
+function stringOfLength(n)
+{
+  if (n == 0) {
+    return """""""";
+  } else if (n == 1) {
+    return """"\"""""""";
+  } else {
+    var r = n % 2;
+    var d = (n - r) / 2;
+    var y = stringOfLength(d);
+    return y + y + stringOfLength(r);
+  }    
+}
+
+try
+{
+  this.__defineGetter__('x', this.toSource);
+  while (x.length < 12000000) { 
+    let q = x;
+    s = q + q; 
+  }
+  print(x.length);
+  <e4x>{x}</e4x>;
+}
+catch(ex)
+{
+}
+ 
+reportCompare(expect, actual, summary);"""
60c2c15563e4eb62680c1ebaebfb8e04c7705980,50246,453736,Boris Zbarsky,"Bug 453736.  Make <svg:script> more like other scripts and fix up a few other minor issues.  r=roc, r+sr=sicking
",1231937358,"""diff --git a/content/base/src/nsScriptElement.cpp b/content/base/src/nsScriptElement.cpp
index 83a885e..dd489e4 100755
--- a/content/base/src/nsScriptElement.cpp
+++ b/content/base/src/nsScriptElement.cpp
@@ -177,8 +177,13 @@ nsScriptElement::MaybeProcessScript()
                """"You forgot to add self as observer"""");
 
   if (mIsEvaluated || !mDoneAddingChildren || !cont->IsInDoc() ||
-      mMalformed || InNonScriptingContainer(cont) ||
-      !HasScriptContent()) {
+      mMalformed || !HasScriptContent()) {
+    return NS_OK;
+  }
+
+  if (InNonScriptingContainer(cont)) {
+    // Make sure to flag ourselves as evaluated
+    mIsEvaluated = PR_TRUE;
     return NS_OK;
   }
 
diff --git a/content/base/test/Makefile.in b/content/base/test/Makefile.in
index 792e8cc..3eddcee 100644
--- a/content/base/test/Makefile.in
+++ b/content/base/test/Makefile.in
@@ -240,6 +240,7 @@ _TEST_FILES = 	test_bug5141.html \
 		test_bug368972.html \
 		test_bug448993.html \
 		test_bug450160.html \
+		test_bug453736.html \
 		test_bug454326.html \
 		test_bug457746.html \
 		bug457746.sjs \
diff --git a/content/base/test/test_bug453736.html b/content/base/test/test_bug453736.html
new file mode 100644
index 0000000..4b3f794
--- /dev/null
+++ b/content/base/test/test_bug453736.html
@@ -0,0 +1,97 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=453736
+-->
+<head>
+  <title>Test for Bug 453736</title>
+  <script type=""""application/javascript"""" src=""""/MochiKit/MochiKit.js""""></script>
+  <script type=""""application/javascript"""" src=""""/tests/SimpleTest/SimpleTest.js""""></script>
+  <link rel=""""stylesheet"""" type=""""text/css"""" href=""""/tests/SimpleTest/test.css""""/>
+</head>
+<body>
+<a target=""""_blank"""" href=""""https://bugzilla.mozilla.org/show_bug.cgi?id=453736"""">Mozilla Bug 453736</a>
+<p id=""""display""""></p>
+<div id=""""content"""" style=""""display: none"""">
+
+</div>
+<pre id=""""test"""">
+<script type=""""application/javascript"""">
+
+/** Test for Bug 453736 **/
+SimpleTest.waitForExplicitFinish();
+addLoadEvent(function() {
+  const scriptCreationFuncs = [
+    function() { return document.createElement(""""script""""); },
+    function() { return document.createElementNS(""""http://www.w3.org/2000/svg"""", """"script""""); }
+  ];
+
+  const noScriptContainers = [""""iframe"""", """"noframes"""", """"noembed""""];
+  for (var i = 0; i < noScriptContainers.length; ++i) {
+    for each (var func in scriptCreationFuncs) {
+      var cont = noScriptContainers[i];
+      var node = document.createElement(cont);
+      document.body.appendChild(node);
+      var s = func();
+      s.setAttribute(""""type"""", """"application/javascript"""");
+      s.appendChild(document.createTextNode('window[""""'+cont+'ScriptRan""""] = true'));
+
+      window[cont+""""ScriptRan""""] = false;
+      document.body.appendChild(s.cloneNode(true));
+      is(window[cont+""""ScriptRan""""], true,
+         """"Clone of non-inserted script created with """" + func +"""" should run"""");
+   
+      window[cont+""""ScriptRan""""] = false;
+      node.appendChild(s);
+      is(window[cont+""""ScriptRan""""], false,
+         """"Script created with """" + func +"""" shouldn't run when inserting in <""""+cont+"""">"""");
+
+      window[cont+""""ScriptRan""""] = false;
+      document.body.appendChild(s);
+      is(window[cont+""""ScriptRan""""], false,
+         """"Script created with """" + func + """" shouldn't run when moving out of <""""+cont+"""">"""");
+
+      window[cont+""""ScriptRan""""] = false;
+      document.body.appendChild(s.cloneNode(true));
+      is(window[cont+""""ScriptRan""""], false,
+         """"Clone of script inside <"""" + cont + """"> created with """" + func + """" shouldn't run"""");
+    }
+  }
+
+  const scriptContainers = [""""div""""];
+  for (var i = 0; i < scriptContainers.length; ++i) {
+    for each (var func in scriptCreationFuncs) {
+      var cont = scriptContainers[i];
+      var node = document.createElement(cont);
+      document.body.appendChild(node);
+      var s = func();
+      s.setAttribute(""""type"""", """"application/javascript"""");
+      s.appendChild(document.createTextNode('window[""""'+cont+'ScriptRan""""] = true'));
+
+      window[cont+""""ScriptRan""""] = false;
+      node.appendChild(s);
+      is(window[cont+""""ScriptRan""""], true,
+         """"Script created with """" + func +"""" should run when inserting in <""""+cont+"""">"""");
+
+      window[cont+""""ScriptRan""""] = false;
+      document.body.appendChild(s);
+      is(window[cont+""""ScriptRan""""], false,
+         """"Script created with """" + func + """" shouldn't run when moving out of <""""+cont+"""">"""");
+
+      window[cont+""""ScriptRan""""] = false;
+      document.body.appendChild(s.cloneNode(true));
+      is(window[cont+""""ScriptRan""""], false,
+         """"Clone of script inside <"""" + cont + """"> created with """" + func + """" shouldn't run"""");
+    }
+  }
+
+  SimpleTest.finish();
+});
+
+
+
+
+</script>
+</pre>
+</body>
+</html>
diff --git a/content/html/content/src/nsHTMLScriptElement.cpp b/content/html/content/src/nsHTMLScriptElement.cpp
index b350492..f3f9aff 100644
--- a/content/html/content/src/nsHTMLScriptElement.cpp
+++ b/content/html/content/src/nsHTMLScriptElement.cpp
@@ -432,9 +432,7 @@ nsHTMLScriptElement::Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const
   nsresult rv = CopyInnerTo(it);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  // The clone should be marked evaluated if we are.  It should also be marked
-  // evaluated if we're evaluating, to handle the case when this script node's
-  // script clones the node.
+  // The clone should be marked evaluated if we are.
   it->mIsEvaluated = mIsEvaluated;
   it->mLineNumber = mLineNumber;
   it->mMalformed = mMalformed;
diff --git a/content/svg/content/src/nsSVGScriptElement.cpp b/content/svg/content/src/nsSVGScriptElement.cpp
index 1b69ca5..4e1cf9c 100644
--- a/content/svg/content/src/nsSVGScriptElement.cpp
+++ b/content/svg/content/src/nsSVGScriptElement.cpp
@@ -101,10 +101,6 @@ protected:
   enum { HREF };
   nsSVGString mStringAttributes[1];
   static StringInfo sStringInfo[1];
-
-  PRUint32 mLineNumber;
-  PRPackedBool mIsEvaluated;
-  PRPackedBool mEvaluating;
 };
 
 nsSVGElement::StringInfo nsSVGScriptElement::sStringInfo[1] =
@@ -132,10 +128,7 @@ NS_INTERFACE_MAP_END_INHERITING(nsSVGScriptElementBase)
 // Implementation
 
 nsSVGScriptElement::nsSVGScriptElement(nsINodeInfo *aNodeInfo)
-  : nsSVGScriptElementBase(aNodeInfo),
-    mLineNumber(0),
-    mIsEvaluated(PR_FALSE),
-    mEvaluating(PR_FALSE)
+  : nsSVGScriptElementBase(aNodeInfo)
 {
   AddMutationObserver(this);
 }
@@ -143,7 +136,29 @@ nsSVGScriptElement::nsSVGScriptElement(nsINodeInfo *aNodeInfo)
 //----------------------------------------------------------------------
 // nsIDOMNode methods
 
-NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGScriptElement)
+nsresult
+nsSVGScriptElement::Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const
+{
+  *aResult = nsnull;
+
+  nsSVGScriptElement* it = new nsSVGScriptElement(aNodeInfo);
+  if (!it) {
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  nsCOMPtr<nsINode> kungFuDeathGrip = it;
+  nsresult rv = CopyInnerTo(it);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // The clone should be marked evaluated if we are.
+  it->mIsEvaluated = mIsEvaluated;
+  it->mLineNumber = mLineNumber;
+  it->mMalformed = mMalformed;
+
+  kungFuDeathGrip.swap(*aResult);
+
+  return NS_OK;
+}
 
 //----------------------------------------------------------------------
 // nsIDOMSVGScriptElement methods
diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
index a518ebc..66a2137 100644
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -9674,6 +9674,8 @@ nsCSSFrameConstructor::CharacterDataChanged(nsIContent* aContent,
 nsresult
 nsCSSFrameConstructor::ProcessRestyledFrames(nsStyleChangeList& aChangeList)
 {
+  NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
+               """"Someone forgot a script blocker"""");
   PRInt32 count = aChangeList.Count();
   if (!count)
     return NS_OK;
@@ -13261,6 +13263,11 @@ nsCSSFrameConstructor::RebuildAllStyleData(nsChangeHint aExtraHint)
     return;
   }
 
+  nsAutoScriptBlocker scriptBlocker;
+
+  // Make sure that the viewmanager will outlive the presshell
+  nsIViewManager::UpdateViewBatch batch(mPresShell->GetViewManager());
+
   // Processing the style changes could cause a flush that propagates to
   // the parent frame and thus destroys the pres shell.
   nsCOMPtr<nsIPresShell> kungFuDeathGrip(mPresShell);
@@ -13268,8 +13275,10 @@ nsCSSFrameConstructor::RebuildAllStyleData(nsChangeHint aExtraHint)
   // Tell the style set to get the old rule tree out of the way
   // so we can recalculate while maintaining rule tree immutability
   nsresult rv = mPresShell->StyleSet()->BeginReconstruct();
-  if (NS_FAILED(rv))
+  if (NS_FAILED(rv)) {
+    batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
     return;
+  }
 
   // Recalculate all of the style contexts for the document
   // Note that we can ignore the return value of ComputeStyleChangeFor
@@ -13290,6 +13299,7 @@ nsCSSFrameConstructor::RebuildAllStyleData(nsChangeHint aExtraHint)
   // reconstructed will still have their old style context pointers
   // until they are destroyed).
   mPresShell->StyleSet()->EndReconstruct();
+  batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
 }
 
 void
@@ -13450,8 +13460,10 @@ nsCSSFrameConstructor::LazyGenerateChildrenEvent::Run()
       nsFrameConstructorState state(mPresShell, nsnull, nsnull, nsnull);
       nsresult rv = fc->ProcessChildren(state, mContent, frame->GetStyleContext(),
                                         frame, PR_FALSE, childItems, PR_FALSE);
-      if (NS_FAILED(rv))
+      if (NS_FAILED(rv)) {
+        fc->EndUpdate();
         return rv;
+      }
 
       frame->SetInitialChildList(nsnull, childItems.childList);
 
diff --git a/layout/base/nsCSSFrameConstructor.h b/layout/base/nsCSSFrameConstructor.h
index 62f8807..48a791c 100644
--- a/layout/base/nsCSSFrameConstructor.h
+++ b/layout/base/nsCSSFrameConstructor.h
@@ -164,7 +164,7 @@ public:
   PRUint32 GetHoverGeneration() const { return mHoverGeneration; }
 
   // Note: It's the caller's responsibility to make sure to wrap a
-  // ProcessRestyledFrames call in a view update batch.
+  // ProcessRestyledFrames call in a view update batch and a script blocker.
   // This function does not call ProcessAttachedQueue() on the binding manager.
   // If the caller wants that to happen synchronously, it needs to handle that
   // itself.
@@ -198,7 +198,7 @@ public:
                         PRInt32 aNewIndexInContainer);
 
   // Note: It's the caller's responsibility to make sure to wrap a
-  // ProcessPendingRestyles call in a view update batch.
+  // ProcessPendingRestyles call in a view update batch and a script blocker.
   // This function does not call ProcessAttachedQueue() on the binding manager.
   // If the caller wants that to happen synchronously, it needs to handle that
   // itself."""
1e5ec4caa5437bef670c41476283f5a5a08d8eea,50427,452979,masa141421356@gmail.com,"Bug 452979 - Invisible control characters in URL MUST NOT be decoded when showing its address (r=gavin)
",1231263694,"""diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
index b47e0cd..bf2bec4 100644
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -2124,9 +2124,10 @@ function losslessDecodeURI(aURI) {
                          encodeURIComponent);
     } catch (e) {}
 
-  // Encode invisible characters (invisible control characters, soft hyphen,
-  // zero-width space, BOM, line separator, paragraph separator) (bug 452979)
-  value = value.replace(/[\v\x0c\x1c\x1d\x1e\x1f\u00ad\u200b\ufeff\u2028\u2029]/g,
+  // Encode invisible characters (soft hyphen, zero-width space, BOM,
+  // line and paragraph separator, word joiner, invisible times,
+  // invisible separator, object replacement character) (bug 452979)
+  value = value.replace(/[\v\x0c\x1c\x1d\x1e\x1f\u00ad\u200b\ufeff\u2028\u2029\u2060\u2062\u2063\ufffc]/g,
                         encodeURIComponent);
 
   // Encode bidirectional formatting characters."""
9280f06a20375164bab886a7ebdf654dcb55db6f,50840,440230,L. David Baron,"Better handling of overflowing integer values.  (Bug 440230)  r+sr=roc
",1230429494,"""diff --git a/layout/style/nsCSSDeclaration.h b/layout/style/nsCSSDeclaration.h
index bcab950..c446971 100644
--- a/layout/style/nsCSSDeclaration.h
+++ b/layout/style/nsCSSDeclaration.h
@@ -182,9 +182,17 @@ private:
     //
     friend class CSSStyleRuleImpl;
     void AddRef(void) {
+      if (mRefCnt == PR_UINT32_MAX) {
+        NS_WARNING(""""refcount overflow, leaking object"""");
+        return;
+      }
       ++mRefCnt;
     }
     void Release(void) {
+      if (mRefCnt == PR_UINT32_MAX) {
+        NS_WARNING(""""refcount overflow, leaking object"""");
+        return;
+      }
       NS_ASSERTION(0 < mRefCnt, """"bad Release"""");
       if (0 == --mRefCnt) {
         delete this;
diff --git a/layout/style/nsCSSValue.h b/layout/style/nsCSSValue.h
index 437275d..9e8f61a 100644
--- a/layout/style/nsCSSValue.h
+++ b/layout/style/nsCSSValue.h
@@ -448,8 +448,21 @@ public:
     nsCOMPtr<nsIURI> mReferrer;
     nsCOMPtr<nsIPrincipal> mOriginPrincipal;
 
-    void AddRef() { ++mRefCnt; }
-    void Release() { if (--mRefCnt == 0) delete this; }
+    void AddRef() {
+      if (mRefCnt == PR_UINT32_MAX) {
+        NS_WARNING(""""refcount overflow, leaking nsCSSValue::URL"""");
+        return;
+      }
+      ++mRefCnt;
+    }
+    void Release() {
+      if (mRefCnt == PR_UINT32_MAX) {
+        NS_WARNING(""""refcount overflow, leaking nsCSSValue::URL"""");
+        return;
+      }
+      if (--mRefCnt == 0)
+        delete this;
+    }
   protected:
     nsrefcnt mRefCnt;
   };
@@ -467,9 +480,15 @@ public:
 
     nsCOMPtr<imgIRequest> mRequest; // null == image load blocked or somehow failed
 
-    // Override AddRef/Release so we delete ourselves via the right pointer.
-    void AddRef() { ++mRefCnt; }
-    void Release() { if (--mRefCnt == 0) delete this; }
+    // Override Release so we delete correctly without a virtual destructor
+    void Release() {
+      if (mRefCnt == PR_UINT32_MAX) {
+        NS_WARNING(""""refcount overflow, leaking nsCSSValue::Image"""");
+        return;
+      }
+      if (--mRefCnt == 0)
+        delete this;
+    }
   };
 
 private:
diff --git a/layout/style/nsStyleContext.h b/layout/style/nsStyleContext.h
index 1000c48..e9d8afe 100644
--- a/layout/style/nsStyleContext.h
+++ b/layout/style/nsStyleContext.h
@@ -80,12 +80,20 @@ public:
   NS_HIDDEN_(void) Destroy();
 
   nsrefcnt AddRef() {
+    if (mRefCnt == PR_UINT32_MAX) {
+      NS_WARNING(""""refcount overflow, leaking object"""");
+      return mRefCnt;
+    }
     ++mRefCnt;
     NS_LOG_ADDREF(this, mRefCnt, """"nsStyleContext"""", sizeof(nsStyleContext));
     return mRefCnt;
   }
 
   nsrefcnt Release() {
+    if (mRefCnt == PR_UINT32_MAX) {
+      NS_WARNING(""""refcount overflow, leaking object"""");
+      return mRefCnt;
+    }
     --mRefCnt;
     NS_LOG_RELEASE(this, mRefCnt, """"nsStyleContext"""");
     if (mRefCnt == 0) {
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
index 5de31b5..92bbee1 100644
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -1741,6 +1741,10 @@ nsChangeHint nsStyleTextReset::MaxDifference()
 nsrefcnt
 nsCSSShadowArray::Release()
 {
+  if (mRefCnt == PR_UINT32_MAX) {
+    NS_WARNING(""""refcount overflow, leaking object"""");
+    return mRefCnt;
+  }
   mRefCnt--;
   if (mRefCnt == 0) {
     delete this;
diff --git a/layout/style/nsStyleStruct.h b/layout/style/nsStyleStruct.h
index c9032f6..a78ae8c 100644
--- a/layout/style/nsStyleStruct.h
+++ b/layout/style/nsStyleStruct.h
@@ -358,7 +358,13 @@ class nsCSSShadowArray {
       }
     }
 
-    nsrefcnt AddRef() { return ++mRefCnt; }
+    nsrefcnt AddRef() {
+      if (mRefCnt == PR_UINT32_MAX) {
+        NS_WARNING(""""refcount overflow, leaking object"""");
+        return mRefCnt;
+      }
+      return ++mRefCnt;
+    }
     nsrefcnt Release();
 
     PRUint32 Length() const { return mLength; }"""
4f06bed4b107ca9a19f15a1d38065232b9c5875b,50988,468581,Blake Kaplan,"Bug 468581 - Use a better function to compute principals. r=brendan

--HG--
extra : rebase_source : 137705045b8b528c49405a52f91455306ecf9857
",1229730440,"""diff --git a/js/src/jsobj.cpp b/js/src/jsobj.cpp
index 06f4ffc..954e9b5 100644
--- a/js/src/jsobj.cpp
+++ b/js/src/jsobj.cpp
@@ -1259,7 +1259,7 @@ obj_eval(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
             }
             if (obj != callerScopeChain) {
                 ok = js_CheckPrincipalsAccess(cx, obj,
-                                              caller->script->principals,
+                                              JS_StackFramePrincipals(cx, caller),
                                               cx->runtime->atomState.evalAtom);
                 if (!ok)
                     goto out;"""
dd909bc2fa47209bbb740eae756441bf3b0a942d,51201,466937,Simon Bnzli,"Bug 466937 - [r=dietrich]
",1229325250,"""diff --git a/browser/components/sessionstore/src/nsSessionStore.js b/browser/components/sessionstore/src/nsSessionStore.js
index 45ade10..24523df 100644
--- a/browser/components/sessionstore/src/nsSessionStore.js
+++ b/browser/components/sessionstore/src/nsSessionStore.js
@@ -1341,8 +1341,12 @@ SessionStoreService.prototype = {
     let data = {};
     do {
       let id = node.id ? """"#"""" + node.id : XPathHelper.generate(node);
-      if (node instanceof Ci.nsIDOMHTMLInputElement)
-        data[id] = node.type == """"checkbox"""" || node.type == """"radio"""" ? node.checked : node.value;
+      if (node instanceof Ci.nsIDOMHTMLInputElement) {
+        if (node.type != """"file"""")
+          data[id] = node.type == """"checkbox"""" || node.type == """"radio"""" ? node.checked : node.value;
+        else
+          data[id] = { type: """"file"""", value: node.value };
+      }
       else if (node instanceof Ci.nsIDOMHTMLTextAreaElement)
         data[id] = node.value;
       else if (!node.multiple)
@@ -1969,7 +1973,7 @@ SessionStoreService.prototype = {
             RegExp.$1 == aPrefix && hasExpectedURL(aContent.document, aURL)) {
           var document = aContent.document;
           var node = RegExp.$2 ? document.getElementById(RegExp.$3) : document.getElementsByName(RegExp.$3)[0] || null;
-          if (node && """"value"""" in node) {
+          if (node && """"value"""" in node && node.type != """"file"""") {
             node.value = decodeURI(RegExp.$4);
             
             var event = document.createEvent(""""UIEvents"""");
@@ -1991,7 +1995,7 @@ SessionStoreService.prototype = {
           continue;
         
         let value = aData[key];
-        if (typeof value == """"string"""") {
+        if (typeof value == """"string"""" && node.type != """"file"""") {
           node.value = value;
           
           let event = aDocument.createEvent(""""UIEvents"""");
@@ -2004,6 +2008,8 @@ SessionStoreService.prototype = {
           try {
             node.selectedIndex = value;
           } catch (ex) { /* throws for invalid indices */ }
+        else if (value && value.type && value.type == node.type)
+          node.value = value.value;
         else if (value && typeof value.indexOf == """"function"""" && node.options) {
           Array.forEach(node.options, function(aOpt, aIx) {
             aOpt.selected = value.indexOf(aIx) > -1;
diff --git a/browser/components/sessionstore/test/browser/Makefile.in b/browser/components/sessionstore/test/browser/Makefile.in
index be692cf..89a55f8 100644
--- a/browser/components/sessionstore/test/browser/Makefile.in
+++ b/browser/components/sessionstore/test/browser/Makefile.in
@@ -67,6 +67,8 @@ _BROWSER_TEST_FILES = \
 	browser_463206_sample.html \
 	browser_465215.js \
 	browser_465223.js \
+	browser_466937.js \
+	browser_466937_sample.html \
 	$(NULL)
 
 libs:: $(_BROWSER_TEST_FILES)
diff --git a/browser/components/sessionstore/test/browser/browser_466937.js b/browser/components/sessionstore/test/browser/browser_466937.js
new file mode 100644
index 0000000..9dd4fb5
--- /dev/null
+++ b/browser/components/sessionstore/test/browser/browser_466937.js
@@ -0,0 +1,69 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is sessionstore test code.
+ *
+ * The Initial Developer of the Original Code is
+ * Simon Bnzli <zeniko@gmail.com>.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+function test() {
+  /** Test for Bug 466937 **/
+  
+  waitForExplicitFinish();
+  
+  let testURL = """"http://localhost:8888/browser/"""" +
+    """"browser/components/sessionstore/test/browser/browser_466937_sample.html"""";
+  let testPath = """"/home/user/regular.file"""";
+  
+  let tab = gBrowser.addTab(testURL);
+  tab.linkedBrowser.addEventListener(""""load"""", function(aEvent) {
+    let doc = tab.linkedBrowser.contentDocument;
+    doc.getElementById(""""reverse_thief"""").value = """"/home/user/secret2"""";
+    doc.getElementById(""""bystander"""").value = testPath;
+    
+    let tab2 = gBrowser.duplicateTab(tab);
+    tab2.linkedBrowser.addEventListener(""""load"""", function(aEvent) {
+      doc = tab2.linkedBrowser.contentDocument;
+      is(doc.getElementById(""""thief"""").value, """""""",
+         """"file path wasn't set to text field value"""");
+      is(doc.getElementById(""""reverse_thief"""").value, """""""",
+         """"text field value wasn't set to full file path"""");
+      is(doc.getElementById(""""bystander"""").value, testPath,
+         """"normal case: file path was correctly preserved"""");
+      
+      // clean up
+      gBrowser.removeTab(tab2);
+      gBrowser.removeTab(tab);
+      
+      finish();
+    }, true);
+  }, true);
+}
diff --git a/browser/components/sessionstore/test/browser/browser_466937_sample.html b/browser/components/sessionstore/test/browser/browser_466937_sample.html
new file mode 100644
index 0000000..21e699d
--- /dev/null
+++ b/browser/components/sessionstore/test/browser/browser_466937_sample.html
@@ -0,0 +1,20 @@
+<!-- Testcase originally by <moz_bug_r_a4@yahoo.com> -->
+
+<!DOCTYPE html>
+<title>Test for bug 466937</title>
+
+<input id=""""thief"""" value=""""/home/user/secret"""">
+<input type=""""file"""" id=""""reverse_thief"""">
+<input type=""""file"""" id=""""bystander"""">
+
+<script>
+  window.addEventListener(""""DOMContentLoaded"""", function() {
+    if (!document.location.hash) {
+      document.location.hash = """"#ready"""";
+    }
+    else {
+      document.getElementById(""""thief"""").type = """"file"""";
+      document.getElementById(""""reverse_thief"""").type = """"text"""";
+    }
+  }, false);
+</script>"""
a10f3361421d3f170dc40231c52ad74d951b463a,51319,441751,Dave Camp,"Bug 441751 - ""Directives not to cache pages ignored."" [r+sr=bzbarsky]
* * *
Bug 441751 - ""Directives not to cache pages ignored."" (fix for offline cache updating) [r+sr=bzbarsky]
",1229061467,"""diff --git a/dom/src/base/nsGlobalWindow.cpp b/dom/src/base/nsGlobalWindow.cpp
index 9364446..3fb5169 100644
--- a/dom/src/base/nsGlobalWindow.cpp
+++ b/dom/src/base/nsGlobalWindow.cpp
@@ -9399,7 +9399,8 @@ nsNavigator::MozIsLocallyAvailable(const nsAString &aURI,
 
   if (aWhenOffline) {
     loadFlags |= nsICachingChannel::LOAD_CHECK_OFFLINE_CACHE |
-                 nsICachingChannel::LOAD_ONLY_FROM_CACHE;
+                 nsICachingChannel::LOAD_ONLY_FROM_CACHE |
+                 nsIRequest::LOAD_FROM_CACHE;
   }
 
   nsCOMPtr<nsIChannel> channel;
diff --git a/netwerk/protocol/http/src/nsHttpChannel.cpp b/netwerk/protocol/http/src/nsHttpChannel.cpp
index 6ec636c..7538834 100644
--- a/netwerk/protocol/http/src/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/src/nsHttpChannel.cpp
@@ -1543,7 +1543,7 @@ nsHttpChannel::OpenCacheEntry(PRBool offline, PRBool *delayed)
 
     // Set the desired cache access mode accordingly...
     nsCacheAccessMode accessRequested;
-    if (mLoadFlags & (LOAD_ONLY_FROM_CACHE | INHIBIT_CACHING)) {
+    if (offline || (mLoadFlags & INHIBIT_CACHING)) {
         // If we have been asked to bypass the cache and not write to the
         // cache, then don't use the cache at all.  Unless we're actually
         // offline, which takes precedence over BYPASS_LOCAL_CACHE.
@@ -1914,15 +1914,15 @@ nsHttpChannel::CheckCache()
     NS_ENSURE_SUCCESS(rv, rv);
     buf.Adopt(0);
 
-    // Don't bother to validate LOAD_ONLY_FROM_CACHE items.
     // Don't bother to validate items that are read-only,
     // unless they are read-only because of INHIBIT_CACHING or because
     // we're updating the offline cache.
     // Don't bother to validate if this is a fallback entry.
-    if (mLoadFlags & LOAD_ONLY_FROM_CACHE ||
-        (mCacheAccess == nsICache::ACCESS_READ &&
-         !((mLoadFlags & INHIBIT_CACHING) || mCacheForOfflineUse)) ||
-        mFallbackChannel) {
+    if (!mCacheForOfflineUse &&
+        (mLoadedFromApplicationCache ||
+         (mCacheAccess == nsICache::ACCESS_READ &&
+          !(mLoadFlags & INHIBIT_CACHING)) ||
+         mFallbackChannel)) {
         mCachedContentIsValid = PR_TRUE;
         return NS_OK;
     }
diff --git a/netwerk/test/unit/test_cacheflags.js b/netwerk/test/unit/test_cacheflags.js
new file mode 100644
index 0000000..c4fb42e
--- /dev/null
+++ b/netwerk/test/unit/test_cacheflags.js
@@ -0,0 +1,268 @@
+do_import_script(""""netwerk/test/httpserver/httpd.js"""");
+
+var httpserver = null;
+
+// Need to randomize, because apparently no one clears our cache
+var suffix = Math.random();
+var httpBase = """"http://localhost:4444"""";
+var httpsBase = """"http://localhost:4445"""";
+var shortexpPath = """"/shortexp"""" + suffix;
+var longexpPath = """"/longexp"""" + suffix;
+var nocachePath = """"/nocache"""" + suffix;
+var nostorePath = """"/nostore"""" + suffix;
+
+function make_channel(url, flags) {
+  var ios = Cc[""""@mozilla.org/network/io-service;1""""].
+    getService(Ci.nsIIOService);
+  var req = ios.newChannel(url, null, null);
+  req.loadFlags = flags;
+  return req;
+}
+
+function Test(path, flags, expectSuccess, readFromCache, hitServer) {
+  this.path = path;
+  this.flags = flags;
+  this.expectSuccess = expectSuccess;
+  this.readFromCache = readFromCache;
+  this.hitServer = hitServer;
+}
+
+Test.prototype = {
+  flags: 0,
+  expectSuccess: true,
+  readFromCache: false,
+  hitServer: true,
+  _buffer: """""""",
+  _isFromCache: false,
+
+  QueryInterface: function(iid) {
+    if (iid.equals(Components.interfaces.nsIStreamListener) ||
+        iid.equals(Components.interfaces.nsIRequestObserver) ||
+        iid.equals(Components.interfaces.nsISupports))
+      return this;
+    throw Components.results.NS_ERROR_NO_INTERFACE;
+  },
+
+  onStartRequest: function(request, context) {
+    var cachingChannel = request.QueryInterface(Ci.nsICachingChannel);
+    this._isFromCache = request.isPending() && cachingChannel.isFromCache();
+  },
+
+  onDataAvailable: function(request, context, stream, offset, count) {
+    this._buffer = this._buffer.concat(read_stream(stream, count));
+  },
+
+  onStopRequest: function(request, context, status) {
+    do_check_eq(Components.isSuccessCode(status), this.expectSuccess);
+    do_check_eq(this._isFromCache, this.readFromCache);
+    do_check_eq(gHitServer, this.hitServer);
+
+    do_timeout(0, """"run_next_test();"""");
+  },
+
+  run: function() {
+    dump(""""Running:"""" +
+         """"\n  """" + this.path +
+         """"\n  """" + this.flags +
+         """"\n  """" + this.expectSuccess +
+         """"\n  """" + this.readFromCache +
+         """"\n  """" + this.hitServer + """"\n"""");
+    gHitServer = false;
+    var channel = make_channel(this.path, this.flags);
+    channel.asyncOpen(this, null);
+  }
+};
+
+var gHitServer = false;
+
+var gTests = [
+  new Test(httpBase + shortexpPath, 0,
+           true,   // expect success
+           false,  // read from cache
+           true),  // hit server
+  new Test(httpBase + shortexpPath, 0,
+           true,   // expect success
+           true,   // read from cache
+           true),  // hit server
+  new Test(httpBase + shortexpPath, Ci.nsIRequest.LOAD_BYPASS_CACHE,
+           true,   // expect success
+           false,  // read from cache
+           true),  // hit server
+  new Test(httpBase + shortexpPath, Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE,
+           false,  // expect success
+           false,  // read from cache
+           false), // hit server
+  new Test(httpBase + shortexpPath,
+           Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
+           Ci.nsIRequest.VALIDATE_NEVER,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+  new Test(httpBase + shortexpPath, Ci.nsIRequest.LOAD_FROM_CACHE,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+
+  new Test(httpBase + longexpPath, 0,
+           true,   // expect success
+           false,  // read from cache
+           true),  // hit server
+  new Test(httpBase + longexpPath, 0,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+  new Test(httpBase + longexpPath, Ci.nsIRequest.LOAD_BYPASS_CACHE,
+           true,   // expect success
+           false,  // read from cache
+           true),  // hit server
+  new Test(httpBase + longexpPath,
+           Ci.nsIRequest.VALIDATE_ALWAYS,
+           true,   // expect success
+           true,   // read from cache
+           true),  // hit server
+  new Test(httpBase + longexpPath, Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+  new Test(httpBase + longexpPath,
+           Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
+           Ci.nsIRequest.VALIDATE_NEVER,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+  new Test(httpBase + longexpPath,
+           Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
+           Ci.nsIRequest.VALIDATE_ALWAYS,
+           false,  // expect success
+           false,  // read from cache
+           false), // hit server
+  new Test(httpBase + longexpPath, Ci.nsIRequest.LOAD_FROM_CACHE,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+
+  new Test(httpBase + nocachePath, 0,
+           true,   // expect success
+           false,  // read from cache
+           true),  // hit server
+  new Test(httpBase + nocachePath, 0,
+           true,   // expect success
+           true,   // read from cache
+           true),  // hit server
+  new Test(httpBase + nocachePath, Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE,
+           false,  // expect success
+           false,  // read from cache
+           false), // hit server
+  new Test(httpBase + nocachePath, Ci.nsIRequest.LOAD_FROM_CACHE,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+  // LOAD_ONLY_FROM_CACHE would normally fail (because no-cache forces
+  // a validation), but VALIDATE_NEVER should override that.
+  new Test(httpBase + nocachePath,
+           Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
+           Ci.nsIRequest.VALIDATE_NEVER,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+
+  // ... however, no-cache over ssl should act like no-store and force
+  // a validation (and therefore failure) even if VALIDATE_NEVER is
+  // set.
+  /* XXX bug 466524: We can't currently start an ssl server in xpcshell tests,
+                     so this test is currently disabled.
+  new Test(httpsBase + nocachePath,
+           Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
+           Ci.nsIRequest.VALIDATE_NEVER,
+           false,  // expect success
+           false,  // read from cache
+           false)  // hit server
+  */
+  new Test(httpBase + nostorePath, 0,
+           true,   // expect success
+           false,  // read from cache
+           true),  // hit server
+  new Test(httpBase + nostorePath, 0,
+           true,   // expect success
+           false,  // read from cache
+           true),  // hit server
+  new Test(httpBase + nostorePath, Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE,
+           false,  // expect success
+           false,  // read from cache
+           false), // hit server
+  new Test(httpBase + nostorePath, Ci.nsIRequest.LOAD_FROM_CACHE,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+  // no-store should force the validation (and therefore failure, with
+  // LOAD_ONLY_FROM_CACHE) even if VALIDATE_NEVER is set.
+  new Test(httpBase + nostorePath,
+           Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
+           Ci.nsIRequest.VALIDATE_NEVER,
+           false,  // expect success
+           false,  // read from cache
+           false)  // hit server
+  ];
+
+function run_next_test()
+{
+  if (gTests.length == 0) {
+    httpserver.stop();
+    do_test_finished();
+    return;
+  }
+
+  var test = gTests.shift();
+  test.run();
+}
+
+function handler(metadata, response) {
+  gHitServer = true;
+  try {
+    var etag = metadata.getHeader(""""If-None-Match"""");
+  } catch(ex) {
+    var etag = """""""";
+  }
+  if (etag == """"testtag"""") {
+    // Allow using the cached data
+    response.setStatusLine(metadata.httpVersion, 304, """"Not Modified"""");
+  } else {
+    response.setStatusLine(metadata.httpVersion, 200, """"OK"""");
+    response.setHeader(""""Content-Type"""", """"text/plain"""", false);
+    response.setHeader(""""ETag"""", """"testtag"""", false);
+    const body = """"data"""";
+    response.bodyOutputStream.write(body, body.length);
+  }
+}
+
+function nocache_handler(metadata, response) {
+  response.setHeader(""""Cache-Control"""", """"no-cache"""", false);
+  handler(metadata, response);
+}
+
+function nostore_handler(metadata, response) {
+  response.setHeader(""""Cache-Control"""", """"no-store"""", false);
+  handler(metadata, response);
+}
+
+function shortexp_handler(metadata, response) {
+  response.setHeader(""""Cache-Control"""", """"max-age=0"""", false);
+  handler(metadata, response);
+}
+
+function longexp_handler(metadata, response) {
+  response.setHeader(""""Cache-Control"""", """"max-age=10000"""", false);
+  handler(metadata, response);
+}
+
+function run_test() {
+  httpserver = new nsHttpServer();
+  httpserver.registerPathHandler(shortexpPath, shortexp_handler);
+  httpserver.registerPathHandler(longexpPath, longexp_handler);
+  httpserver.registerPathHandler(nocachePath, nocache_handler);
+  httpserver.registerPathHandler(nostorePath, nostore_handler);
+  httpserver.start(4444);
+
+  run_next_test();
+  do_test_pending();
+}
diff --git a/netwerk/test/unit/test_redirect_caching.js b/netwerk/test/unit/test_redirect_caching.js
index 1fda7c4..c752998 100644
--- a/netwerk/test/unit/test_redirect_caching.js
+++ b/netwerk/test/unit/test_redirect_caching.js
@@ -30,7 +30,7 @@ function firstTimeThrough(request, buffer)
 {
   do_check_eq(buffer, responseBody);
   var chan = make_channel(randomURI);
-  chan.loadFlags |= Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE;
+  chan.loadFlags |= Ci.nsICachingChannel.LOAD_FROM_CACHE;
   chan.asyncOpen(new ChannelListener(finish_test, null), null);
 }
 """
2ccc82d620da7f0192ed541170792aa5124e9df4,51494,441751,Dave Camp,"Bug 441751: Fix up LOAD_ONLY_FROM_CACHE.  r+sr=bz
",1228793073,"""diff --git a/dom/src/base/nsGlobalWindow.cpp b/dom/src/base/nsGlobalWindow.cpp
index e8971ba..e26cd4b 100644
--- a/dom/src/base/nsGlobalWindow.cpp
+++ b/dom/src/base/nsGlobalWindow.cpp
@@ -9401,7 +9401,8 @@ nsNavigator::MozIsLocallyAvailable(const nsAString &aURI,
 
   if (aWhenOffline) {
     loadFlags |= nsICachingChannel::LOAD_CHECK_OFFLINE_CACHE |
-                 nsICachingChannel::LOAD_ONLY_FROM_CACHE;
+                 nsICachingChannel::LOAD_ONLY_FROM_CACHE |
+                 nsIRequest::LOAD_FROM_CACHE;
   }
 
   nsCOMPtr<nsIChannel> channel;
diff --git a/netwerk/protocol/http/src/nsHttpChannel.cpp b/netwerk/protocol/http/src/nsHttpChannel.cpp
index 6ec636c..415353f 100644
--- a/netwerk/protocol/http/src/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/src/nsHttpChannel.cpp
@@ -1543,7 +1543,7 @@ nsHttpChannel::OpenCacheEntry(PRBool offline, PRBool *delayed)
 
     // Set the desired cache access mode accordingly...
     nsCacheAccessMode accessRequested;
-    if (mLoadFlags & (LOAD_ONLY_FROM_CACHE | INHIBIT_CACHING)) {
+    if (offline || (mLoadFlags & INHIBIT_CACHING)) {
         // If we have been asked to bypass the cache and not write to the
         // cache, then don't use the cache at all.  Unless we're actually
         // offline, which takes precedence over BYPASS_LOCAL_CACHE.
@@ -1914,12 +1914,11 @@ nsHttpChannel::CheckCache()
     NS_ENSURE_SUCCESS(rv, rv);
     buf.Adopt(0);
 
-    // Don't bother to validate LOAD_ONLY_FROM_CACHE items.
     // Don't bother to validate items that are read-only,
     // unless they are read-only because of INHIBIT_CACHING or because
     // we're updating the offline cache.
     // Don't bother to validate if this is a fallback entry.
-    if (mLoadFlags & LOAD_ONLY_FROM_CACHE ||
+    if (mLoadedFromApplicationCache ||
         (mCacheAccess == nsICache::ACCESS_READ &&
          !((mLoadFlags & INHIBIT_CACHING) || mCacheForOfflineUse)) ||
         mFallbackChannel) {
diff --git a/netwerk/test/unit/test_cacheflags.js b/netwerk/test/unit/test_cacheflags.js
new file mode 100644
index 0000000..c4fb42e
--- /dev/null
+++ b/netwerk/test/unit/test_cacheflags.js
@@ -0,0 +1,268 @@
+do_import_script(""""netwerk/test/httpserver/httpd.js"""");
+
+var httpserver = null;
+
+// Need to randomize, because apparently no one clears our cache
+var suffix = Math.random();
+var httpBase = """"http://localhost:4444"""";
+var httpsBase = """"http://localhost:4445"""";
+var shortexpPath = """"/shortexp"""" + suffix;
+var longexpPath = """"/longexp"""" + suffix;
+var nocachePath = """"/nocache"""" + suffix;
+var nostorePath = """"/nostore"""" + suffix;
+
+function make_channel(url, flags) {
+  var ios = Cc[""""@mozilla.org/network/io-service;1""""].
+    getService(Ci.nsIIOService);
+  var req = ios.newChannel(url, null, null);
+  req.loadFlags = flags;
+  return req;
+}
+
+function Test(path, flags, expectSuccess, readFromCache, hitServer) {
+  this.path = path;
+  this.flags = flags;
+  this.expectSuccess = expectSuccess;
+  this.readFromCache = readFromCache;
+  this.hitServer = hitServer;
+}
+
+Test.prototype = {
+  flags: 0,
+  expectSuccess: true,
+  readFromCache: false,
+  hitServer: true,
+  _buffer: """""""",
+  _isFromCache: false,
+
+  QueryInterface: function(iid) {
+    if (iid.equals(Components.interfaces.nsIStreamListener) ||
+        iid.equals(Components.interfaces.nsIRequestObserver) ||
+        iid.equals(Components.interfaces.nsISupports))
+      return this;
+    throw Components.results.NS_ERROR_NO_INTERFACE;
+  },
+
+  onStartRequest: function(request, context) {
+    var cachingChannel = request.QueryInterface(Ci.nsICachingChannel);
+    this._isFromCache = request.isPending() && cachingChannel.isFromCache();
+  },
+
+  onDataAvailable: function(request, context, stream, offset, count) {
+    this._buffer = this._buffer.concat(read_stream(stream, count));
+  },
+
+  onStopRequest: function(request, context, status) {
+    do_check_eq(Components.isSuccessCode(status), this.expectSuccess);
+    do_check_eq(this._isFromCache, this.readFromCache);
+    do_check_eq(gHitServer, this.hitServer);
+
+    do_timeout(0, """"run_next_test();"""");
+  },
+
+  run: function() {
+    dump(""""Running:"""" +
+         """"\n  """" + this.path +
+         """"\n  """" + this.flags +
+         """"\n  """" + this.expectSuccess +
+         """"\n  """" + this.readFromCache +
+         """"\n  """" + this.hitServer + """"\n"""");
+    gHitServer = false;
+    var channel = make_channel(this.path, this.flags);
+    channel.asyncOpen(this, null);
+  }
+};
+
+var gHitServer = false;
+
+var gTests = [
+  new Test(httpBase + shortexpPath, 0,
+           true,   // expect success
+           false,  // read from cache
+           true),  // hit server
+  new Test(httpBase + shortexpPath, 0,
+           true,   // expect success
+           true,   // read from cache
+           true),  // hit server
+  new Test(httpBase + shortexpPath, Ci.nsIRequest.LOAD_BYPASS_CACHE,
+           true,   // expect success
+           false,  // read from cache
+           true),  // hit server
+  new Test(httpBase + shortexpPath, Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE,
+           false,  // expect success
+           false,  // read from cache
+           false), // hit server
+  new Test(httpBase + shortexpPath,
+           Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
+           Ci.nsIRequest.VALIDATE_NEVER,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+  new Test(httpBase + shortexpPath, Ci.nsIRequest.LOAD_FROM_CACHE,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+
+  new Test(httpBase + longexpPath, 0,
+           true,   // expect success
+           false,  // read from cache
+           true),  // hit server
+  new Test(httpBase + longexpPath, 0,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+  new Test(httpBase + longexpPath, Ci.nsIRequest.LOAD_BYPASS_CACHE,
+           true,   // expect success
+           false,  // read from cache
+           true),  // hit server
+  new Test(httpBase + longexpPath,
+           Ci.nsIRequest.VALIDATE_ALWAYS,
+           true,   // expect success
+           true,   // read from cache
+           true),  // hit server
+  new Test(httpBase + longexpPath, Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+  new Test(httpBase + longexpPath,
+           Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
+           Ci.nsIRequest.VALIDATE_NEVER,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+  new Test(httpBase + longexpPath,
+           Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
+           Ci.nsIRequest.VALIDATE_ALWAYS,
+           false,  // expect success
+           false,  // read from cache
+           false), // hit server
+  new Test(httpBase + longexpPath, Ci.nsIRequest.LOAD_FROM_CACHE,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+
+  new Test(httpBase + nocachePath, 0,
+           true,   // expect success
+           false,  // read from cache
+           true),  // hit server
+  new Test(httpBase + nocachePath, 0,
+           true,   // expect success
+           true,   // read from cache
+           true),  // hit server
+  new Test(httpBase + nocachePath, Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE,
+           false,  // expect success
+           false,  // read from cache
+           false), // hit server
+  new Test(httpBase + nocachePath, Ci.nsIRequest.LOAD_FROM_CACHE,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+  // LOAD_ONLY_FROM_CACHE would normally fail (because no-cache forces
+  // a validation), but VALIDATE_NEVER should override that.
+  new Test(httpBase + nocachePath,
+           Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
+           Ci.nsIRequest.VALIDATE_NEVER,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+
+  // ... however, no-cache over ssl should act like no-store and force
+  // a validation (and therefore failure) even if VALIDATE_NEVER is
+  // set.
+  /* XXX bug 466524: We can't currently start an ssl server in xpcshell tests,
+                     so this test is currently disabled.
+  new Test(httpsBase + nocachePath,
+           Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
+           Ci.nsIRequest.VALIDATE_NEVER,
+           false,  // expect success
+           false,  // read from cache
+           false)  // hit server
+  */
+  new Test(httpBase + nostorePath, 0,
+           true,   // expect success
+           false,  // read from cache
+           true),  // hit server
+  new Test(httpBase + nostorePath, 0,
+           true,   // expect success
+           false,  // read from cache
+           true),  // hit server
+  new Test(httpBase + nostorePath, Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE,
+           false,  // expect success
+           false,  // read from cache
+           false), // hit server
+  new Test(httpBase + nostorePath, Ci.nsIRequest.LOAD_FROM_CACHE,
+           true,   // expect success
+           true,   // read from cache
+           false), // hit server
+  // no-store should force the validation (and therefore failure, with
+  // LOAD_ONLY_FROM_CACHE) even if VALIDATE_NEVER is set.
+  new Test(httpBase + nostorePath,
+           Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
+           Ci.nsIRequest.VALIDATE_NEVER,
+           false,  // expect success
+           false,  // read from cache
+           false)  // hit server
+  ];
+
+function run_next_test()
+{
+  if (gTests.length == 0) {
+    httpserver.stop();
+    do_test_finished();
+    return;
+  }
+
+  var test = gTests.shift();
+  test.run();
+}
+
+function handler(metadata, response) {
+  gHitServer = true;
+  try {
+    var etag = metadata.getHeader(""""If-None-Match"""");
+  } catch(ex) {
+    var etag = """""""";
+  }
+  if (etag == """"testtag"""") {
+    // Allow using the cached data
+    response.setStatusLine(metadata.httpVersion, 304, """"Not Modified"""");
+  } else {
+    response.setStatusLine(metadata.httpVersion, 200, """"OK"""");
+    response.setHeader(""""Content-Type"""", """"text/plain"""", false);
+    response.setHeader(""""ETag"""", """"testtag"""", false);
+    const body = """"data"""";
+    response.bodyOutputStream.write(body, body.length);
+  }
+}
+
+function nocache_handler(metadata, response) {
+  response.setHeader(""""Cache-Control"""", """"no-cache"""", false);
+  handler(metadata, response);
+}
+
+function nostore_handler(metadata, response) {
+  response.setHeader(""""Cache-Control"""", """"no-store"""", false);
+  handler(metadata, response);
+}
+
+function shortexp_handler(metadata, response) {
+  response.setHeader(""""Cache-Control"""", """"max-age=0"""", false);
+  handler(metadata, response);
+}
+
+function longexp_handler(metadata, response) {
+  response.setHeader(""""Cache-Control"""", """"max-age=10000"""", false);
+  handler(metadata, response);
+}
+
+function run_test() {
+  httpserver = new nsHttpServer();
+  httpserver.registerPathHandler(shortexpPath, shortexp_handler);
+  httpserver.registerPathHandler(longexpPath, longexp_handler);
+  httpserver.registerPathHandler(nocachePath, nocache_handler);
+  httpserver.registerPathHandler(nostorePath, nostore_handler);
+  httpserver.start(4444);
+
+  run_next_test();
+  do_test_pending();
+}
diff --git a/netwerk/test/unit/test_redirect_caching.js b/netwerk/test/unit/test_redirect_caching.js
index 1fda7c4..c752998 100644
--- a/netwerk/test/unit/test_redirect_caching.js
+++ b/netwerk/test/unit/test_redirect_caching.js
@@ -30,7 +30,7 @@ function firstTimeThrough(request, buffer)
 {
   do_check_eq(buffer, responseBody);
   var chan = make_channel(randomURI);
-  chan.loadFlags |= Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE;
+  chan.loadFlags |= Ci.nsICachingChannel.LOAD_FROM_CACHE;
   chan.asyncOpen(new ChannelListener(finish_test, null), null);
 }
 """
1f8c5bedb69eb2f7182cbc7ea9b03404c09e206c,51523,411835,Mats Palmgren,"Walk child frame next-in-flows that are overflow containers. Skip [excess]overflowContainersList to avoid processing them more than once. b=411835 r+sr=roc
",1228705285,"""diff --git a/layout/base/nsCSSFrameConstructor.cpp b/layout/base/nsCSSFrameConstructor.cpp
index 2654530..58edee7 100644
--- a/layout/base/nsCSSFrameConstructor.cpp
+++ b/layout/base/nsCSSFrameConstructor.cpp
@@ -9142,6 +9142,33 @@ nsCSSFrameConstructor::ReinsertContent(nsIContent* aContainer,
   return res;
 }
 
+static void
+DoDeletingFrameSubtree(nsFrameManager* aFrameManager,
+                       nsVoidArray&    aDestroyQueue,
+                       nsIFrame*       aRemovedFrame,
+                       nsIFrame*       aFrame);
+
+static void
+DoDeletingOverflowContainers(nsFrameManager* aFrameManager,
+                             nsVoidArray&    aDestroyQueue,
+                             nsIFrame*       aRemovedFrame,
+                             nsIFrame*       aFrame)
+{
+  // The invariant that """"continuing frames should be found as part of the
+  // walk over the top-most frame's continuing frames"""" does not hold for
+  // out-of-flow overflow containers, so we need to walk them too.
+  // Note that DoDeletingFrameSubtree() skips the child lists where
+  // overflow containers live so we won't process them twice.
+  const PRBool orphanSubtree = aRemovedFrame == aFrame;
+  for (nsIFrame* next = aFrame->GetNextContinuation();
+       next && (next->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER);
+       next = next->GetNextContinuation()) {
+    DoDeletingFrameSubtree(aFrameManager, aDestroyQueue,
+                           orphanSubtree ? next : aRemovedFrame,
+                           next);
+  }
+}
+
 /**
  * Called when a frame subtree is about to be deleted. Two important
  * things happen:
@@ -9165,12 +9192,17 @@ nsCSSFrameConstructor::ReinsertContent(nsIContent* aContainer,
  *            the same as aRemovedFrame, but as we recurse down the tree
  *            this changes
  */
-static nsresult
+static void
 DoDeletingFrameSubtree(nsFrameManager* aFrameManager,
                        nsVoidArray&    aDestroyQueue,
                        nsIFrame*       aRemovedFrame,
                        nsIFrame*       aFrame)
 {
+#undef RECURSE
+#define RECURSE(top, child)                                                  \
+  DoDeletingFrameSubtree(aFrameManager, aDestroyQueue, (top), (child));      \
+  DoDeletingOverflowContainers(aFrameManager, aDestroyQueue, (top), (child));
+
   // Remove the mapping from the content object to its frame.
   nsIContent* content = aFrame->GetContent();
   if (content) {
@@ -9185,10 +9217,10 @@ DoDeletingFrameSubtree(nsFrameManager* aFrameManager,
     // Walk aFrame's normal flow child frames looking for placeholder frames.
     nsIFrame* childFrame = aFrame->GetFirstChild(childListName);
     for (; childFrame; childFrame = childFrame->GetNextSibling()) {
+      NS_ASSERTION(!(childFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW),
+                   """"out-of-flow on wrong child list"""");
       if (NS_LIKELY(nsGkAtoms::placeholderFrame != childFrame->GetType())) {
-        DoDeletingFrameSubtree(aFrameManager, aDestroyQueue,
-                               aRemovedFrame, childFrame);
-
+        RECURSE(aRemovedFrame, childFrame);
       } else {
         nsIFrame* outOfFlowFrame =
           nsPlaceholderFrame::GetRealFrameForPlaceholder(childFrame);
@@ -9208,26 +9240,25 @@ DoDeletingFrameSubtree(nsFrameManager* aFrameManager,
                        """"out-of-flow is already in the destroy queue"""");
           aDestroyQueue.AppendElement(outOfFlowFrame);
           // Recurse into the out-of-flow, it is now the aRemovedFrame.
-          DoDeletingFrameSubtree(aFrameManager, aDestroyQueue,
-                                 outOfFlowFrame, outOfFlowFrame);
+          RECURSE(outOfFlowFrame, outOfFlowFrame);
         }
         else {
           // Also recurse into the out-of-flow when it's a descendant of aRemovedFrame
           // since we don't walk those lists, see |childListName| increment below.
-          DoDeletingFrameSubtree(aFrameManager, aDestroyQueue,
-                                 aRemovedFrame, outOfFlowFrame);
+          RECURSE(aRemovedFrame, outOfFlowFrame);
         }
       }
     }
 
     // Move to next child list but skip lists with frames we should have
-    // a placeholder for.
+    // a placeholder for or that contains only next-in-flow overflow containers
+    // (which we walk explicitly above).
     do {
       childListName = aFrame->GetAdditionalChildListName(childListIndex++);
-    } while (IsOutOfFlowList(childListName));
+    } while (IsOutOfFlowList(childListName) ||
+             childListName == nsGkAtoms::overflowContainersList ||
+             childListName == nsGkAtoms::excessOverflowContainersList);
   } while (childListName);
-
-  return NS_OK;
 }
 
 /**
@@ -9261,6 +9292,10 @@ DeletingFrameSubtree(nsFrameManager* aFrameManager,
     // recursing over a subtree, because those continuing frames should be
     // found as part of the walk over the top-most frame's continuing frames.
     // Walking them again will make this an N^2/2 algorithm.
+    // The above is true for normal child next-in-flows but not overflow
+    // containers which we do walk because they *can* escape the subtree
+    // we're deleting.  We skip [excess]overflowContainersList where
+    // they live to avoid processing them more than once.
     aFrame = aFrame->GetNextContinuation();
   } while (aFrame);
 """
6912c8d643a0fefd2d4901de08054d37cbdf8493,51783,451613,Daniel Veditz,"Fixing bug 451613. URL parsing treats leading whitespace inconsistently. r=jst@mozilla.org
",1231808527,"""diff --git a/netwerk/base/src/nsURLParsers.cpp b/netwerk/base/src/nsURLParsers.cpp
index 5657301..50ac921 100644
--- a/netwerk/base/src/nsURLParsers.cpp
+++ b/netwerk/base/src/nsURLParsers.cpp
@@ -93,12 +93,14 @@ nsBaseURLParser::ParseURL(const char *spec, PRInt32 specLen,
     const char *colon = nsnull;
     const char *slash = nsnull;
     const char *p;
+    PRUint32 offset = 0;
     PRInt32 len = specLen;
     for (p = spec; len && *p && !colon && !slash; ++p, --len) {
-        // skip leading whitespace and control characters
-        if (*p > '\0' && *p <= ' ') {
+        // skip leading whitespace
+        if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t') {
             spec++;
             specLen--;
+            offset++;
             continue;
         }
         switch (*p) {
@@ -124,7 +126,7 @@ nsBaseURLParser::ParseURL(const char *spec, PRInt32 specLen,
     if (colon && stop && colon > stop)
         colon = nsnull;
 
-    // if the spec only contained whitespace or control characters...
+    // if the spec only contained whitespace ...
     if (specLen == 0) {
         SET_RESULT(scheme, 0, -1);
         SET_RESULT(authority, 0, 0);
@@ -151,10 +153,11 @@ nsBaseURLParser::ParseURL(const char *spec, PRInt32 specLen,
             NS_WARNING(""""malformed uri"""");
             return NS_ERROR_MALFORMED_URI;
         }
-        SET_RESULT(scheme, 0, colon - spec);
+        SET_RESULT(scheme, offset, colon - spec);
         if (authorityLen || pathLen) {
-            PRUint32 offset = colon + 1 - spec;
-            ParseAfterScheme(colon + 1, specLen - offset,
+            PRUint32 schemeLen = colon + 1 - spec;
+            offset += schemeLen;
+            ParseAfterScheme(colon + 1, specLen - schemeLen,
                              authorityPos, authorityLen,
                              pathPos, pathLen);
             OFFSET_RESULT(authority, offset);
@@ -181,6 +184,8 @@ nsBaseURLParser::ParseURL(const char *spec, PRInt32 specLen,
             ParseAfterScheme(spec, specLen,
                              authorityPos, authorityLen,
                              pathPos, pathLen);
+            OFFSET_RESULT(authority, offset);
+            OFFSET_RESULT(path, offset);
     }
     return NS_OK;
 }"""
7e987b012c6efba7035de830ba90665b4ec16368,51845,436741,Bob Clary,"bug 436741 - JavaScript Test by Jesse Ruderman.
",1228394916,"""diff --git a/js/tests/js1_5/extensions/regress-436741.js b/js/tests/js1_5/extensions/regress-436741.js
new file mode 100644
index 0000000..f1be7f0
--- /dev/null
+++ b/js/tests/js1_5/extensions/regress-436741.js
@@ -0,0 +1,68 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is JavaScript Engine testing utilities.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Jesse Ruderman
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var gTestfile = 'regress-436741.js';
+//-----------------------------------------------------------------------------
+var BUGNUMBER = 436741;
+var summary = 'Do not assert: OBJ_IS_NATIVE(obj)';
+var actual = 'No Crash';
+var expect = 'No Crash';
+
+
+//-----------------------------------------------------------------------------
+test();
+//-----------------------------------------------------------------------------
+
+function test()
+{
+  enterFunc ('test');
+  printBugNumber(BUGNUMBER);
+  printStatus (summary);
+ 
+  if (typeof window == 'undefined')
+  {
+    print('This test is only meaningful in the browser.');
+  }
+  else
+  {
+    window.__proto__.__proto__ = [{}];
+    for (var j in window);
+  }
+  reportCompare(expect, actual, summary);
+
+  exitFunc ('test');
+}"""
4f3c5a4a1e5946e4024d69d6191aa9df3159c405,52106,452786,Bob Clary,"bug 452786 - JavaScript Test by Joachim Kuebart.
",1227781769,"""diff --git a/js/tests/ecma_3/Date/regress-452786.js b/js/tests/ecma_3/Date/regress-452786.js
new file mode 100644
index 0000000..7f842a2
--- /dev/null
+++ b/js/tests/ecma_3/Date/regress-452786.js
@@ -0,0 +1,66 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is JavaScript Engine testing utilities.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Joachim Kuebart
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var gTestfile = 'regress-452786.js';
+//-----------------------------------------------------------------------------
+var BUGNUMBER = 452786;
+var summary = 'Do not crash with (new Date()).getMonth.call(new Function())';
+var actual = '';
+var expect = '';
+
+
+//-----------------------------------------------------------------------------
+test();
+//-----------------------------------------------------------------------------
+
+function test()
+{
+  enterFunc ('test');
+  printBugNumber(BUGNUMBER);
+  printStatus (summary);
+ 
+  try
+  {
+    (new Date()).getMonth.call(new Function());
+  }
+  catch(ex)
+  {
+  }
+  reportCompare(expect, actual, summary);
+
+  exitFunc ('test');
+}"""
145a8f2e24bf5dbb80b63ce3eb99c02aea2befbc,52107,453915,Bob Clary,"bug 453915 - JavaScript Test by Chris Evans.
",1227781767,"""diff --git a/js/tests/e4x/Regress/regress-453915.js b/js/tests/e4x/Regress/regress-453915.js
new file mode 100644
index 0000000..1d44102
--- /dev/null
+++ b/js/tests/e4x/Regress/regress-453915.js
@@ -0,0 +1,54 @@
+/* -*- Mode: java; tab-width:8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is JavaScript Engine testing utilities.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s): Chris Evans
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+gTestfile = 'regress-453915.js';
+
+var summary = 'XML Injection possible via default xml namespace';
+var BUGNUMBER = 453915;
+var actual = '';
+var expect = '';
+
+printBugNumber(BUGNUMBER);
+START(summary);
+
+default xml namespace = '\'';
+<foo/>
+
+TEST(1, expect, actual);
+
+END();"""
51c6be8dc20e34787bfa05145a225a6476b681ad,52208,460425,Boris Zbarsky,"Bug 460425.  Do better security checks during redirection.  r=sicking,biesi, sr=sicking
",1227664204,"""diff --git a/caps/src/nsScriptSecurityManager.cpp b/caps/src/nsScriptSecurityManager.cpp
index 6f35139..b83b234 100644
--- a/caps/src/nsScriptSecurityManager.cpp
+++ b/caps/src/nsScriptSecurityManager.cpp
@@ -3143,13 +3143,19 @@ nsScriptSecurityManager::OnChannelRedirect(nsIChannel* oldChannel,
 
     nsCOMPtr<nsIURI> newURI;
     newChannel->GetURI(getter_AddRefs(newURI));
+    nsCOMPtr<nsIURI> newOriginalURI;
+    newChannel->GetOriginalURI(getter_AddRefs(newOriginalURI));
 
-    NS_ENSURE_STATE(oldPrincipal && newURI);
+    NS_ENSURE_STATE(oldPrincipal && newURI && newOriginalURI);
 
     const PRUint32 flags =
         nsIScriptSecurityManager::LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT |
         nsIScriptSecurityManager::DISALLOW_SCRIPT;
-    return CheckLoadURIWithPrincipal(oldPrincipal, newURI, flags);
+    nsresult rv = CheckLoadURIWithPrincipal(oldPrincipal, newURI, flags);
+    if (NS_SUCCEEDED(rv) && newOriginalURI != newURI) {
+        rv = CheckLoadURIWithPrincipal(oldPrincipal, newOriginalURI, flags);
+    }
+    return rv;
 }
 
 
diff --git a/content/base/src/nsContentUtils.cpp b/content/base/src/nsContentUtils.cpp
index d9477d0..36fd75a 100644
--- a/content/base/src/nsContentUtils.cpp
+++ b/content/base/src/nsContentUtils.cpp
@@ -4487,17 +4487,26 @@ nsSameOriginChecker::OnChannelRedirect(nsIChannel *aOldChannel,
                                        PRUint32    aFlags)
 {
   NS_PRECONDITION(aNewChannel, """"Redirecting to null channel?"""");
+  if (!nsContentUtils::GetSecurityManager()) {
+    return NS_ERROR_NOT_AVAILABLE;
+  }
 
-  nsCOMPtr<nsIURI> oldURI;
-  nsresult rv = aOldChannel->GetURI(getter_AddRefs(oldURI)); // The original URI
-  NS_ENSURE_SUCCESS(rv, rv);
+  nsCOMPtr<nsIPrincipal> oldPrincipal;
+  nsContentUtils::GetSecurityManager()->
+    GetChannelPrincipal(aOldChannel, getter_AddRefs(oldPrincipal));
 
   nsCOMPtr<nsIURI> newURI;
-  rv = aNewChannel->GetURI(getter_AddRefs(newURI)); // The new URI
-  NS_ENSURE_SUCCESS(rv, rv);
+  aNewChannel->GetURI(getter_AddRefs(newURI));
+  nsCOMPtr<nsIURI> newOriginalURI;
+  aNewChannel->GetOriginalURI(getter_AddRefs(newOriginalURI));
 
-  return nsContentUtils::GetSecurityManager()->
-    CheckSameOriginURI(oldURI, newURI, PR_TRUE);
+  NS_ENSURE_STATE(oldPrincipal && newURI && newOriginalURI);
+
+  nsresult rv = oldPrincipal->CheckMayLoad(newURI, PR_FALSE);
+  if (NS_SUCCEEDED(rv) && newOriginalURI != newURI) {
+    rv = oldPrincipal->CheckMayLoad(newOriginalURI, PR_FALSE);
+  }
+  return rv;
 }
 
 NS_IMETHODIMP
diff --git a/content/base/src/nsCrossSiteListenerProxy.cpp b/content/base/src/nsCrossSiteListenerProxy.cpp
index ab48e85..03c5934 100644
--- a/content/base/src/nsCrossSiteListenerProxy.cpp
+++ b/content/base/src/nsCrossSiteListenerProxy.cpp
@@ -351,9 +351,11 @@ nsCrossSiteListenerProxy::OnChannelRedirect(nsIChannel *aOldChannel,
 nsresult
 nsCrossSiteListenerProxy::UpdateChannel(nsIChannel* aChannel)
 {
-  nsCOMPtr<nsIURI> uri;
+  nsCOMPtr<nsIURI> uri, originalURI;
   nsresult rv = aChannel->GetURI(getter_AddRefs(uri));
   NS_ENSURE_SUCCESS(rv, rv);
+  rv = aChannel->GetOriginalURI(getter_AddRefs(originalURI));
+  NS_ENSURE_SUCCESS(rv, rv);  
 
   // Check that the uri is ok to load
   rv = nsContentUtils::GetSecurityManager()->
@@ -361,8 +363,18 @@ nsCrossSiteListenerProxy::UpdateChannel(nsIChannel* aChannel)
                               nsIScriptSecurityManager::STANDARD);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  if (originalURI != uri) {
+    rv = nsContentUtils::GetSecurityManager()->
+      CheckLoadURIWithPrincipal(mRequestingPrincipal, originalURI,
+                                nsIScriptSecurityManager::STANDARD);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
   if (!mHasBeenCrossSite &&
-      NS_SUCCEEDED(mRequestingPrincipal->CheckMayLoad(uri, PR_FALSE))) {
+      NS_SUCCEEDED(mRequestingPrincipal->CheckMayLoad(uri, PR_FALSE)) &&
+      (originalURI == uri ||
+       NS_SUCCEEDED(mRequestingPrincipal->CheckMayLoad(originalURI,
+                                                       PR_FALSE)))) {
     return NS_OK;
   }
 
diff --git a/content/base/src/nsDocument.cpp b/content/base/src/nsDocument.cpp
index e25a56e..08d375f 100644
--- a/content/base/src/nsDocument.cpp
+++ b/content/base/src/nsDocument.cpp
@@ -1117,17 +1117,16 @@ nsExternalResourceMap::PendingLoad::StartLoad(nsIURI* aURI,
     return NS_ERROR_NOT_AVAILABLE;
   }
 
+  nsCOMPtr<nsIInterfaceRequestor> req = nsContentUtils::GetSameOriginChecker();
+  NS_ENSURE_TRUE(req, NS_ERROR_OUT_OF_MEMORY);
+
   nsCOMPtr<nsILoadGroup> loadGroup = doc->GetDocumentLoadGroup();
   nsCOMPtr<nsIChannel> channel;
-  rv = NS_NewChannel(getter_AddRefs(channel), aURI, nsnull, loadGroup);
+  rv = NS_NewChannel(getter_AddRefs(channel), aURI, nsnull, loadGroup, req);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mURI = aURI;
 
-  nsCOMPtr<nsIInterfaceRequestor> req = nsContentUtils::GetSameOriginChecker();
-  NS_ENSURE_TRUE(req, NS_ERROR_OUT_OF_MEMORY);
-
-  channel->SetNotificationCallbacks(req);
   return channel->AsyncOpen(this, nsnull);
 }
 
diff --git a/content/base/src/nsXMLHttpRequest.cpp b/content/base/src/nsXMLHttpRequest.cpp
index 6650a53..87d1e86 100644
--- a/content/base/src/nsXMLHttpRequest.cpp
+++ b/content/base/src/nsXMLHttpRequest.cpp
@@ -1738,11 +1738,16 @@ CheckMayLoad(nsIPrincipal* aPrincipal, nsIChannel* aChannel)
 {
   NS_ASSERTION(!IsSystemPrincipal(aPrincipal), """"Shouldn't get here!"""");
 
-  nsCOMPtr<nsIURI> channelURI;
+  nsCOMPtr<nsIURI> channelURI, originalURI;
   nsresult rv = aChannel->GetURI(getter_AddRefs(channelURI));
   NS_ENSURE_SUCCESS(rv, PR_FALSE);
+  rv = aChannel->GetOriginalURI(getter_AddRefs(originalURI));
+  NS_ENSURE_SUCCESS(rv, PR_FALSE);
 
   rv = aPrincipal->CheckMayLoad(channelURI, PR_FALSE);
+  if (NS_SUCCEEDED(rv) && originalURI != channelURI) {
+    rv = aPrincipal->CheckMayLoad(originalURI, PR_FALSE);
+  }
   return NS_SUCCEEDED(rv);
 }
 
diff --git a/content/xml/document/src/nsXMLDocument.cpp b/content/xml/document/src/nsXMLDocument.cpp
index ae798ed..3b9d15e 100644
--- a/content/xml/document/src/nsXMLDocument.cpp
+++ b/content/xml/document/src/nsXMLDocument.cpp
@@ -236,8 +236,6 @@ nsXMLDocument::~nsXMLDocument()
 // QueryInterface implementation for nsXMLDocument
 NS_INTERFACE_TABLE_HEAD(nsXMLDocument)
   NS_DOCUMENT_INTERFACE_TABLE_BEGIN(nsXMLDocument)
-    NS_INTERFACE_TABLE_ENTRY(nsXMLDocument, nsIInterfaceRequestor)
-    NS_INTERFACE_TABLE_ENTRY(nsXMLDocument, nsIChannelEventSink)
     NS_INTERFACE_TABLE_ENTRY(nsXMLDocument, nsIDOMXMLDocument)
   NS_OFFSET_AND_INTERFACE_TABLE_END
   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
@@ -277,35 +275,6 @@ nsXMLDocument::ResetToURI(nsIURI *aURI, nsILoadGroup *aLoadGroup,
   nsDocument::ResetToURI(aURI, aLoadGroup, aPrincipal);
 }
 
-/////////////////////////////////////////////////////
-// nsIInterfaceRequestor methods:
-//
-NS_IMETHODIMP
-nsXMLDocument::GetInterface(const nsIID& aIID, void** aSink)
-{
-  return QueryInterface(aIID, aSink);
-}
-
-// nsIChannelEventSink
-NS_IMETHODIMP
-nsXMLDocument::OnChannelRedirect(nsIChannel *aOldChannel,
-                                 nsIChannel *aNewChannel,
-                                 PRUint32 aFlags)
-{
-  NS_PRECONDITION(aNewChannel, """"Redirecting to null channel?"""");
-
-  nsCOMPtr<nsIURI> oldURI;
-  nsresult rv = aOldChannel->GetURI(getter_AddRefs(oldURI));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  nsCOMPtr<nsIURI> newURI;
-  rv = aNewChannel->GetURI(getter_AddRefs(newURI));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  return nsContentUtils::GetSecurityManager()->
-    CheckSameOriginURI(oldURI, newURI, PR_TRUE);
-}
-
 NS_IMETHODIMP
 nsXMLDocument::EvaluateFIXptr(const nsAString& aExpression, nsIDOMRange **aRange)
 {
@@ -438,11 +407,13 @@ nsXMLDocument::Load(const nsAString& aUrl, PRBool *aReturn)
   mListenerManager = elm;
 
   // Create a channel
+  nsCOMPtr<nsIInterfaceRequestor> req = nsContentUtils::GetSameOriginChecker();
+  NS_ENSURE_TRUE(req, NS_ERROR_OUT_OF_MEMORY);  
 
   nsCOMPtr<nsIChannel> channel;
   // nsIRequest::LOAD_BACKGROUND prevents throbber from becoming active,
   // which in turn keeps STOP button from becoming active  
-  rv = NS_NewChannel(getter_AddRefs(channel), uri, nsnull, loadGroup, this, 
+  rv = NS_NewChannel(getter_AddRefs(channel), uri, nsnull, loadGroup, req, 
                      nsIRequest::LOAD_BACKGROUND);
   if (NS_FAILED(rv)) {
     return rv;
diff --git a/content/xml/document/src/nsXMLDocument.h b/content/xml/document/src/nsXMLDocument.h
index c34c362..5bfbf4b 100644
--- a/content/xml/document/src/nsXMLDocument.h
+++ b/content/xml/document/src/nsXMLDocument.h
@@ -39,9 +39,6 @@
 #define nsXMLDocument_h___
 
 #include """"nsDocument.h""""
-#include """"nsIInterfaceRequestor.h""""
-#include """"nsIInterfaceRequestorUtils.h""""
-#include """"nsIChannelEventSink.h""""
 #include """"nsIDOMXMLDocument.h""""
 #include """"nsIScriptContext.h""""
 #include """"nsHTMLStyleSheet.h""""
@@ -52,9 +49,7 @@ class nsIDOMNode;
 class nsIURI;
 class nsIChannel;
 
-class nsXMLDocument : public nsDocument,
-                      public nsIInterfaceRequestor,
-                      public nsIChannelEventSink
+class nsXMLDocument : public nsDocument
 {
 public:
   nsXMLDocument(const char* aContentType = """"application/xml"""");
@@ -75,12 +70,6 @@ public:
 
   virtual void EndLoad();
 
-  // nsIInterfaceRequestor
-  NS_DECL_NSIINTERFACEREQUESTOR
-
-  // nsIHTTPEventSink
-  NS_DECL_NSICHANNELEVENTSINK
-
   // nsIDOMXMLDocument
   NS_DECL_NSIDOMXMLDOCUMENT
 
diff --git a/content/xml/document/test/test_bug392338.html b/content/xml/document/test/test_bug392338.html
index bf2dae1..0516bdb 100644
--- a/content/xml/document/test/test_bug392338.html
+++ b/content/xml/document/test/test_bug392338.html
@@ -30,36 +30,43 @@ function obs () {
 obs.prototype = {
   observe: function obs_observe (theSubject, theTopic, theData)
   {
+    this.timeToFinish = true;
     try{
       this.window.netscape.security
           .PrivilegeManager.enablePrivilege(""""UniversalXPConnect"""");
       var ir = theSubject.QueryInterface(this.window.Components.interfaces
                                              .nsIChannel).notificationCallbacks;
-      if (!(ir instanceof this.window.Components.interfaces.nsIDOMDocument)) {
+      if (!ir) {
+        this.timeToFinish = false;
         return;
       }
+      this.window.ok(true, """"No exception thrown"""");
 
       this.window.is(ir instanceof
                        this.window.Components.interfaces.nsIInterfaceRequestor,
                      true, """"Must be an interface requestor"""");
 
-      var count = {};
-      var interfaces = ir.
-                   QueryInterface(this.window.Components
-                                      .interfaces.nsIClassInfo).
-                   getInterfaces(count).
-                   map(function(id) {
-                              return this.window.Components
-                                                .interfacesByID[id].toString();
-                       });
-      this.window.isnot(interfaces.indexOf(""""nsIInterfaceRequestor""""), -1,
-                        """"Must have interface requestor classinfo"""");
+      if (ir instanceof this.window.Components.interfaces.nsIClassInfo) {
+        var count = {};
+        var interfaces = ir.
+                     QueryInterface(this.window.Components
+                                        .interfaces.nsIClassInfo).
+                     getInterfaces(count).
+                     map(function(id) {
+                                return this.window.Components
+                                                  .interfacesByID[id].toString();
+                         });
+        this.window.isnot(interfaces.indexOf(""""nsIInterfaceRequestor""""), -1,
+                          """"Must have interface requestor classinfo"""");
+      }
     } catch(ex) {
       this.window.is(true, false, """"Exception thrown """" + ex);
     } finally {
-      this.remove();
-      this.window.SimpleTest.finish();
-      this.window = null;
+      if (this.timeToFinish) {
+        this.remove();
+        this.window.SimpleTest.finish();
+        this.window = null;
+      }
     }
   },
 
diff --git a/docshell/base/nsWebShell.cpp b/docshell/base/nsWebShell.cpp
index 5d8a420..df94164 100644
--- a/docshell/base/nsWebShell.cpp
+++ b/docshell/base/nsWebShell.cpp
@@ -390,6 +390,8 @@ nsPingListener::OnChannelRedirect(nsIChannel *oldChan, nsIChannel *newChan,
   if (!mRequireSameHost)
     return NS_OK;
 
+  // XXXbz should this be using something more like the nsContentUtils
+  // same-origin checker?
   nsCOMPtr<nsIURI> oldURI;
   oldChan->GetURI(getter_AddRefs(oldURI));
   NS_ENSURE_STATE(oldURI && newURI);
diff --git a/dom/src/base/nsDOMClassInfo.cpp b/dom/src/base/nsDOMClassInfo.cpp
index fb8db86..ba5fcfa 100644
--- a/dom/src/base/nsDOMClassInfo.cpp
+++ b/dom/src/base/nsDOMClassInfo.cpp
@@ -2038,7 +2038,6 @@ nsDOMClassInfo::Init()
   DOM_CLASSINFO_MAP_BEGIN(XMLDocument, nsIDOMXMLDocument)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMDocument)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMXMLDocument)
-    DOM_CLASSINFO_MAP_ENTRY(nsIInterfaceRequestor)
     DOM_CLASSINFO_DOCUMENT_MAP_ENTRIES
   DOM_CLASSINFO_MAP_END
 
diff --git a/netwerk/base/src/nsBaseChannel.cpp b/netwerk/base/src/nsBaseChannel.cpp
index 3355100..a24ccdc 100644
--- a/netwerk/base/src/nsBaseChannel.cpp
+++ b/netwerk/base/src/nsBaseChannel.cpp
@@ -102,7 +102,6 @@ nsBaseChannel::Redirect(nsIChannel *newChannel, PRUint32 redirectFlags,
 
   // Transfer properties
 
-  newChannel->SetOriginalURI(OriginalURI());
   newChannel->SetLoadGroup(mLoadGroup);
   newChannel->SetNotificationCallbacks(mCallbacks);
   newChannel->SetLoadFlags(mLoadFlags | LOAD_REPLACE);
@@ -145,6 +144,9 @@ nsBaseChannel::Redirect(nsIChannel *newChannel, PRUint32 redirectFlags,
       return rv;
   }
 
+  // Make sure to do this _after_ making all the  OnChannelRedirect calls
+  newChannel->SetOriginalURI(OriginalURI());
+
   // If we fail to open the new channel, then we want to leave this channel
   // unaffected, so we defer tearing down our channel until we have succeeded
   // with the redirect.
diff --git a/netwerk/protocol/http/src/nsHttpChannel.cpp b/netwerk/protocol/http/src/nsHttpChannel.cpp
index 808b856..404d97e 100644
--- a/netwerk/protocol/http/src/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/src/nsHttpChannel.cpp
@@ -1133,6 +1133,9 @@ nsHttpChannel::DoReplaceWithProxy(nsIProxyInfo* pi)
     if (NS_FAILED(rv))
         return rv;
 
+    // Make sure to do this _after_ calling OnChannelRedirect
+    newChannel->SetOriginalURI(mOriginalURI);
+
     // open new channel
     rv = newChannel->AsyncOpen(mListener, mListenerContext);
     if (NS_FAILED(rv))
@@ -1463,6 +1466,9 @@ nsHttpChannel::ProcessFallback(PRBool *fallingBack)
     if (NS_FAILED(rv))
         return rv;
 
+    // Make sure to do this _after_ calling OnChannelRedirect
+    newChannel->SetOriginalURI(mOriginalURI);
+    
     rv = newChannel->AsyncOpen(mListener, mListenerContext);
     NS_ENSURE_SUCCESS(rv, rv);
 
@@ -2582,7 +2588,6 @@ nsHttpChannel::SetupReplacementChannel(nsIURI       *newURI,
     // Do not pass along LOAD_CHECK_OFFLINE_CACHE
     newLoadFlags &= ~LOAD_CHECK_OFFLINE_CACHE;
 
-    newChannel->SetOriginalURI(mOriginalURI);
     newChannel->SetLoadGroup(mLoadGroup); 
     newChannel->SetNotificationCallbacks(mCallbacks);
     newChannel->SetLoadFlags(newLoadFlags);
@@ -2763,6 +2768,9 @@ nsHttpChannel::ProcessRedirection(PRUint32 redirectType)
     if (NS_FAILED(rv))
         return rv;
 
+    // Make sure to do this _after_ calling OnChannelRedirect
+    newChannel->SetOriginalURI(mOriginalURI);    
+
     // And now, the deprecated way
     nsCOMPtr<nsIHttpEventSink> httpEventSink;
     GetCallback(httpEventSink);
diff --git a/uriloader/base/nsDocLoader.cpp b/uriloader/base/nsDocLoader.cpp
index 1879733..f579cb5 100644
--- a/uriloader/base/nsDocLoader.cpp
+++ b/uriloader/base/nsDocLoader.cpp
@@ -1487,15 +1487,6 @@ NS_IMETHODIMP nsDocLoader::OnChannelRedirect(nsIChannel *aOldChannel,
 {
   if (aOldChannel)
   {
-    nsresult rv;
-    nsCOMPtr<nsIURI> oldURI, newURI;
-
-    rv = aOldChannel->GetOriginalURI(getter_AddRefs(oldURI));
-    if (NS_FAILED(rv)) return rv;
-
-    rv = aNewChannel->GetURI(getter_AddRefs(newURI));
-    if (NS_FAILED(rv)) return rv;
-
     nsLoadFlags loadFlags = 0;
     PRInt32 stateFlags = nsIWebProgressListener::STATE_REDIRECTING |
                          nsIWebProgressListener::STATE_IS_REQUEST;"""
0c7385d706b39a3d2a8f080d8e6489c706884788,52468,452913,Igor Bukanov,"bug 452913 - fixing sprop management, r=brendan, a.9.1b2=sayer
",1226926779,"""diff --git a/js/src/jsgc.cpp b/js/src/jsgc.cpp
index 7d655e1..ac29021 100644
--- a/js/src/jsgc.cpp
+++ b/js/src/jsgc.cpp
@@ -3675,7 +3675,7 @@ out:
         goto restart;
     }
 
-    if (rt->shapeGen & SHAPE_OVERFLOW_BIT) {
+    if (rt->shapeGen >= SHAPE_OVERFLOW_BIT - 1) {
         /*
          * FIXME bug 440834: The shape id space has overflowed. Currently we
          * cope badly with this. Every call to js_GenerateShape does GC, and
diff --git a/js/src/jsinterp.cpp b/js/src/jsinterp.cpp
index 3695aa2..303a4cd 100644
--- a/js/src/jsinterp.cpp
+++ b/js/src/jsinterp.cpp
@@ -85,17 +85,22 @@
 #if !JS_LONE_INTERPRET ^ defined jsinvoke_cpp___
 
 uint32
-js_GenerateShape(JSContext *cx, JSBool gcLocked)
+js_GenerateShape(JSContext *cx, JSBool gcLocked, JSScopeProperty *sprop)
 {
     JSRuntime *rt;
     uint32 shape;
+    JSTempValueRooter tvr;
 
     rt = cx->runtime;
     shape = JS_ATOMIC_INCREMENT(&rt->shapeGen);
     JS_ASSERT(shape != 0);
     if (shape & SHAPE_OVERFLOW_BIT) {
         rt->gcPoke = JS_TRUE;
+        if (sprop)
+            JS_PUSH_TEMP_ROOT_SPROP(cx, sprop, &tvr);
         js_GC(cx, gcLocked ? GC_LOCK_HELD : GC_NORMAL);
+        if (sprop)
+            JS_POP_TEMP_ROOT(cx, &tvr);
         shape = JS_ATOMIC_INCREMENT(&rt->shapeGen);
         JS_ASSERT(shape != 0);
         JS_ASSERT_IF(shape & SHAPE_OVERFLOW_BIT,
diff --git a/js/src/jsinterp.h b/js/src/jsinterp.h
index eab3239..a016c47 100644
--- a/js/src/jsinterp.h
+++ b/js/src/jsinterp.h
@@ -198,8 +198,12 @@ typedef struct JSInlineFrame {
 
 #define SHAPE_OVERFLOW_BIT      JS_BIT(32 - PCVCAP_TAGBITS)
 
+/*
+ * When sprop is not null and the shape generation triggers the GC due to a
+ * shape overflow, the functions roots sprop.
+ */
 extern uint32
-js_GenerateShape(JSContext *cx, JSBool gcLocked);
+js_GenerateShape(JSContext *cx, JSBool gcLocked, JSScopeProperty *sprop);
 
 struct JSPropCacheEntry {
     jsbytecode          *kpc;           /* pc if vcap tag is <= 1, else atom */
diff --git a/js/src/jsscope.cpp b/js/src/jsscope.cpp
index c81b280..1f9bc0c 100644
--- a/js/src/jsscope.cpp
+++ b/js/src/jsscope.cpp
@@ -809,6 +809,7 @@ GetPropertyTreeChild(JSContext *cx, JSScopeProperty *parent,
     JSScopeProperty *sprop;
     PropTreeKidsChunk *chunk;
     uintN i, n;
+    uint32 shape;
 
     rt = cx->runtime;
     if (!parent) {
@@ -895,6 +896,12 @@ GetPropertyTreeChild(JSContext *cx, JSScopeProperty *parent,
     }
 
 locked_not_found:
+    /*
+     * Call js_GenerateShape before the allocation to prevent collecting the
+     * new property when the shape generation triggers the GC.
+     */
+    shape = js_GenerateShape(cx, JS_TRUE, NULL);
+
     sprop = NewScopeProperty(rt);
     if (!sprop)
         goto out_of_memory;
@@ -907,7 +914,7 @@ locked_not_found:
     sprop->flags = child->flags;
     sprop->shortid = child->shortid;
     sprop->parent = sprop->kids = NULL;
-    sprop->shape = js_GenerateShape(cx, JS_TRUE);
+    sprop->shape = shape;
 
     if (!parent) {
         entry->child = sprop;
diff --git a/js/src/jsscope.h b/js/src/jsscope.h
index 53676b7..b7d8455 100644
--- a/js/src/jsscope.h
+++ b/js/src/jsscope.h
@@ -221,7 +221,7 @@ JS_STATIC_ASSERT(offsetof(JSScope, title) == sizeof(JSObjectMap));
 #define OBJ_SHAPE(obj)                  (OBJ_SCOPE(obj)->shape)
 
 #define SCOPE_MAKE_UNIQUE_SHAPE(cx,scope)                                     \
-    ((scope)->shape = js_GenerateShape((cx), JS_FALSE))
+    ((scope)->shape = js_GenerateShape((cx), JS_FALSE, NULL))
 
 #define SCOPE_EXTEND_SHAPE(cx,scope,sprop)                                    \
     JS_BEGIN_MACRO                                                            \
@@ -229,7 +229,7 @@ JS_STATIC_ASSERT(offsetof(JSScope, title) == sizeof(JSObjectMap));
             (scope)->shape == (scope)->lastProp->shape) {                     \
             (scope)->shape = (sprop)->shape;                                  \
         } else {                                                              \
-            (scope)->shape = js_GenerateShape((cx), JS_FALSE);                \
+            (scope)->shape = js_GenerateShape((cx), JS_FALSE, sprop);         \
         }                                                                     \
     JS_END_MACRO
 """
6d2ce01f6047d8edb26998c6d6b9523558d5d824,52608,452979,Vladimir Vukicevic,"Putting back 452979, wasn't the problem.
",1226532004,"""diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
index c75db51..ea74403 100644
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -2095,6 +2095,11 @@ function losslessDecodeURI(aURI) {
                          encodeURIComponent);
     } catch (e) {}
 
+  // Encode invisible characters (invisible control characters, soft hyphen,
+  // zero-width space, BOM, line separator, paragraph separator) (bug 452979)
+  value = value.replace(/[\v\x0c\x1c\x1d\x1e\x1f\u00ad\u200b\ufeff\u2028\u2029]/g,
+                        encodeURIComponent);
+
   // Encode bidirectional formatting characters.
   // (RFC 3987 sections 3.2 and 4.1 paragraph 6)
   value = value.replace(/[\u200e\u200f\u202a\u202b\u202c\u202d\u202e]/g,"""
87223c4b64a2473af3ebefa76ce763ed41b93e37,52609,452979,Vladimir Vukicevic,"Backing out bug 452979, in attempt to fix bustage
",1226531137,"""diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
index ea74403..c75db51 100644
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -2095,11 +2095,6 @@ function losslessDecodeURI(aURI) {
                          encodeURIComponent);
     } catch (e) {}
 
-  // Encode invisible characters (invisible control characters, soft hyphen,
-  // zero-width space, BOM, line separator, paragraph separator) (bug 452979)
-  value = value.replace(/[\v\x0c\x1c\x1d\x1e\x1f\u00ad\u200b\ufeff\u2028\u2029]/g,
-                        encodeURIComponent);
-
   // Encode bidirectional formatting characters.
   // (RFC 3987 sections 3.2 and 4.1 paragraph 6)
   value = value.replace(/[\u200e\u200f\u202a\u202b\u202c\u202d\u202e]/g,"""
c2e6d86a562bf46a0fea63e60074ddeb3e505e4f,52623,452979,Masayuki Nakano,"Bug 452979 p=Masahiro Yamada <masa141421356@gmail.com>, r=gavin, a=beltzner
",1226507091,"""diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
index c75db51..ea74403 100644
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -2095,6 +2095,11 @@ function losslessDecodeURI(aURI) {
                          encodeURIComponent);
     } catch (e) {}
 
+  // Encode invisible characters (invisible control characters, soft hyphen,
+  // zero-width space, BOM, line separator, paragraph separator) (bug 452979)
+  value = value.replace(/[\v\x0c\x1c\x1d\x1e\x1f\u00ad\u200b\ufeff\u2028\u2029]/g,
+                        encodeURIComponent);
+
   // Encode bidirectional formatting characters.
   // (RFC 3987 sections 3.2 and 4.1 paragraph 6)
   value = value.replace(/[\u200e\u200f\u202a\u202b\u202c\u202d\u202e]/g,"""
e16d1912457eefc69346519664e09c766218629a,52673,461735,Boris Zbarsky,"Bug 461735.  Use the final channel URI as the script URI.  r+sr=jst, a=beltzner
",1226351370,"""diff --git a/content/base/src/nsScriptLoader.cpp b/content/base/src/nsScriptLoader.cpp
index f40e082..8bdb753 100644
--- a/content/base/src/nsScriptLoader.cpp
+++ b/content/base/src/nsScriptLoader.cpp
@@ -108,6 +108,7 @@ public:
   nsString mScriptText;              // Holds script for loaded scripts
   PRUint32 mJSVersion;
   nsCOMPtr<nsIURI> mURI;
+  nsCOMPtr<nsIURI> mFinalURI;
   PRInt32 mLineNo;
 };
 
@@ -624,11 +625,10 @@ nsScriptLoader::EvaluateScript(nsScriptLoadRequest* aRequest,
 
   nsCAutoString url;
 
-  if (aRequest->mURI) {
-    rv = aRequest->mURI->GetSpec(url);
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
+  nsIURI* uri = aRequest->mFinalURI ? aRequest->mFinalURI : aRequest->mURI;
+  rv = uri->GetSpec(url);
+  if (NS_FAILED(rv)) {
+    return rv;
   }
 
   PRBool oldProcessingScriptTag = context->GetProcessingScriptTag();
@@ -912,6 +912,7 @@ nsScriptLoader::PrepareLoadedRequest(nsScriptLoadRequest* aRequest,
   }
 
   nsCOMPtr<nsIChannel> channel = do_QueryInterface(req);
+  NS_GetFinalChannelURI(channel, getter_AddRefs(aRequest->mFinalURI));
   if (aStringLen) {
     // Check the charset attribute to determine script charset.
     nsAutoString hintCharset;
diff --git a/content/base/test/Makefile.in b/content/base/test/Makefile.in
index 4028db1..d917e38 100644
--- a/content/base/test/Makefile.in
+++ b/content/base/test/Makefile.in
@@ -254,6 +254,10 @@ _TEST_FILES = 	test_bug5141.html \
 		file_XHRDocURI.text \
 		file_XHRDocURI.text^headers^ \
 		test_bug459424.html \
+		bug461735-redirect1.sjs \
+		bug461735-redirect2.sjs \
+		bug461735-post-redirect.js \
+		test_bug461735.html \
 		$(NULL)
 
 # Disabled for now. Mochitest isn't reliable enough for these.
diff --git a/content/base/test/bug461735-post-redirect.js b/content/base/test/bug461735-post-redirect.js
new file mode 100644
index 0000000..bae1963
--- /dev/null
+++ b/content/base/test/bug461735-post-redirect.js
@@ -0,0 +1,3 @@
+var a = 0;
+var b = 0;
+c();
\ No newline at end of file
diff --git a/content/base/test/bug461735-redirect1.sjs b/content/base/test/bug461735-redirect1.sjs
new file mode 100644
index 0000000..a3f0078
--- /dev/null
+++ b/content/base/test/bug461735-redirect1.sjs
@@ -0,0 +1,4 @@
+function handleRequest(request, response) {
+  response.setStatusLine(null, 302, """"Found"""");
+  response.setHeader(""""Location"""", """"http://example.com/tests/content/base/test/bug461735-post-redirect.js"""", false);
+}
diff --git a/content/base/test/bug461735-redirect2.sjs b/content/base/test/bug461735-redirect2.sjs
new file mode 100644
index 0000000..9f2118c
--- /dev/null
+++ b/content/base/test/bug461735-redirect2.sjs
@@ -0,0 +1,4 @@
+function handleRequest(request, response) {
+  response.setStatusLine(null, 302, """"Found"""");
+  response.setHeader(""""Location"""", """"http://localhost:8888/tests/content/base/test/bug461735-post-redirect.js"""", false);
+}
diff --git a/content/base/test/test_bug461735.html b/content/base/test/test_bug461735.html
new file mode 100644
index 0000000..7761c7a
--- /dev/null
+++ b/content/base/test/test_bug461735.html
@@ -0,0 +1,37 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=461735
+-->
+<head>
+  <title>Test for Bug 461735</title>
+  <script type=""""application/javascript"""" src=""""/MochiKit/MochiKit.js""""></script>
+  <script type=""""application/javascript"""" src=""""/tests/SimpleTest/SimpleTest.js""""></script>
+  <link rel=""""stylesheet"""" type=""""text/css"""" href=""""/tests/SimpleTest/test.css""""/>
+</head>
+<body>
+<a target=""""_blank"""" href=""""https://bugzilla.mozilla.org/show_bug.cgi?id=461735"""">Mozilla Bug 461735</a>
+<p id=""""display""""></p>
+<div id=""""content"""" style=""""display: none"""">
+  
+</div>
+<pre id=""""test"""">
+<script type=""""application/javascript"""">
+window.onerror = function(message, uri, line) {
+  is(message, """"Script error."""", """"Should have empty error message"""");
+  is(uri, """"http://example.com/tests/content/base/test/bug461735-post-redirect.js"""", """"Unexpected error location URI"""");
+  is(line, 0, """"Shouldn't have a line here"""");
+}
+</script>
+<script src=""""bug461735-redirect1.sjs""""></script>
+<script type=""""application/javascript"""">
+window.onerror = function(message, uri, line) {
+  is(message, """"c is not defined"""", """"Should have correct error message"""");
+  is(uri, """"http://localhost:8888/tests/content/base/test/bug461735-post-redirect.js"""", """"Unexpected error location URI"""");
+  is(line, 3, """"Should have a line here"""");
+}
+</script>
+<script src=""""bug461735-redirect2.sjs""""></script>
+</pre>
+</body>
+</html>"""
0091e94157547094f2e25524f026a6257a83ed51,53408,443299,Daniel Veditz,"bug 443299: prevent potential OOM dos and null-deref crash. Patch by Justin Schuh, r=cbiesinger, sr=dveditz
",1224892061,"""diff --git a/netwerk/streamconv/converters/nsDirIndexParser.cpp b/netwerk/streamconv/converters/nsDirIndexParser.cpp
index 41b50fe..0927ee6 100644
--- a/netwerk/streamconv/converters/nsDirIndexParser.cpp
+++ b/netwerk/streamconv/converters/nsDirIndexParser.cpp
@@ -190,6 +190,10 @@ nsDirIndexParser::ParseFormat(const char* aFormatStr) {
       ++pos;
     
     ++num;
+    // There are a maximum of six allowed header fields (doubled plus
+    // terminator, just in case) -- Bug 443299
+    if (num > (2 * NS_ARRAY_LENGTH(gFieldTable)))
+      return NS_ERROR_UNEXPECTED;
 
     if (! *pos)
       break;
@@ -200,6 +204,9 @@ nsDirIndexParser::ParseFormat(const char* aFormatStr) {
   } while (*pos);
 
   mFormat = new int[num+1];
+  // Prevent NULL Deref - Bug 443299 
+  if (mFormat == nsnull)
+    return NS_ERROR_OUT_OF_MEMORY;
   mFormat[num] = -1;
   
   int formatNum=0;"""
30c4563edce57e551d694bfab2d2509f4460571e,53410,455987,Daniel Veditz,"bug 455987 crash fix, r/sr=bsmedberg
",1224890133,"""diff --git a/browser/components/places/src/nsPlacesImportExportService.cpp b/browser/components/places/src/nsPlacesImportExportService.cpp
index 97a44ce..38da788 100644
--- a/browser/components/places/src/nsPlacesImportExportService.cpp
+++ b/browser/components/places/src/nsPlacesImportExportService.cpp
@@ -241,62 +241,67 @@ public:
 char *
 nsEscapeHTML(const char * string)
 {
-	/* XXX Hardcoded max entity len. The +1 is for the trailing null. */
-	char *rv = (char *) nsMemory::Alloc(strlen(string) * 6 + 1);
-	char *ptr = rv;
-
-	if(rv)
-	  {
-		for(; *string != '\0'; string++)
-		  {
-			if(*string == '<')
-			  {
-				*ptr++ = '&';
-				*ptr++ = 'l';
-				*ptr++ = 't';
-				*ptr++ = ';';
-			  }
-			else if(*string == '>')
-			  {
-				*ptr++ = '&';
-				*ptr++ = 'g';
-				*ptr++ = 't';
-				*ptr++ = ';';
-			  }
-			else if(*string == '&')
-			  {
-				*ptr++ = '&';
-				*ptr++ = 'a';
-				*ptr++ = 'm';
-				*ptr++ = 'p';
-				*ptr++ = ';';
-			  }
-			else if (*string == '""""')
-			  {
-				*ptr++ = '&';
-				*ptr++ = 'q';
-				*ptr++ = 'u';
-				*ptr++ = 'o';
-				*ptr++ = 't';
-				*ptr++ = ';';
-			  }			
-			else if (*string == '\'')
-			  {
-				*ptr++ = '&';
-				*ptr++ = '#';
-				*ptr++ = '3';
-				*ptr++ = '9';
-				*ptr++ = ';';
-			  }
-			else
-			  {
-				*ptr++ = *string;
-			  }
-		  }
-		*ptr = '\0';
-	  }
-
-	return(rv);
+    /* XXX Hardcoded max entity len. The +1 is for the trailing null. */
+    char *rv = nsnull;
+    PRUint32 len = strlen(string);
+    if (len >= (PR_UINT32_MAX / 6))
+      return nsnull;
+
+    rv = (char *) NS_Alloc((len * 6) + 1);
+    char *ptr = rv;
+
+    if(rv)
+      {
+        for(; *string != '\0'; string++)
+          {
+            if(*string == '<')
+              {
+                *ptr++ = '&';
+                *ptr++ = 'l';
+                *ptr++ = 't';
+                *ptr++ = ';';
+              }
+            else if(*string == '>')
+              {
+                *ptr++ = '&';
+                *ptr++ = 'g';
+                *ptr++ = 't';
+                *ptr++ = ';';
+              }
+            else if(*string == '&')
+              {
+                *ptr++ = '&';
+                *ptr++ = 'a';
+                *ptr++ = 'm';
+                *ptr++ = 'p';
+                *ptr++ = ';';
+              }
+            else if (*string == '""""')
+              {
+                *ptr++ = '&';
+                *ptr++ = 'q';
+                *ptr++ = 'u';
+                *ptr++ = 'o';
+                *ptr++ = 't';
+                *ptr++ = ';';
+              }            
+            else if (*string == '\'')
+              {
+                *ptr++ = '&';
+                *ptr++ = '#';
+                *ptr++ = '3';
+                *ptr++ = '9';
+                *ptr++ = ';';
+              }
+            else
+              {
+                *ptr++ = *string;
+              }
+          }
+        *ptr = '\0';
+      }
+
+    return(rv);
 }
 
 NS_IMPL_ISUPPORTS2(nsPlacesImportExportService, nsIPlacesImportExportService,
diff --git a/xpcom/io/nsEscape.cpp b/xpcom/io/nsEscape.cpp
index 704ee50..ebe7715 100644
--- a/xpcom/io/nsEscape.cpp
+++ b/xpcom/io/nsEscape.cpp
@@ -222,62 +222,67 @@ NS_COM PRInt32 nsUnescapeCount(char * str)
 NS_COM char *
 nsEscapeHTML(const char * string)
 {
-	/* XXX Hardcoded max entity len. The +1 is for the trailing null. */
-	char *rv = (char *) nsMemory::Alloc(strlen(string) * 6 + 1);
-	char *ptr = rv;
-
-	if(rv)
-	  {
-		for(; *string != '\0'; string++)
-		  {
-			if(*string == '<')
-			  {
-				*ptr++ = '&';
-				*ptr++ = 'l';
-				*ptr++ = 't';
-				*ptr++ = ';';
-			  }
-			else if(*string == '>')
-			  {
-				*ptr++ = '&';
-				*ptr++ = 'g';
-				*ptr++ = 't';
-				*ptr++ = ';';
-			  }
-			else if(*string == '&')
-			  {
-				*ptr++ = '&';
-				*ptr++ = 'a';
-				*ptr++ = 'm';
-				*ptr++ = 'p';
-				*ptr++ = ';';
-			  }
-			else if (*string == '""""')
-			  {
-				*ptr++ = '&';
-				*ptr++ = 'q';
-				*ptr++ = 'u';
-				*ptr++ = 'o';
-				*ptr++ = 't';
-				*ptr++ = ';';
-			  }			
-			else if (*string == '\'')
-			  {
-				*ptr++ = '&';
-				*ptr++ = '#';
-				*ptr++ = '3';
-				*ptr++ = '9';
-				*ptr++ = ';';
-			  }
-			else
-			  {
-				*ptr++ = *string;
-			  }
-		  }
-		*ptr = '\0';
-	  }
-
-	return(rv);
+    char *rv = nsnull;
+    /* XXX Hardcoded max entity len. The +1 is for the trailing null. */
+    PRUint32 len = PL_strlen(string);
+    if (len >= (PR_UINT32_MAX / 6))
+      return nsnull;
+
+    rv = (char *)NS_Alloc( (6 * len) + 1 );
+    char *ptr = rv;
+
+    if(rv)
+      {
+        for(; *string != '\0'; string++)
+          {
+            if(*string == '<')
+              {
+                *ptr++ = '&';
+                *ptr++ = 'l';
+                *ptr++ = 't';
+                *ptr++ = ';';
+              }
+            else if(*string == '>')
+              {
+                *ptr++ = '&';
+                *ptr++ = 'g';
+                *ptr++ = 't';
+                *ptr++ = ';';
+              }
+            else if(*string == '&')
+              {
+                *ptr++ = '&';
+                *ptr++ = 'a';
+                *ptr++ = 'm';
+                *ptr++ = 'p';
+                *ptr++ = ';';
+              }
+            else if (*string == '""""')
+              {
+                *ptr++ = '&';
+                *ptr++ = 'q';
+                *ptr++ = 'u';
+                *ptr++ = 'o';
+                *ptr++ = 't';
+                *ptr++ = ';';
+              }
+            else if (*string == '\'')
+              {
+                *ptr++ = '&';
+                *ptr++ = '#';
+                *ptr++ = '3';
+                *ptr++ = '9';
+                *ptr++ = ';';
+              }
+            else
+              {
+                *ptr++ = *string;
+              }
+          }
+        *ptr = '\0';
+      }
+
+    return(rv);
 }
 
 NS_COM PRUnichar *
@@ -289,6 +294,10 @@ nsEscapeHTML2(const PRUnichar *aSourceBuffer, PRInt32 aSourceBufferLen)
   }
 
   /* XXX Hardcoded max entity len. */
+  if (aSourceBufferLen >=
+      ((PR_UINT32_MAX / (6 * sizeof(PRUnichar))) + sizeof(PRUnichar)))
+    return nsnull;
+
   PRUnichar *resultBuffer = (PRUnichar *)nsMemory::Alloc(aSourceBufferLen *
                             6 * sizeof(PRUnichar) + sizeof(PRUnichar('\0')));
   PRUnichar *ptr = resultBuffer;"""
08325408e7dfc28c52e54b5eff8e1d4879fdc0f1,53476,455311,Boris Zbarsky,"Bug 455311.  Better handling of a successful redirect.  r+sr=biesi pending
",1224726195,"""diff --git a/netwerk/base/src/nsBaseChannel.cpp b/netwerk/base/src/nsBaseChannel.cpp
index 7d4f2ad..3355100 100644
--- a/netwerk/base/src/nsBaseChannel.cpp
+++ b/netwerk/base/src/nsBaseChannel.cpp
@@ -253,16 +253,19 @@ void
 nsBaseChannel::HandleAsyncRedirect(nsIChannel* newChannel)
 {
   NS_ASSERTION(!mPump, """"Shouldn't have gotten here"""");
+  PRBool doNotify = PR_TRUE;
   if (NS_SUCCEEDED(mStatus)) {
       nsresult rv = Redirect(newChannel, nsIChannelEventSink::REDIRECT_INTERNAL,
                              PR_TRUE);
       if (NS_FAILED(rv))
           Cancel(rv);
+      else
+          doNotify = PR_FALSE;
   }
 
   mWaitingOnAsyncRedirect = PR_FALSE;
 
-  if (NS_FAILED(mStatus)) {
+  if (doNotify) {
     // Notify our consumer ourselves
     mListener->OnStartRequest(this, mListenerContext);
     mListener->OnStopRequest(this, mListenerContext, mStatus);"""
58395126668e15a69e84d897b57766b4e913405f,53509,455311,Boris Zbarsky,"Bug 455311.  Better handling of Cancel and IsPending() on nsBaseChannel redirects, plus unit tests.  r+sr=biesi
",1224690152,"""diff --git a/netwerk/base/src/nsBaseChannel.cpp b/netwerk/base/src/nsBaseChannel.cpp
index df453e9..7d4f2ad 100644
--- a/netwerk/base/src/nsBaseChannel.cpp
+++ b/netwerk/base/src/nsBaseChannel.cpp
@@ -89,6 +89,7 @@ nsBaseChannel::nsBaseChannel()
   , mQueriedProgressSink(PR_TRUE)
   , mSynthProgressEvents(PR_FALSE)
   , mWasOpened(PR_FALSE)
+  , mWaitingOnAsyncRedirect(PR_FALSE)
 {
   mContentType.AssignLiteral(UNKNOWN_CONTENT_TYPE);
 }
@@ -227,8 +228,12 @@ nsBaseChannel::BeginPumpingData()
 
   NS_ASSERTION(!stream || !channel, """"Got both a channel and a stream?"""");
 
-  if (channel)
-      return NS_DispatchToCurrentThread(new RedirectRunnable(this, channel));
+  if (channel) {
+      rv = NS_DispatchToCurrentThread(new RedirectRunnable(this, channel));
+      if (NS_SUCCEEDED(rv))
+          mWaitingOnAsyncRedirect = PR_TRUE;
+      return rv;
+  }
 
   // By assigning mPump, we flag this channel as pending (see IsPending).  It's
   // important that the pending flag is set when we call into the stream (the
@@ -248,11 +253,17 @@ void
 nsBaseChannel::HandleAsyncRedirect(nsIChannel* newChannel)
 {
   NS_ASSERTION(!mPump, """"Shouldn't have gotten here"""");
-  nsresult rv = Redirect(newChannel, nsIChannelEventSink::REDIRECT_INTERNAL,
-                         PR_TRUE);
-  if (NS_FAILED(rv)) {
+  if (NS_SUCCEEDED(mStatus)) {
+      nsresult rv = Redirect(newChannel, nsIChannelEventSink::REDIRECT_INTERNAL,
+                             PR_TRUE);
+      if (NS_FAILED(rv))
+          Cancel(rv);
+  }
+
+  mWaitingOnAsyncRedirect = PR_FALSE;
+
+  if (NS_FAILED(mStatus)) {
     // Notify our consumer ourselves
-    Cancel(rv);
     mListener->OnStartRequest(this, mListenerContext);
     mListener->OnStopRequest(this, mListenerContext, mStatus);
     mListener = nsnull;
diff --git a/netwerk/base/src/nsBaseChannel.h b/netwerk/base/src/nsBaseChannel.h
index 6878e8c..4b0dd42 100644
--- a/netwerk/base/src/nsBaseChannel.h
+++ b/netwerk/base/src/nsBaseChannel.h
@@ -179,7 +179,7 @@ public:
 
   // This is a short-cut to calling nsIRequest::IsPending()
   PRBool IsPending() const {
-    return (mPump != nsnull);
+    return mPump || mWaitingOnAsyncRedirect;
   }
 
   // Set the content length that should be reported for this channel.  Pass -1
@@ -285,6 +285,7 @@ private:
   PRPackedBool                        mQueriedProgressSink;
   PRPackedBool                        mSynthProgressEvents;
   PRPackedBool                        mWasOpened;
+  PRPackedBool                        mWaitingOnAsyncRedirect;
 };
 
 #endif // !nsBaseChannel_h__
diff --git a/netwerk/test/unit/test_bug455311.js b/netwerk/test/unit/test_bug455311.js
new file mode 100644
index 0000000..962e977
--- /dev/null
+++ b/netwerk/test/unit/test_bug455311.js
@@ -0,0 +1,124 @@
+const Ci = Components.interfaces;
+const Cc = Components.classes;
+const Cr = Components.results;
+const isWindows = (""""@mozilla.org/windows-registry-key;1"""" in Cc);
+const isLinux = (""""@mozilla.org/gnome-gconf-service;1"""" in Cc);
+
+function getLinkFile()
+{
+  if (isWindows) {
+    return do_get_file(""""netwerk/test/unit/test_link.url"""");
+  }
+  if (isLinux) {
+    return do_get_file(""""netwerk/test/unit/test_link.desktop"""");
+  }
+  do_throw(""""Unexpected platform"""");
+  return null;
+}
+
+const ios = Cc[""""@mozilla.org/network/io-service;1""""].getService(Ci.nsIIOService);
+const link = getLinkFile();
+const linkURI = ios.newFileURI(link);
+const newURI = ios.newURI(""""http://www.mozilla.org/"""", null, null);
+  
+function NotificationCallbacks(origURI, newURI)
+{
+    this._origURI = origURI;
+  this._newURI = newURI;
+}
+NotificationCallbacks.prototype = {
+  QueryInterface: function(iid)
+  {
+    if (iid.equals(Ci.nsISupports) ||
+	iid.equals(Ci.nsIInterfaceRequestor) ||
+	iid.equals(Ci.nsIChannelEventSink)) {
+      return this;
+    }
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  },
+  getInterface: function (iid)
+  {
+    return this.QueryInterface(iid);
+  },
+  onChannelRedirect: function(oldChan, newChan, flags)
+  {
+    do_check_eq(oldChan.URI.spec, this._origURI.spec);
+    do_check_eq(oldChan.URI, this._origURI);
+    do_check_eq(oldChan.originalURI.spec, this._origURI.spec);
+    do_check_eq(oldChan.originalURI, this._origURI);
+    do_check_eq(newChan.originalURI.spec, this._origURI.spec);
+    do_check_eq(newChan.originalURI, this._origURI);
+    do_check_eq(newChan.URI.spec, this._newURI.spec);
+    throw Cr.NS_ERROR_ABORT;
+  }
+};
+
+function RequestObserver(origURI, newURI, nextTest)
+{
+  this._origURI = origURI;
+  this._newURI = newURI;
+  this._nextTest = nextTest;
+}
+RequestObserver.prototype = {
+  QueryInterface: function(iid)
+  {
+    if (iid.equals(Ci.nsISupports) ||
+	iid.equals(Ci.nsIRequestObserver) ||
+	iid.equals(Ci.nsIStreamListener)) {
+      return this;
+    }
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  },
+  onStartRequest: function (req, ctx)
+  {
+    var chan = req.QueryInterface(Ci.nsIChannel);
+    do_check_eq(chan.URI.spec, this._origURI.spec);
+    do_check_eq(chan.URI, this._origURI);
+    do_check_eq(chan.originalURI.spec, this._origURI.spec);
+    do_check_eq(chan.originalURI, this._origURI);
+  },
+  onDataAvailable: function(req, ctx, stream, offset, count)
+  {
+    do_throw(""""Unexpected call to onDataAvailable"""");
+  },
+  onStopRequest: function (req, ctx, status)
+  {
+    var chan = req.QueryInterface(Ci.nsIChannel);
+    try {
+      do_check_eq(chan.URI.spec, this._origURI.spec);
+      do_check_eq(chan.URI, this._origURI);
+      do_check_eq(chan.originalURI.spec, this._origURI.spec);
+      do_check_eq(chan.originalURI, this._origURI);
+      do_check_eq(status, Cr.NS_ERROR_ABORT);
+      do_check_false(chan.isPending());
+    } catch(e) {}
+    this._nextTest();
+  }
+};
+
+function test_cancel()
+{
+  var chan = ios.newChannelFromURI(linkURI);
+  do_check_eq(chan.URI, linkURI);
+  do_check_eq(chan.originalURI, linkURI);
+  chan.asyncOpen(new RequestObserver(linkURI, newURI, do_test_finished), null);
+  do_check_true(chan.isPending());
+  chan.cancel(Cr.NS_ERROR_ABORT);
+  do_check_true(chan.isPending());
+}
+
+function run_test()
+{
+  if (!isWindows && !isLinux) {
+    return;
+  }
+
+  do_test_pending();
+
+  var chan = ios.newChannelFromURI(linkURI);
+  do_check_eq(chan.URI, linkURI);
+  do_check_eq(chan.originalURI, linkURI);
+  chan.notificationCallbacks = new NotificationCallbacks(linkURI, newURI);
+  chan.asyncOpen(new RequestObserver(linkURI, newURI, test_cancel), null);
+  do_check_true(chan.isPending());
+}
diff --git a/netwerk/test/unit/test_file_protocol.js b/netwerk/test/unit/test_file_protocol.js
index 577bbfd..208d85c 100644
--- a/netwerk/test/unit/test_file_protocol.js
+++ b/netwerk/test/unit/test_file_protocol.js
@@ -69,9 +69,9 @@ FileStreamListener.prototype = {
   },
 
   QueryInterface: function(iid) {
-    if (iid.Equals(Ci.nsIStreamListener) ||
-        iid.Equals(Ci.nsIRequestObserver) ||
-        iid.Equals(Ci.nsISupports))
+    if (iid.equals(Ci.nsIStreamListener) ||
+        iid.equals(Ci.nsIRequestObserver) ||
+        iid.equals(Ci.nsISupports))
       return this;
     throw Cr.NS_ERROR_NO_INTERFACE;
   },
diff --git a/netwerk/test/unit/test_gzipped_206.js b/netwerk/test/unit/test_gzipped_206.js
index 5fe79c1..cfc9dc3 100644
--- a/netwerk/test/unit/test_gzipped_206.js
+++ b/netwerk/test/unit/test_gzipped_206.js
@@ -52,9 +52,9 @@ function Canceler() {
 
 Canceler.prototype = {
   QueryInterface: function(iid) {
-    if (iid.Equals(Ci.nsIStreamListener) ||
-        iid.Equals(Ci.nsIRequestObserver) ||
-        iid.Equals(Ci.nsISupports))
+    if (iid.equals(Ci.nsIStreamListener) ||
+        iid.equals(Ci.nsIRequestObserver) ||
+        iid.equals(Ci.nsISupports))
       return this;
     throw Components.results.NS_ERROR_NO_INTERFACE;
   },
diff --git a/netwerk/test/unit/test_link.desktop b/netwerk/test/unit/test_link.desktop
new file mode 100644
index 0000000..b179820
--- /dev/null
+++ b/netwerk/test/unit/test_link.desktop
@@ -0,0 +1,3 @@
+[Desktop Entry]
+Type=Link
+URL=http://www.mozilla.org/
diff --git a/netwerk/test/unit/test_link.url b/netwerk/test/unit/test_link.url
new file mode 100644
index 0000000..05f8275
--- /dev/null
+++ b/netwerk/test/unit/test_link.url
@@ -0,0 +1,5 @@
+[InternetShortcut]
+URL=http://www.mozilla.org/
+IDList=
+[{000214A0-0000-0000-C000-000000000046}]
+Prop3=19,2
diff --git a/netwerk/test/unit/test_resumable_truncate.js b/netwerk/test/unit/test_resumable_truncate.js
index 9336ec3..ed8313e 100644
--- a/netwerk/test/unit/test_resumable_truncate.js
+++ b/netwerk/test/unit/test_resumable_truncate.js
@@ -45,9 +45,9 @@ function Canceler(continueFn) {
 
 Canceler.prototype = {
   QueryInterface: function(iid) {
-    if (iid.Equals(Ci.nsIStreamListener) ||
-        iid.Equals(Ci.nsIRequestObserver) ||
-        iid.Equals(Ci.nsISupports))
+    if (iid.equals(Ci.nsIStreamListener) ||
+        iid.equals(Ci.nsIRequestObserver) ||
+        iid.equals(Ci.nsISupports))
       return this;
     throw Components.results.NS_ERROR_NO_INTERFACE;
   },"""
8c6cb3ead51490b126b9bc460897e4a685abad4a,53736,424733,Boris Zbarsky,"Bug 424733.  Be a little more careful with certificate principals.  r+sr=sicking
",1224292088,"""diff --git a/content/xbl/src/nsXBLBinding.cpp b/content/xbl/src/nsXBLBinding.cpp
index 1b27c0a..ecefd72 100644
--- a/content/xbl/src/nsXBLBinding.cpp
+++ b/content/xbl/src/nsXBLBinding.cpp
@@ -1373,7 +1373,21 @@ nsXBLBinding::AllowScripts()
   PRBool canExecute;
   nsresult rv =
     mgr->CanExecuteScripts(cx, ourDocument->NodePrincipal(), &canExecute);
-  return NS_SUCCEEDED(rv) && canExecute;
+  if (NS_FAILED(rv) || !canExecute) {
+    return PR_FALSE;
+  }
+
+  // Now one last check: make sure that we're not allowing a privilege
+  // escalation here.
+  PRBool haveCert;
+  doc->NodePrincipal()->GetHasCertificate(&haveCert);
+  if (!haveCert) {
+    return PR_TRUE;
+  }
+
+  PRBool subsumes;
+  rv = ourDocument->NodePrincipal()->Subsumes(doc->NodePrincipal(), &subsumes);
+  return NS_SUCCEEDED(rv) && subsumes;
 }
 
 void"""
051b48b61e8d65f685a11c4cdee32b8e82664653,53874,453915,Brian Crowder,"Bug 453915 -- XML namespace escaping improvement, r=igor
",1224017945,"""diff --git a/js/src/jsxml.cpp b/js/src/jsxml.cpp
index dc8523f..f42db88 100644
--- a/js/src/jsxml.cpp
+++ b/js/src/jsxml.cpp
@@ -1835,8 +1835,8 @@ ParseXMLSource(JSContext *cx, JSString *src)
     JSXMLArray nsarray;
     uintN flags;
 
-    static const char prefix[] = """"<parent xmlns='"""";
-    static const char middle[] = """"'>"""";
+    static const char prefix[] = """"<parent xmlns=\"""""""";
+    static const char middle[] = """"\"""">"""";
     static const char suffix[] = """"</parent>"""";
 
 #define constrlen(constr)   (sizeof(constr) - 1)
@@ -1844,6 +1844,7 @@ ParseXMLSource(JSContext *cx, JSString *src)
     if (!js_GetDefaultXMLNamespace(cx, &nsval))
         return NULL;
     uri = GetURI(JSVAL_TO_OBJECT(nsval));
+    uri = js_EscapeAttributeValue(cx, uri, JS_FALSE);
 
     urilen = JSSTRING_LENGTH(uri);
     srclen = JSSTRING_LENGTH(src);"""
3b8dc08a96d2d6124fd045ecd1bbce208ec4e895,53979,458883,Phil Ringnalda,"Bug 458883, r+sr=bzbarsky
",1223847720,"""diff --git a/modules/libpref/src/init/all.js b/modules/libpref/src/init/all.js
index 84154e1..5428b21 100644
--- a/modules/libpref/src/init/all.js
+++ b/modules/libpref/src/init/all.js
@@ -357,6 +357,8 @@ pref(""""capability.policy.mailnews.*.data.get"""", """"noAccess"""");
 pref(""""capability.policy.mailnews.*.getAttribute"""", """"noAccess"""");
 pref(""""capability.policy.mailnews.HTMLDivElement.getAttribute"""", """"sameOrigin"""");
 pref(""""capability.policy.mailnews.*.getAttributeNS"""", """"noAccess"""");
+pref(""""capability.policy.mailnews.*.getAttributeNode"""", """"noAccess"""");
+pref(""""capability.policy.mailnews.*.getAttributeNodeNS"""", """"noAccess"""");
 pref(""""capability.policy.mailnews.*.getNamedItem"""", """"noAccess"""");
 pref(""""capability.policy.mailnews.*.getNamedItemNS"""", """"noAccess"""");
 pref(""""capability.policy.mailnews.*.host.get"""", """"noAccess"""");
@@ -370,11 +372,13 @@ pref(""""capability.policy.mailnews.*.protocol.get"""", """"noAccess"""");
 pref(""""capability.policy.mailnews.*.src.get"""", """"noAccess"""");
 pref(""""capability.policy.mailnews.*.substringData.get"""", """"noAccess"""");
 pref(""""capability.policy.mailnews.*.text.get"""", """"noAccess"""");
+pref(""""capability.policy.mailnews.*.textContent"""", """"noAccess"""");
 pref(""""capability.policy.mailnews.*.title.get"""", """"noAccess"""");
 pref(""""capability.policy.mailnews.DOMException.toString"""", """"noAccess"""");
 pref(""""capability.policy.mailnews.HTMLAnchorElement.toString"""", """"noAccess"""");
 pref(""""capability.policy.mailnews.HTMLDocument.domain"""", """"noAccess"""");
 pref(""""capability.policy.mailnews.HTMLDocument.URL"""", """"noAccess"""");
+pref(""""capability.policy.mailnews.*.documentURI"""", """"noAccess"""");
 pref(""""capability.policy.mailnews.Location.toString"""", """"noAccess"""");
 pref(""""capability.policy.mailnews.Range.toString"""", """"noAccess"""");
 pref(""""capability.policy.mailnews.Window.blur"""", """"noAccess"""");"""
97b6a844a27d70c0a16af0594302076259cc66f9,54076,458679,Igor Bukanov,"bug 458679 - r=crowder
",1223644587,"""diff --git a/js/src/jsscan.cpp b/js/src/jsscan.cpp
index c5cb57d..664dd16 100644
--- a/js/src/jsscan.cpp
+++ b/js/src/jsscan.cpp
@@ -814,6 +814,8 @@ GetXMLEntity(JSContext *cx, JSTokenStream *ts)
     /* Put the entity, including the '&' already scanned, in ts->tokenbuf. */
     offset = PTRDIFF(ts->tokenbuf.ptr, ts->tokenbuf.base, jschar);
     FastAppendChar(&ts->tokenbuf, '&');
+    if (!STRING_BUFFER_OK(&ts->tokenbuf))
+        return JS_FALSE;
     while ((c = GetChar(ts)) != ';') {
         if (c == EOF || c == '\n') {
             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
@@ -821,6 +823,8 @@ GetXMLEntity(JSContext *cx, JSTokenStream *ts)
             return JS_FALSE;
         }
         FastAppendChar(&ts->tokenbuf, (jschar) c);
+        if (!STRING_BUFFER_OK(&ts->tokenbuf))
+            return JS_FALSE;
     }
 
     /* Let length be the number of jschars after the '&', including the ';'. */
@@ -906,6 +910,8 @@ badncr:
     msg = JSMSG_BAD_XML_NCR;
 bad:
     /* No match: throw a TypeError per ECMA-357 10.3.2.1 step 8(a). */
+    JS_ASSERT(STRING_BUFFER_OK(&ts->tokenbuf));
+    JS_ASSERT(PTRDIFF(ts->tokenbuf.ptr, bp, jschar) >= 1);
     bytes = js_DeflateString(cx, bp + 1,
                              PTRDIFF(ts->tokenbuf.ptr, bp, jschar) - 1);
     if (bytes) {"""
bf5449d14246b6fd151297aefa3eefe5c41401a3,54249,455311,L. David Baron,"Merge backout of changeset 6357eb31cec6 (bug 455311) for causing performance regression bug 458065.
",1223261777,"""diff --git a/netwerk/base/src/nsBaseChannel.cpp b/netwerk/base/src/nsBaseChannel.cpp
index 333ae29..fd5030e 100644
--- a/netwerk/base/src/nsBaseChannel.cpp
+++ b/netwerk/base/src/nsBaseChannel.cpp
@@ -62,7 +62,7 @@ class ScopedRequestSuspender {
 public:
   ScopedRequestSuspender(nsIRequest *request)
     : mRequest(request) {
-    if (mRequest && NS_FAILED(mRequest->Suspend())) {
+    if (NS_FAILED(mRequest->Suspend())) {
       NS_WARNING(""""Couldn't suspend pump"""");
       mRequest = nsnull;
     }
@@ -94,8 +94,7 @@ nsBaseChannel::nsBaseChannel()
 }
 
 nsresult
-nsBaseChannel::Redirect(nsIChannel *newChannel, PRUint32 redirectFlags,
-                        PRBool openNewChannel)
+nsBaseChannel::Redirect(nsIChannel *newChannel, PRUint32 redirectFlags)
 {
   SUSPEND_PUMP_FOR_SCOPE();
 
@@ -148,11 +147,9 @@ nsBaseChannel::Redirect(nsIChannel *newChannel, PRUint32 redirectFlags,
   // unaffected, so we defer tearing down our channel until we have succeeded
   // with the redirect.
 
-  if (openNewChannel) {
-    rv = newChannel->AsyncOpen(mListener, mListenerContext);
-    if (NS_FAILED(rv))
-      return rv;
-  }
+  rv = newChannel->AsyncOpen(mListener, mListenerContext);
+  if (NS_FAILED(rv))
+    return rv;
 
   // close down this channel
   Cancel(NS_BINDING_REDIRECTED);
@@ -219,17 +216,10 @@ nsresult
 nsBaseChannel::BeginPumpingData()
 {
   nsCOMPtr<nsIInputStream> stream;
-  nsCOMPtr<nsIChannel> channel;
-  nsresult rv = OpenContentStream(PR_TRUE, getter_AddRefs(stream),
-                                  getter_AddRefs(channel));
+  nsresult rv = OpenContentStream(PR_TRUE, getter_AddRefs(stream));
   if (NS_FAILED(rv))
     return rv;
 
-  NS_ASSERTION(!stream || !channel, """"Got both a channel and a stream?"""");
-
-  if (channel)
-      return NS_DispatchToCurrentThread(new RedirectRunnable(this, channel));
-
   // By assigning mPump, we flag this channel as pending (see IsPending).  It's
   // important that the pending flag is set when we call into the stream (the
   // call to AsyncRead results in the stream's AsyncWait method being called)
@@ -244,29 +234,6 @@ nsBaseChannel::BeginPumpingData()
   return rv;
 }
 
-void
-nsBaseChannel::HandleAsyncRedirect(nsIChannel* newChannel)
-{
-  NS_ASSERTION(!mPump, """"Shouldn't have gotten here"""");
-  nsresult rv = Redirect(newChannel, nsIChannelEventSink::REDIRECT_INTERNAL,
-                         PR_TRUE);
-  if (NS_FAILED(rv)) {
-    // Notify our consumer ourselves
-    Cancel(rv);
-    mListener->OnStartRequest(this, mListenerContext);
-    mListener->OnStopRequest(this, mListenerContext, mStatus);
-    mListener = nsnull;
-    mListenerContext = nsnull;
-  }
-
-  if (mLoadGroup)
-    mLoadGroup->RemoveRequest(this, nsnull, mStatus);
-
-  // Drop notification callbacks to prevent cycles.
-  mCallbacks = nsnull;
-  CallbacksChanged();
-}
-
 //-----------------------------------------------------------------------------
 // nsBaseChannel::nsISupports
 
@@ -484,15 +451,8 @@ nsBaseChannel::Open(nsIInputStream **result)
   NS_ENSURE_TRUE(!mPump, NS_ERROR_IN_PROGRESS);
   NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_IN_PROGRESS);
 
-  nsCOMPtr<nsIChannel> chan;
-  nsresult rv = OpenContentStream(PR_FALSE, result, getter_AddRefs(chan));
-  NS_ASSERTION(!chan || !*result, """"Got both a channel and a stream?"""");
-  if (NS_SUCCEEDED(rv) && chan) {
-      rv = Redirect(chan, nsIChannelEventSink::REDIRECT_INTERNAL, PR_FALSE);
-      if (NS_FAILED(rv))
-          return rv;
-      rv = chan->Open(result);
-  } else if (rv == NS_ERROR_NOT_IMPLEMENTED)
+  nsresult rv = OpenContentStream(PR_FALSE, result);
+  if (rv == NS_ERROR_NOT_IMPLEMENTED)
     return NS_ImplementChannelOpen(this, result);
 
   mWasOpened = NS_SUCCEEDED(rv);
diff --git a/netwerk/base/src/nsBaseChannel.h b/netwerk/base/src/nsBaseChannel.h
index 14f840e..4ead1b8 100644
--- a/netwerk/base/src/nsBaseChannel.h
+++ b/netwerk/base/src/nsBaseChannel.h
@@ -52,7 +52,6 @@
 #include """"nsIInterfaceRequestor.h""""
 #include """"nsIProgressEventSink.h""""
 #include """"nsITransport.h""""
-#include """"nsThreadUtils.h""""
 
 //-----------------------------------------------------------------------------
 // nsBaseChannel is designed to be subclassed.  The subclass is responsible for
@@ -104,12 +103,7 @@ private:
   // need to implement ReadSegments.  If async is false, this method may return
   // NS_ERROR_NOT_IMPLEMENTED to cause the basechannel to implement Open in
   // terms of AsyncOpen (see NS_ImplementChannelOpen).
-  // A callee is allowed to return an nsIChannel instead of an nsIInputStream.
-  // That case will be treated as a redirect to the new channel.  By default
-  // *channel will be set to null by the caller, so callees who don't want to
-  // return one an just not touch it.
-  virtual nsresult OpenContentStream(PRBool async, nsIInputStream **stream,
-                                     nsIChannel** channel) = 0;
+  virtual nsresult OpenContentStream(PRBool async, nsIInputStream **stream) = 0;
 
   // The basechannel calls this method from its OnTransportStatus method to
   // determine whether to call nsIProgressEventSink::OnStatus in addition to
@@ -132,14 +126,12 @@ public:
   // Methods provided for use by the derived class:
 
   // Redirect to another channel.  This method takes care of notifying
-  // observers of this redirect as well as of opening the new channel, if asked
-  // to do so.  It also cancels |this| with the status code
-  // NS_BINDING_REDIRECTED.  A failure return from this method means that the
-  // redirect could not be performed (no channel was opened; this channel
-  // wasn't canceled.)  The redirectFlags parameter consists of the flag values
-  // defined on nsIChannelEventSink.
-  nsresult Redirect(nsIChannel *newChannel, PRUint32 redirectFlags,
-                    PRBool openNewChannel);
+  // observers of this redirect as well as of opening the new channel.  It also
+  // cancels |this| with the status code NS_BINDING_REDIRECTED.  A failure
+  // return from this method means that the redirect could not be performed (no
+  // channel was opened; this channel wasn't canceled.)  The redirectFlags
+  // parameter consists of the flag values defined on nsIChannelEventSink.
+  nsresult Redirect(nsIChannel *newChannel, PRUint32 redirectFlags);
 
   // Tests whether a type hint was set. Subclasses can use this to decide
   // whether to call SetContentType.
@@ -241,31 +233,6 @@ private:
     OnCallbacksChanged();
   }
 
-  // Handle an async redirect callback.  This will only be called if we
-  // returned success from AsyncOpen while posting a redirect runnable.
-  void HandleAsyncRedirect(nsIChannel* newChannel);
-
-  class RedirectRunnable : public nsRunnable
-  {
-  public:
-    RedirectRunnable(nsBaseChannel* chan, nsIChannel* newChannel)
-      : mChannel(chan), mNewChannel(newChannel)
-    {
-      NS_PRECONDITION(newChannel, """"Must have channel to redirect to"""");
-    }
-    
-    NS_IMETHOD Run()
-    {
-      mChannel->HandleAsyncRedirect(mNewChannel);
-      return NS_OK;
-    }
-
-  private:
-    nsRefPtr<nsBaseChannel> mChannel;
-    nsCOMPtr<nsIChannel> mNewChannel;
-  };
-  friend class RedirectRunnable;
-
   nsRefPtr<nsInputStreamPump>         mPump;
   nsCOMPtr<nsIInterfaceRequestor>     mCallbacks;
   nsCOMPtr<nsIProgressEventSink>      mProgressSink;
diff --git a/netwerk/base/src/nsInputStreamChannel.cpp b/netwerk/base/src/nsInputStreamChannel.cpp
index fd35b9d..0a32e67 100644
--- a/netwerk/base/src/nsInputStreamChannel.cpp
+++ b/netwerk/base/src/nsInputStreamChannel.cpp
@@ -41,8 +41,7 @@
 // nsInputStreamChannel
 
 nsresult
-nsInputStreamChannel::OpenContentStream(PRBool async, nsIInputStream **result,
-                                        nsIChannel** channel)
+nsInputStreamChannel::OpenContentStream(PRBool async, nsIInputStream **result)
 {
   NS_ENSURE_TRUE(mContentStream, NS_ERROR_NOT_INITIALIZED);
 
diff --git a/netwerk/base/src/nsInputStreamChannel.h b/netwerk/base/src/nsInputStreamChannel.h
index a3aad38..7d374d5 100644
--- a/netwerk/base/src/nsInputStreamChannel.h
+++ b/netwerk/base/src/nsInputStreamChannel.h
@@ -55,8 +55,7 @@ public:
 protected:
     virtual ~nsInputStreamChannel() {}
 
-    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
-                                       nsIChannel** channel);
+    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
 
 private:
     nsCOMPtr<nsIInputStream> mContentStream;
diff --git a/netwerk/protocol/data/src/nsDataChannel.cpp b/netwerk/protocol/data/src/nsDataChannel.cpp
index fa63c9f..106e51e 100644
--- a/netwerk/protocol/data/src/nsDataChannel.cpp
+++ b/netwerk/protocol/data/src/nsDataChannel.cpp
@@ -51,8 +51,7 @@
 #include """"prmem.h""""
 
 nsresult
-nsDataChannel::OpenContentStream(PRBool async, nsIInputStream **result,
-                                 nsIChannel** channel)
+nsDataChannel::OpenContentStream(PRBool async, nsIInputStream **result)
 {
     NS_ENSURE_TRUE(URI(), NS_ERROR_NOT_INITIALIZED);
 
diff --git a/netwerk/protocol/data/src/nsDataChannel.h b/netwerk/protocol/data/src/nsDataChannel.h
index 5543be9..c6534a3 100644
--- a/netwerk/protocol/data/src/nsDataChannel.h
+++ b/netwerk/protocol/data/src/nsDataChannel.h
@@ -52,8 +52,7 @@ public:
     }
 
 protected:
-    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
-                                       nsIChannel** channel);
+    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
 };
 
 #endif /* nsDataChannel_h___ */
diff --git a/netwerk/protocol/file/src/nsFileChannel.cpp b/netwerk/protocol/file/src/nsFileChannel.cpp
index 2fff61d..7513f44 100644
--- a/netwerk/protocol/file/src/nsFileChannel.cpp
+++ b/netwerk/protocol/file/src/nsFileChannel.cpp
@@ -307,8 +307,7 @@ nsFileChannel::MakeFileInputStream(nsIFile *file,
 }
 
 nsresult
-nsFileChannel::OpenContentStream(PRBool async, nsIInputStream **result,
-                                 nsIChannel** channel)
+nsFileChannel::OpenContentStream(PRBool async, nsIInputStream **result)
 {
   // NOTE: the resulting file is a clone, so it is safe to pass it to the
   //       file input stream which will be read on a background thread.
@@ -317,24 +316,6 @@ nsFileChannel::OpenContentStream(PRBool async, nsIInputStream **result,
   if (NS_FAILED(rv))
     return rv;
 
-  nsCOMPtr<nsIFileProtocolHandler> fileHandler;
-  rv = NS_GetFileProtocolHandler(getter_AddRefs(fileHandler));
-  if (NS_FAILED(rv))
-    return rv;
-    
-  nsCOMPtr<nsIURI> newURI;
-  rv = fileHandler->ReadURLFile(file, getter_AddRefs(newURI));
-  if (NS_SUCCEEDED(rv)) {
-    nsCOMPtr<nsIChannel> newChannel;
-    rv = NS_NewChannel(getter_AddRefs(newChannel), newURI);
-    if (NS_FAILED(rv))
-      return rv;
-
-    *result = nsnull;
-    newChannel.forget(channel);
-    return NS_OK;
-  }
-
   nsCOMPtr<nsIInputStream> stream;
 
   if (mUploadStream) {
diff --git a/netwerk/protocol/file/src/nsFileChannel.h b/netwerk/protocol/file/src/nsFileChannel.h
index be9cbfb..cc559ab 100644
--- a/netwerk/protocol/file/src/nsFileChannel.h
+++ b/netwerk/protocol/file/src/nsFileChannel.h
@@ -65,8 +65,7 @@ protected:
   nsresult MakeFileInputStream(nsIFile *file, nsCOMPtr<nsIInputStream> &stream,
                                nsCString &contentType);
 
-  virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
-                                     nsIChannel** channel);
+  virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
 
 private:
   nsCOMPtr<nsIInputStream> mUploadStream;
diff --git a/netwerk/protocol/file/src/nsFileProtocolHandler.cpp b/netwerk/protocol/file/src/nsFileProtocolHandler.cpp
index b7189a1b..29f5fcf 100644
--- a/netwerk/protocol/file/src/nsFileProtocolHandler.cpp
+++ b/netwerk/protocol/file/src/nsFileProtocolHandler.cpp
@@ -278,12 +278,30 @@ nsFileProtocolHandler::NewURI(const nsACString &spec,
 NS_IMETHODIMP
 nsFileProtocolHandler::NewChannel(nsIURI *uri, nsIChannel **result)
 {
+    nsresult rv;
+
+    // This file may be a url file
+    nsCOMPtr<nsIFileURL> url(do_QueryInterface(uri));
+    if (url) {
+        nsCOMPtr<nsIFile> file;
+        rv = url->GetFile(getter_AddRefs(file));
+        if (NS_SUCCEEDED(rv)) {
+            nsCOMPtr<nsIURI> uri;
+            rv = ReadURLFile(file, getter_AddRefs(uri));
+            if (NS_SUCCEEDED(rv)) {
+                rv = NS_NewChannel(result, uri);
+                if (NS_SUCCEEDED(rv))
+                    return rv;
+            }
+        }
+    }
+
     nsFileChannel *chan = new nsFileChannel(uri);
     if (!chan)
         return NS_ERROR_OUT_OF_MEMORY;
     NS_ADDREF(chan);
 
-    nsresult rv = chan->Init();
+    rv = chan->Init();
     if (NS_FAILED(rv)) {
         NS_RELEASE(chan);
         return rv;
diff --git a/netwerk/protocol/ftp/src/nsFTPChannel.cpp b/netwerk/protocol/ftp/src/nsFTPChannel.cpp
index 7bc4743..688ebcb 100644
--- a/netwerk/protocol/ftp/src/nsFTPChannel.cpp
+++ b/netwerk/protocol/ftp/src/nsFTPChannel.cpp
@@ -143,8 +143,7 @@ nsFtpChannel::GetProxyInfo(nsIProxyInfo** aProxyInfo)
 //-----------------------------------------------------------------------------
 
 nsresult
-nsFtpChannel::OpenContentStream(PRBool async, nsIInputStream **result,
-                                nsIChannel** channel)
+nsFtpChannel::OpenContentStream(PRBool async, nsIInputStream **result)
 {
     if (!async)
         return NS_ERROR_NOT_IMPLEMENTED;
diff --git a/netwerk/protocol/ftp/src/nsFTPChannel.h b/netwerk/protocol/ftp/src/nsFTPChannel.h
index 314337e..bec6464 100644
--- a/netwerk/protocol/ftp/src/nsFTPChannel.h
+++ b/netwerk/protocol/ftp/src/nsFTPChannel.h
@@ -117,8 +117,7 @@ public:
 
 protected:
     virtual ~nsFtpChannel() {}
-    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
-                                       nsIChannel** channel);
+    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
     virtual PRBool GetStatusArg(nsresult status, nsString &statusArg);
     virtual void OnCallbacksChanged();
 
diff --git a/netwerk/protocol/gopher/src/nsGopherChannel.cpp b/netwerk/protocol/gopher/src/nsGopherChannel.cpp
index 317d73b..d3fd802 100644
--- a/netwerk/protocol/gopher/src/nsGopherChannel.cpp
+++ b/netwerk/protocol/gopher/src/nsGopherChannel.cpp
@@ -469,8 +469,7 @@ nsGopherChannel::GetProxyInfo(nsIProxyInfo** aProxyInfo)
 }
 
 nsresult
-nsGopherChannel::OpenContentStream(PRBool async, nsIInputStream **result,
-                                   nsIChannel** channel)
+nsGopherChannel::OpenContentStream(PRBool async, nsIInputStream **result)
 {
     // Implement nsIChannel::Open in terms of nsIChannel::AsyncOpen
     if (!async)
diff --git a/netwerk/protocol/gopher/src/nsGopherChannel.h b/netwerk/protocol/gopher/src/nsGopherChannel.h
index ba9bcca..4cfe9d8 100644
--- a/netwerk/protocol/gopher/src/nsGopherChannel.h
+++ b/netwerk/protocol/gopher/src/nsGopherChannel.h
@@ -59,8 +59,7 @@ public:
 protected:
     virtual ~nsGopherChannel() {}
 
-    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
-                                       nsIChannel** channel);
+    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
     virtual PRBool GetStatusArg(nsresult status, nsString &statusArg);
 
 private:"""
ffc367bf741e802bb69242db172c166eb10f653e,54250,455311,L. David Baron,"Backed out changeset 6357eb31cec6 (bug 455311) for causing performance regression bug 458065.
",1223261741,"""diff --git a/netwerk/base/src/nsBaseChannel.cpp b/netwerk/base/src/nsBaseChannel.cpp
index 333ae29..fd5030e 100644
--- a/netwerk/base/src/nsBaseChannel.cpp
+++ b/netwerk/base/src/nsBaseChannel.cpp
@@ -62,7 +62,7 @@ class ScopedRequestSuspender {
 public:
   ScopedRequestSuspender(nsIRequest *request)
     : mRequest(request) {
-    if (mRequest && NS_FAILED(mRequest->Suspend())) {
+    if (NS_FAILED(mRequest->Suspend())) {
       NS_WARNING(""""Couldn't suspend pump"""");
       mRequest = nsnull;
     }
@@ -94,8 +94,7 @@ nsBaseChannel::nsBaseChannel()
 }
 
 nsresult
-nsBaseChannel::Redirect(nsIChannel *newChannel, PRUint32 redirectFlags,
-                        PRBool openNewChannel)
+nsBaseChannel::Redirect(nsIChannel *newChannel, PRUint32 redirectFlags)
 {
   SUSPEND_PUMP_FOR_SCOPE();
 
@@ -148,11 +147,9 @@ nsBaseChannel::Redirect(nsIChannel *newChannel, PRUint32 redirectFlags,
   // unaffected, so we defer tearing down our channel until we have succeeded
   // with the redirect.
 
-  if (openNewChannel) {
-    rv = newChannel->AsyncOpen(mListener, mListenerContext);
-    if (NS_FAILED(rv))
-      return rv;
-  }
+  rv = newChannel->AsyncOpen(mListener, mListenerContext);
+  if (NS_FAILED(rv))
+    return rv;
 
   // close down this channel
   Cancel(NS_BINDING_REDIRECTED);
@@ -219,17 +216,10 @@ nsresult
 nsBaseChannel::BeginPumpingData()
 {
   nsCOMPtr<nsIInputStream> stream;
-  nsCOMPtr<nsIChannel> channel;
-  nsresult rv = OpenContentStream(PR_TRUE, getter_AddRefs(stream),
-                                  getter_AddRefs(channel));
+  nsresult rv = OpenContentStream(PR_TRUE, getter_AddRefs(stream));
   if (NS_FAILED(rv))
     return rv;
 
-  NS_ASSERTION(!stream || !channel, """"Got both a channel and a stream?"""");
-
-  if (channel)
-      return NS_DispatchToCurrentThread(new RedirectRunnable(this, channel));
-
   // By assigning mPump, we flag this channel as pending (see IsPending).  It's
   // important that the pending flag is set when we call into the stream (the
   // call to AsyncRead results in the stream's AsyncWait method being called)
@@ -244,29 +234,6 @@ nsBaseChannel::BeginPumpingData()
   return rv;
 }
 
-void
-nsBaseChannel::HandleAsyncRedirect(nsIChannel* newChannel)
-{
-  NS_ASSERTION(!mPump, """"Shouldn't have gotten here"""");
-  nsresult rv = Redirect(newChannel, nsIChannelEventSink::REDIRECT_INTERNAL,
-                         PR_TRUE);
-  if (NS_FAILED(rv)) {
-    // Notify our consumer ourselves
-    Cancel(rv);
-    mListener->OnStartRequest(this, mListenerContext);
-    mListener->OnStopRequest(this, mListenerContext, mStatus);
-    mListener = nsnull;
-    mListenerContext = nsnull;
-  }
-
-  if (mLoadGroup)
-    mLoadGroup->RemoveRequest(this, nsnull, mStatus);
-
-  // Drop notification callbacks to prevent cycles.
-  mCallbacks = nsnull;
-  CallbacksChanged();
-}
-
 //-----------------------------------------------------------------------------
 // nsBaseChannel::nsISupports
 
@@ -484,15 +451,8 @@ nsBaseChannel::Open(nsIInputStream **result)
   NS_ENSURE_TRUE(!mPump, NS_ERROR_IN_PROGRESS);
   NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_IN_PROGRESS);
 
-  nsCOMPtr<nsIChannel> chan;
-  nsresult rv = OpenContentStream(PR_FALSE, result, getter_AddRefs(chan));
-  NS_ASSERTION(!chan || !*result, """"Got both a channel and a stream?"""");
-  if (NS_SUCCEEDED(rv) && chan) {
-      rv = Redirect(chan, nsIChannelEventSink::REDIRECT_INTERNAL, PR_FALSE);
-      if (NS_FAILED(rv))
-          return rv;
-      rv = chan->Open(result);
-  } else if (rv == NS_ERROR_NOT_IMPLEMENTED)
+  nsresult rv = OpenContentStream(PR_FALSE, result);
+  if (rv == NS_ERROR_NOT_IMPLEMENTED)
     return NS_ImplementChannelOpen(this, result);
 
   mWasOpened = NS_SUCCEEDED(rv);
diff --git a/netwerk/base/src/nsBaseChannel.h b/netwerk/base/src/nsBaseChannel.h
index 14f840e..4ead1b8 100644
--- a/netwerk/base/src/nsBaseChannel.h
+++ b/netwerk/base/src/nsBaseChannel.h
@@ -52,7 +52,6 @@
 #include """"nsIInterfaceRequestor.h""""
 #include """"nsIProgressEventSink.h""""
 #include """"nsITransport.h""""
-#include """"nsThreadUtils.h""""
 
 //-----------------------------------------------------------------------------
 // nsBaseChannel is designed to be subclassed.  The subclass is responsible for
@@ -104,12 +103,7 @@ private:
   // need to implement ReadSegments.  If async is false, this method may return
   // NS_ERROR_NOT_IMPLEMENTED to cause the basechannel to implement Open in
   // terms of AsyncOpen (see NS_ImplementChannelOpen).
-  // A callee is allowed to return an nsIChannel instead of an nsIInputStream.
-  // That case will be treated as a redirect to the new channel.  By default
-  // *channel will be set to null by the caller, so callees who don't want to
-  // return one an just not touch it.
-  virtual nsresult OpenContentStream(PRBool async, nsIInputStream **stream,
-                                     nsIChannel** channel) = 0;
+  virtual nsresult OpenContentStream(PRBool async, nsIInputStream **stream) = 0;
 
   // The basechannel calls this method from its OnTransportStatus method to
   // determine whether to call nsIProgressEventSink::OnStatus in addition to
@@ -132,14 +126,12 @@ public:
   // Methods provided for use by the derived class:
 
   // Redirect to another channel.  This method takes care of notifying
-  // observers of this redirect as well as of opening the new channel, if asked
-  // to do so.  It also cancels |this| with the status code
-  // NS_BINDING_REDIRECTED.  A failure return from this method means that the
-  // redirect could not be performed (no channel was opened; this channel
-  // wasn't canceled.)  The redirectFlags parameter consists of the flag values
-  // defined on nsIChannelEventSink.
-  nsresult Redirect(nsIChannel *newChannel, PRUint32 redirectFlags,
-                    PRBool openNewChannel);
+  // observers of this redirect as well as of opening the new channel.  It also
+  // cancels |this| with the status code NS_BINDING_REDIRECTED.  A failure
+  // return from this method means that the redirect could not be performed (no
+  // channel was opened; this channel wasn't canceled.)  The redirectFlags
+  // parameter consists of the flag values defined on nsIChannelEventSink.
+  nsresult Redirect(nsIChannel *newChannel, PRUint32 redirectFlags);
 
   // Tests whether a type hint was set. Subclasses can use this to decide
   // whether to call SetContentType.
@@ -241,31 +233,6 @@ private:
     OnCallbacksChanged();
   }
 
-  // Handle an async redirect callback.  This will only be called if we
-  // returned success from AsyncOpen while posting a redirect runnable.
-  void HandleAsyncRedirect(nsIChannel* newChannel);
-
-  class RedirectRunnable : public nsRunnable
-  {
-  public:
-    RedirectRunnable(nsBaseChannel* chan, nsIChannel* newChannel)
-      : mChannel(chan), mNewChannel(newChannel)
-    {
-      NS_PRECONDITION(newChannel, """"Must have channel to redirect to"""");
-    }
-    
-    NS_IMETHOD Run()
-    {
-      mChannel->HandleAsyncRedirect(mNewChannel);
-      return NS_OK;
-    }
-
-  private:
-    nsRefPtr<nsBaseChannel> mChannel;
-    nsCOMPtr<nsIChannel> mNewChannel;
-  };
-  friend class RedirectRunnable;
-
   nsRefPtr<nsInputStreamPump>         mPump;
   nsCOMPtr<nsIInterfaceRequestor>     mCallbacks;
   nsCOMPtr<nsIProgressEventSink>      mProgressSink;
diff --git a/netwerk/base/src/nsInputStreamChannel.cpp b/netwerk/base/src/nsInputStreamChannel.cpp
index fd35b9d..0a32e67 100644
--- a/netwerk/base/src/nsInputStreamChannel.cpp
+++ b/netwerk/base/src/nsInputStreamChannel.cpp
@@ -41,8 +41,7 @@
 // nsInputStreamChannel
 
 nsresult
-nsInputStreamChannel::OpenContentStream(PRBool async, nsIInputStream **result,
-                                        nsIChannel** channel)
+nsInputStreamChannel::OpenContentStream(PRBool async, nsIInputStream **result)
 {
   NS_ENSURE_TRUE(mContentStream, NS_ERROR_NOT_INITIALIZED);
 
diff --git a/netwerk/base/src/nsInputStreamChannel.h b/netwerk/base/src/nsInputStreamChannel.h
index a3aad38..7d374d5 100644
--- a/netwerk/base/src/nsInputStreamChannel.h
+++ b/netwerk/base/src/nsInputStreamChannel.h
@@ -55,8 +55,7 @@ public:
 protected:
     virtual ~nsInputStreamChannel() {}
 
-    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
-                                       nsIChannel** channel);
+    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
 
 private:
     nsCOMPtr<nsIInputStream> mContentStream;
diff --git a/netwerk/protocol/data/src/nsDataChannel.cpp b/netwerk/protocol/data/src/nsDataChannel.cpp
index fa63c9f..106e51e 100644
--- a/netwerk/protocol/data/src/nsDataChannel.cpp
+++ b/netwerk/protocol/data/src/nsDataChannel.cpp
@@ -51,8 +51,7 @@
 #include """"prmem.h""""
 
 nsresult
-nsDataChannel::OpenContentStream(PRBool async, nsIInputStream **result,
-                                 nsIChannel** channel)
+nsDataChannel::OpenContentStream(PRBool async, nsIInputStream **result)
 {
     NS_ENSURE_TRUE(URI(), NS_ERROR_NOT_INITIALIZED);
 
diff --git a/netwerk/protocol/data/src/nsDataChannel.h b/netwerk/protocol/data/src/nsDataChannel.h
index 5543be9..c6534a3 100644
--- a/netwerk/protocol/data/src/nsDataChannel.h
+++ b/netwerk/protocol/data/src/nsDataChannel.h
@@ -52,8 +52,7 @@ public:
     }
 
 protected:
-    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
-                                       nsIChannel** channel);
+    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
 };
 
 #endif /* nsDataChannel_h___ */
diff --git a/netwerk/protocol/file/src/nsFileChannel.cpp b/netwerk/protocol/file/src/nsFileChannel.cpp
index 2fff61d..7513f44 100644
--- a/netwerk/protocol/file/src/nsFileChannel.cpp
+++ b/netwerk/protocol/file/src/nsFileChannel.cpp
@@ -307,8 +307,7 @@ nsFileChannel::MakeFileInputStream(nsIFile *file,
 }
 
 nsresult
-nsFileChannel::OpenContentStream(PRBool async, nsIInputStream **result,
-                                 nsIChannel** channel)
+nsFileChannel::OpenContentStream(PRBool async, nsIInputStream **result)
 {
   // NOTE: the resulting file is a clone, so it is safe to pass it to the
   //       file input stream which will be read on a background thread.
@@ -317,24 +316,6 @@ nsFileChannel::OpenContentStream(PRBool async, nsIInputStream **result,
   if (NS_FAILED(rv))
     return rv;
 
-  nsCOMPtr<nsIFileProtocolHandler> fileHandler;
-  rv = NS_GetFileProtocolHandler(getter_AddRefs(fileHandler));
-  if (NS_FAILED(rv))
-    return rv;
-    
-  nsCOMPtr<nsIURI> newURI;
-  rv = fileHandler->ReadURLFile(file, getter_AddRefs(newURI));
-  if (NS_SUCCEEDED(rv)) {
-    nsCOMPtr<nsIChannel> newChannel;
-    rv = NS_NewChannel(getter_AddRefs(newChannel), newURI);
-    if (NS_FAILED(rv))
-      return rv;
-
-    *result = nsnull;
-    newChannel.forget(channel);
-    return NS_OK;
-  }
-
   nsCOMPtr<nsIInputStream> stream;
 
   if (mUploadStream) {
diff --git a/netwerk/protocol/file/src/nsFileChannel.h b/netwerk/protocol/file/src/nsFileChannel.h
index be9cbfb..cc559ab 100644
--- a/netwerk/protocol/file/src/nsFileChannel.h
+++ b/netwerk/protocol/file/src/nsFileChannel.h
@@ -65,8 +65,7 @@ protected:
   nsresult MakeFileInputStream(nsIFile *file, nsCOMPtr<nsIInputStream> &stream,
                                nsCString &contentType);
 
-  virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
-                                     nsIChannel** channel);
+  virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
 
 private:
   nsCOMPtr<nsIInputStream> mUploadStream;
diff --git a/netwerk/protocol/file/src/nsFileProtocolHandler.cpp b/netwerk/protocol/file/src/nsFileProtocolHandler.cpp
index b7189a1b..29f5fcf 100644
--- a/netwerk/protocol/file/src/nsFileProtocolHandler.cpp
+++ b/netwerk/protocol/file/src/nsFileProtocolHandler.cpp
@@ -278,12 +278,30 @@ nsFileProtocolHandler::NewURI(const nsACString &spec,
 NS_IMETHODIMP
 nsFileProtocolHandler::NewChannel(nsIURI *uri, nsIChannel **result)
 {
+    nsresult rv;
+
+    // This file may be a url file
+    nsCOMPtr<nsIFileURL> url(do_QueryInterface(uri));
+    if (url) {
+        nsCOMPtr<nsIFile> file;
+        rv = url->GetFile(getter_AddRefs(file));
+        if (NS_SUCCEEDED(rv)) {
+            nsCOMPtr<nsIURI> uri;
+            rv = ReadURLFile(file, getter_AddRefs(uri));
+            if (NS_SUCCEEDED(rv)) {
+                rv = NS_NewChannel(result, uri);
+                if (NS_SUCCEEDED(rv))
+                    return rv;
+            }
+        }
+    }
+
     nsFileChannel *chan = new nsFileChannel(uri);
     if (!chan)
         return NS_ERROR_OUT_OF_MEMORY;
     NS_ADDREF(chan);
 
-    nsresult rv = chan->Init();
+    rv = chan->Init();
     if (NS_FAILED(rv)) {
         NS_RELEASE(chan);
         return rv;
diff --git a/netwerk/protocol/ftp/src/nsFTPChannel.cpp b/netwerk/protocol/ftp/src/nsFTPChannel.cpp
index 7bc4743..688ebcb 100644
--- a/netwerk/protocol/ftp/src/nsFTPChannel.cpp
+++ b/netwerk/protocol/ftp/src/nsFTPChannel.cpp
@@ -143,8 +143,7 @@ nsFtpChannel::GetProxyInfo(nsIProxyInfo** aProxyInfo)
 //-----------------------------------------------------------------------------
 
 nsresult
-nsFtpChannel::OpenContentStream(PRBool async, nsIInputStream **result,
-                                nsIChannel** channel)
+nsFtpChannel::OpenContentStream(PRBool async, nsIInputStream **result)
 {
     if (!async)
         return NS_ERROR_NOT_IMPLEMENTED;
diff --git a/netwerk/protocol/ftp/src/nsFTPChannel.h b/netwerk/protocol/ftp/src/nsFTPChannel.h
index 314337e..bec6464 100644
--- a/netwerk/protocol/ftp/src/nsFTPChannel.h
+++ b/netwerk/protocol/ftp/src/nsFTPChannel.h
@@ -117,8 +117,7 @@ public:
 
 protected:
     virtual ~nsFtpChannel() {}
-    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
-                                       nsIChannel** channel);
+    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
     virtual PRBool GetStatusArg(nsresult status, nsString &statusArg);
     virtual void OnCallbacksChanged();
 
diff --git a/netwerk/protocol/gopher/src/nsGopherChannel.cpp b/netwerk/protocol/gopher/src/nsGopherChannel.cpp
index 317d73b..d3fd802 100644
--- a/netwerk/protocol/gopher/src/nsGopherChannel.cpp
+++ b/netwerk/protocol/gopher/src/nsGopherChannel.cpp
@@ -469,8 +469,7 @@ nsGopherChannel::GetProxyInfo(nsIProxyInfo** aProxyInfo)
 }
 
 nsresult
-nsGopherChannel::OpenContentStream(PRBool async, nsIInputStream **result,
-                                   nsIChannel** channel)
+nsGopherChannel::OpenContentStream(PRBool async, nsIInputStream **result)
 {
     // Implement nsIChannel::Open in terms of nsIChannel::AsyncOpen
     if (!async)
diff --git a/netwerk/protocol/gopher/src/nsGopherChannel.h b/netwerk/protocol/gopher/src/nsGopherChannel.h
index ba9bcca..4cfe9d8 100644
--- a/netwerk/protocol/gopher/src/nsGopherChannel.h
+++ b/netwerk/protocol/gopher/src/nsGopherChannel.h
@@ -59,8 +59,7 @@ public:
 protected:
     virtual ~nsGopherChannel() {}
 
-    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
-                                       nsIChannel** channel);
+    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
     virtual PRBool GetStatusArg(nsresult status, nsString &statusArg);
 
 private:"""
046cb088f789ab02bc64159a95af34c15c84782b,54427,455311,Boris Zbarsky,"Bug 455311.  Treat .url files as redirects.  r+sr=biesi
",1222722164,"""diff --git a/netwerk/base/src/nsBaseChannel.cpp b/netwerk/base/src/nsBaseChannel.cpp
index fd5030e..333ae29 100644
--- a/netwerk/base/src/nsBaseChannel.cpp
+++ b/netwerk/base/src/nsBaseChannel.cpp
@@ -62,7 +62,7 @@ class ScopedRequestSuspender {
 public:
   ScopedRequestSuspender(nsIRequest *request)
     : mRequest(request) {
-    if (NS_FAILED(mRequest->Suspend())) {
+    if (mRequest && NS_FAILED(mRequest->Suspend())) {
       NS_WARNING(""""Couldn't suspend pump"""");
       mRequest = nsnull;
     }
@@ -94,7 +94,8 @@ nsBaseChannel::nsBaseChannel()
 }
 
 nsresult
-nsBaseChannel::Redirect(nsIChannel *newChannel, PRUint32 redirectFlags)
+nsBaseChannel::Redirect(nsIChannel *newChannel, PRUint32 redirectFlags,
+                        PRBool openNewChannel)
 {
   SUSPEND_PUMP_FOR_SCOPE();
 
@@ -147,9 +148,11 @@ nsBaseChannel::Redirect(nsIChannel *newChannel, PRUint32 redirectFlags)
   // unaffected, so we defer tearing down our channel until we have succeeded
   // with the redirect.
 
-  rv = newChannel->AsyncOpen(mListener, mListenerContext);
-  if (NS_FAILED(rv))
-    return rv;
+  if (openNewChannel) {
+    rv = newChannel->AsyncOpen(mListener, mListenerContext);
+    if (NS_FAILED(rv))
+      return rv;
+  }
 
   // close down this channel
   Cancel(NS_BINDING_REDIRECTED);
@@ -216,10 +219,17 @@ nsresult
 nsBaseChannel::BeginPumpingData()
 {
   nsCOMPtr<nsIInputStream> stream;
-  nsresult rv = OpenContentStream(PR_TRUE, getter_AddRefs(stream));
+  nsCOMPtr<nsIChannel> channel;
+  nsresult rv = OpenContentStream(PR_TRUE, getter_AddRefs(stream),
+                                  getter_AddRefs(channel));
   if (NS_FAILED(rv))
     return rv;
 
+  NS_ASSERTION(!stream || !channel, """"Got both a channel and a stream?"""");
+
+  if (channel)
+      return NS_DispatchToCurrentThread(new RedirectRunnable(this, channel));
+
   // By assigning mPump, we flag this channel as pending (see IsPending).  It's
   // important that the pending flag is set when we call into the stream (the
   // call to AsyncRead results in the stream's AsyncWait method being called)
@@ -234,6 +244,29 @@ nsBaseChannel::BeginPumpingData()
   return rv;
 }
 
+void
+nsBaseChannel::HandleAsyncRedirect(nsIChannel* newChannel)
+{
+  NS_ASSERTION(!mPump, """"Shouldn't have gotten here"""");
+  nsresult rv = Redirect(newChannel, nsIChannelEventSink::REDIRECT_INTERNAL,
+                         PR_TRUE);
+  if (NS_FAILED(rv)) {
+    // Notify our consumer ourselves
+    Cancel(rv);
+    mListener->OnStartRequest(this, mListenerContext);
+    mListener->OnStopRequest(this, mListenerContext, mStatus);
+    mListener = nsnull;
+    mListenerContext = nsnull;
+  }
+
+  if (mLoadGroup)
+    mLoadGroup->RemoveRequest(this, nsnull, mStatus);
+
+  // Drop notification callbacks to prevent cycles.
+  mCallbacks = nsnull;
+  CallbacksChanged();
+}
+
 //-----------------------------------------------------------------------------
 // nsBaseChannel::nsISupports
 
@@ -451,8 +484,15 @@ nsBaseChannel::Open(nsIInputStream **result)
   NS_ENSURE_TRUE(!mPump, NS_ERROR_IN_PROGRESS);
   NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_IN_PROGRESS);
 
-  nsresult rv = OpenContentStream(PR_FALSE, result);
-  if (rv == NS_ERROR_NOT_IMPLEMENTED)
+  nsCOMPtr<nsIChannel> chan;
+  nsresult rv = OpenContentStream(PR_FALSE, result, getter_AddRefs(chan));
+  NS_ASSERTION(!chan || !*result, """"Got both a channel and a stream?"""");
+  if (NS_SUCCEEDED(rv) && chan) {
+      rv = Redirect(chan, nsIChannelEventSink::REDIRECT_INTERNAL, PR_FALSE);
+      if (NS_FAILED(rv))
+          return rv;
+      rv = chan->Open(result);
+  } else if (rv == NS_ERROR_NOT_IMPLEMENTED)
     return NS_ImplementChannelOpen(this, result);
 
   mWasOpened = NS_SUCCEEDED(rv);
diff --git a/netwerk/base/src/nsBaseChannel.h b/netwerk/base/src/nsBaseChannel.h
index 4ead1b8..14f840e 100644
--- a/netwerk/base/src/nsBaseChannel.h
+++ b/netwerk/base/src/nsBaseChannel.h
@@ -52,6 +52,7 @@
 #include """"nsIInterfaceRequestor.h""""
 #include """"nsIProgressEventSink.h""""
 #include """"nsITransport.h""""
+#include """"nsThreadUtils.h""""
 
 //-----------------------------------------------------------------------------
 // nsBaseChannel is designed to be subclassed.  The subclass is responsible for
@@ -103,7 +104,12 @@ private:
   // need to implement ReadSegments.  If async is false, this method may return
   // NS_ERROR_NOT_IMPLEMENTED to cause the basechannel to implement Open in
   // terms of AsyncOpen (see NS_ImplementChannelOpen).
-  virtual nsresult OpenContentStream(PRBool async, nsIInputStream **stream) = 0;
+  // A callee is allowed to return an nsIChannel instead of an nsIInputStream.
+  // That case will be treated as a redirect to the new channel.  By default
+  // *channel will be set to null by the caller, so callees who don't want to
+  // return one an just not touch it.
+  virtual nsresult OpenContentStream(PRBool async, nsIInputStream **stream,
+                                     nsIChannel** channel) = 0;
 
   // The basechannel calls this method from its OnTransportStatus method to
   // determine whether to call nsIProgressEventSink::OnStatus in addition to
@@ -126,12 +132,14 @@ public:
   // Methods provided for use by the derived class:
 
   // Redirect to another channel.  This method takes care of notifying
-  // observers of this redirect as well as of opening the new channel.  It also
-  // cancels |this| with the status code NS_BINDING_REDIRECTED.  A failure
-  // return from this method means that the redirect could not be performed (no
-  // channel was opened; this channel wasn't canceled.)  The redirectFlags
-  // parameter consists of the flag values defined on nsIChannelEventSink.
-  nsresult Redirect(nsIChannel *newChannel, PRUint32 redirectFlags);
+  // observers of this redirect as well as of opening the new channel, if asked
+  // to do so.  It also cancels |this| with the status code
+  // NS_BINDING_REDIRECTED.  A failure return from this method means that the
+  // redirect could not be performed (no channel was opened; this channel
+  // wasn't canceled.)  The redirectFlags parameter consists of the flag values
+  // defined on nsIChannelEventSink.
+  nsresult Redirect(nsIChannel *newChannel, PRUint32 redirectFlags,
+                    PRBool openNewChannel);
 
   // Tests whether a type hint was set. Subclasses can use this to decide
   // whether to call SetContentType.
@@ -233,6 +241,31 @@ private:
     OnCallbacksChanged();
   }
 
+  // Handle an async redirect callback.  This will only be called if we
+  // returned success from AsyncOpen while posting a redirect runnable.
+  void HandleAsyncRedirect(nsIChannel* newChannel);
+
+  class RedirectRunnable : public nsRunnable
+  {
+  public:
+    RedirectRunnable(nsBaseChannel* chan, nsIChannel* newChannel)
+      : mChannel(chan), mNewChannel(newChannel)
+    {
+      NS_PRECONDITION(newChannel, """"Must have channel to redirect to"""");
+    }
+    
+    NS_IMETHOD Run()
+    {
+      mChannel->HandleAsyncRedirect(mNewChannel);
+      return NS_OK;
+    }
+
+  private:
+    nsRefPtr<nsBaseChannel> mChannel;
+    nsCOMPtr<nsIChannel> mNewChannel;
+  };
+  friend class RedirectRunnable;
+
   nsRefPtr<nsInputStreamPump>         mPump;
   nsCOMPtr<nsIInterfaceRequestor>     mCallbacks;
   nsCOMPtr<nsIProgressEventSink>      mProgressSink;
diff --git a/netwerk/base/src/nsInputStreamChannel.cpp b/netwerk/base/src/nsInputStreamChannel.cpp
index 0a32e67..fd35b9d 100644
--- a/netwerk/base/src/nsInputStreamChannel.cpp
+++ b/netwerk/base/src/nsInputStreamChannel.cpp
@@ -41,7 +41,8 @@
 // nsInputStreamChannel
 
 nsresult
-nsInputStreamChannel::OpenContentStream(PRBool async, nsIInputStream **result)
+nsInputStreamChannel::OpenContentStream(PRBool async, nsIInputStream **result,
+                                        nsIChannel** channel)
 {
   NS_ENSURE_TRUE(mContentStream, NS_ERROR_NOT_INITIALIZED);
 
diff --git a/netwerk/base/src/nsInputStreamChannel.h b/netwerk/base/src/nsInputStreamChannel.h
index 7d374d5..a3aad38 100644
--- a/netwerk/base/src/nsInputStreamChannel.h
+++ b/netwerk/base/src/nsInputStreamChannel.h
@@ -55,7 +55,8 @@ public:
 protected:
     virtual ~nsInputStreamChannel() {}
 
-    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
+    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
+                                       nsIChannel** channel);
 
 private:
     nsCOMPtr<nsIInputStream> mContentStream;
diff --git a/netwerk/protocol/data/src/nsDataChannel.cpp b/netwerk/protocol/data/src/nsDataChannel.cpp
index 106e51e..fa63c9f 100644
--- a/netwerk/protocol/data/src/nsDataChannel.cpp
+++ b/netwerk/protocol/data/src/nsDataChannel.cpp
@@ -51,7 +51,8 @@
 #include """"prmem.h""""
 
 nsresult
-nsDataChannel::OpenContentStream(PRBool async, nsIInputStream **result)
+nsDataChannel::OpenContentStream(PRBool async, nsIInputStream **result,
+                                 nsIChannel** channel)
 {
     NS_ENSURE_TRUE(URI(), NS_ERROR_NOT_INITIALIZED);
 
diff --git a/netwerk/protocol/data/src/nsDataChannel.h b/netwerk/protocol/data/src/nsDataChannel.h
index c6534a3..5543be9 100644
--- a/netwerk/protocol/data/src/nsDataChannel.h
+++ b/netwerk/protocol/data/src/nsDataChannel.h
@@ -52,7 +52,8 @@ public:
     }
 
 protected:
-    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
+    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
+                                       nsIChannel** channel);
 };
 
 #endif /* nsDataChannel_h___ */
diff --git a/netwerk/protocol/file/src/nsFileChannel.cpp b/netwerk/protocol/file/src/nsFileChannel.cpp
index 7513f44..2fff61d 100644
--- a/netwerk/protocol/file/src/nsFileChannel.cpp
+++ b/netwerk/protocol/file/src/nsFileChannel.cpp
@@ -307,7 +307,8 @@ nsFileChannel::MakeFileInputStream(nsIFile *file,
 }
 
 nsresult
-nsFileChannel::OpenContentStream(PRBool async, nsIInputStream **result)
+nsFileChannel::OpenContentStream(PRBool async, nsIInputStream **result,
+                                 nsIChannel** channel)
 {
   // NOTE: the resulting file is a clone, so it is safe to pass it to the
   //       file input stream which will be read on a background thread.
@@ -316,6 +317,24 @@ nsFileChannel::OpenContentStream(PRBool async, nsIInputStream **result)
   if (NS_FAILED(rv))
     return rv;
 
+  nsCOMPtr<nsIFileProtocolHandler> fileHandler;
+  rv = NS_GetFileProtocolHandler(getter_AddRefs(fileHandler));
+  if (NS_FAILED(rv))
+    return rv;
+    
+  nsCOMPtr<nsIURI> newURI;
+  rv = fileHandler->ReadURLFile(file, getter_AddRefs(newURI));
+  if (NS_SUCCEEDED(rv)) {
+    nsCOMPtr<nsIChannel> newChannel;
+    rv = NS_NewChannel(getter_AddRefs(newChannel), newURI);
+    if (NS_FAILED(rv))
+      return rv;
+
+    *result = nsnull;
+    newChannel.forget(channel);
+    return NS_OK;
+  }
+
   nsCOMPtr<nsIInputStream> stream;
 
   if (mUploadStream) {
diff --git a/netwerk/protocol/file/src/nsFileChannel.h b/netwerk/protocol/file/src/nsFileChannel.h
index cc559ab..be9cbfb 100644
--- a/netwerk/protocol/file/src/nsFileChannel.h
+++ b/netwerk/protocol/file/src/nsFileChannel.h
@@ -65,7 +65,8 @@ protected:
   nsresult MakeFileInputStream(nsIFile *file, nsCOMPtr<nsIInputStream> &stream,
                                nsCString &contentType);
 
-  virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
+  virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
+                                     nsIChannel** channel);
 
 private:
   nsCOMPtr<nsIInputStream> mUploadStream;
diff --git a/netwerk/protocol/file/src/nsFileProtocolHandler.cpp b/netwerk/protocol/file/src/nsFileProtocolHandler.cpp
index 29f5fcf..b7189a1b 100644
--- a/netwerk/protocol/file/src/nsFileProtocolHandler.cpp
+++ b/netwerk/protocol/file/src/nsFileProtocolHandler.cpp
@@ -278,30 +278,12 @@ nsFileProtocolHandler::NewURI(const nsACString &spec,
 NS_IMETHODIMP
 nsFileProtocolHandler::NewChannel(nsIURI *uri, nsIChannel **result)
 {
-    nsresult rv;
-
-    // This file may be a url file
-    nsCOMPtr<nsIFileURL> url(do_QueryInterface(uri));
-    if (url) {
-        nsCOMPtr<nsIFile> file;
-        rv = url->GetFile(getter_AddRefs(file));
-        if (NS_SUCCEEDED(rv)) {
-            nsCOMPtr<nsIURI> uri;
-            rv = ReadURLFile(file, getter_AddRefs(uri));
-            if (NS_SUCCEEDED(rv)) {
-                rv = NS_NewChannel(result, uri);
-                if (NS_SUCCEEDED(rv))
-                    return rv;
-            }
-        }
-    }
-
     nsFileChannel *chan = new nsFileChannel(uri);
     if (!chan)
         return NS_ERROR_OUT_OF_MEMORY;
     NS_ADDREF(chan);
 
-    rv = chan->Init();
+    nsresult rv = chan->Init();
     if (NS_FAILED(rv)) {
         NS_RELEASE(chan);
         return rv;
diff --git a/netwerk/protocol/ftp/src/nsFTPChannel.cpp b/netwerk/protocol/ftp/src/nsFTPChannel.cpp
index 688ebcb..7bc4743 100644
--- a/netwerk/protocol/ftp/src/nsFTPChannel.cpp
+++ b/netwerk/protocol/ftp/src/nsFTPChannel.cpp
@@ -143,7 +143,8 @@ nsFtpChannel::GetProxyInfo(nsIProxyInfo** aProxyInfo)
 //-----------------------------------------------------------------------------
 
 nsresult
-nsFtpChannel::OpenContentStream(PRBool async, nsIInputStream **result)
+nsFtpChannel::OpenContentStream(PRBool async, nsIInputStream **result,
+                                nsIChannel** channel)
 {
     if (!async)
         return NS_ERROR_NOT_IMPLEMENTED;
diff --git a/netwerk/protocol/ftp/src/nsFTPChannel.h b/netwerk/protocol/ftp/src/nsFTPChannel.h
index bec6464..314337e 100644
--- a/netwerk/protocol/ftp/src/nsFTPChannel.h
+++ b/netwerk/protocol/ftp/src/nsFTPChannel.h
@@ -117,7 +117,8 @@ public:
 
 protected:
     virtual ~nsFtpChannel() {}
-    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
+    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
+                                       nsIChannel** channel);
     virtual PRBool GetStatusArg(nsresult status, nsString &statusArg);
     virtual void OnCallbacksChanged();
 
diff --git a/netwerk/protocol/gopher/src/nsGopherChannel.cpp b/netwerk/protocol/gopher/src/nsGopherChannel.cpp
index d3fd802..317d73b 100644
--- a/netwerk/protocol/gopher/src/nsGopherChannel.cpp
+++ b/netwerk/protocol/gopher/src/nsGopherChannel.cpp
@@ -469,7 +469,8 @@ nsGopherChannel::GetProxyInfo(nsIProxyInfo** aProxyInfo)
 }
 
 nsresult
-nsGopherChannel::OpenContentStream(PRBool async, nsIInputStream **result)
+nsGopherChannel::OpenContentStream(PRBool async, nsIInputStream **result,
+                                   nsIChannel** channel)
 {
     // Implement nsIChannel::Open in terms of nsIChannel::AsyncOpen
     if (!async)
diff --git a/netwerk/protocol/gopher/src/nsGopherChannel.h b/netwerk/protocol/gopher/src/nsGopherChannel.h
index 4cfe9d8..ba9bcca 100644
--- a/netwerk/protocol/gopher/src/nsGopherChannel.h
+++ b/netwerk/protocol/gopher/src/nsGopherChannel.h
@@ -59,7 +59,8 @@ public:
 protected:
     virtual ~nsGopherChannel() {}
 
-    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
+    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
+                                       nsIChannel** channel);
     virtual PRBool GetStatusArg(nsresult status, nsString &statusArg);
 
 private:"""
063eca113d644f52f9759708299907d152cac981,54428,455311,Boris Zbarsky,"Back out changeset a8eb5fc88c01: relanding bug 455311.  Treat .url files as redirects.  r+sr=biesi
",1222722164,"""diff --git a/netwerk/base/src/nsBaseChannel.cpp b/netwerk/base/src/nsBaseChannel.cpp
index fd5030e..333ae29 100644
--- a/netwerk/base/src/nsBaseChannel.cpp
+++ b/netwerk/base/src/nsBaseChannel.cpp
@@ -62,7 +62,7 @@ class ScopedRequestSuspender {
 public:
   ScopedRequestSuspender(nsIRequest *request)
     : mRequest(request) {
-    if (NS_FAILED(mRequest->Suspend())) {
+    if (mRequest && NS_FAILED(mRequest->Suspend())) {
       NS_WARNING(""""Couldn't suspend pump"""");
       mRequest = nsnull;
     }
@@ -94,7 +94,8 @@ nsBaseChannel::nsBaseChannel()
 }
 
 nsresult
-nsBaseChannel::Redirect(nsIChannel *newChannel, PRUint32 redirectFlags)
+nsBaseChannel::Redirect(nsIChannel *newChannel, PRUint32 redirectFlags,
+                        PRBool openNewChannel)
 {
   SUSPEND_PUMP_FOR_SCOPE();
 
@@ -147,9 +148,11 @@ nsBaseChannel::Redirect(nsIChannel *newChannel, PRUint32 redirectFlags)
   // unaffected, so we defer tearing down our channel until we have succeeded
   // with the redirect.
 
-  rv = newChannel->AsyncOpen(mListener, mListenerContext);
-  if (NS_FAILED(rv))
-    return rv;
+  if (openNewChannel) {
+    rv = newChannel->AsyncOpen(mListener, mListenerContext);
+    if (NS_FAILED(rv))
+      return rv;
+  }
 
   // close down this channel
   Cancel(NS_BINDING_REDIRECTED);
@@ -216,10 +219,17 @@ nsresult
 nsBaseChannel::BeginPumpingData()
 {
   nsCOMPtr<nsIInputStream> stream;
-  nsresult rv = OpenContentStream(PR_TRUE, getter_AddRefs(stream));
+  nsCOMPtr<nsIChannel> channel;
+  nsresult rv = OpenContentStream(PR_TRUE, getter_AddRefs(stream),
+                                  getter_AddRefs(channel));
   if (NS_FAILED(rv))
     return rv;
 
+  NS_ASSERTION(!stream || !channel, """"Got both a channel and a stream?"""");
+
+  if (channel)
+      return NS_DispatchToCurrentThread(new RedirectRunnable(this, channel));
+
   // By assigning mPump, we flag this channel as pending (see IsPending).  It's
   // important that the pending flag is set when we call into the stream (the
   // call to AsyncRead results in the stream's AsyncWait method being called)
@@ -234,6 +244,29 @@ nsBaseChannel::BeginPumpingData()
   return rv;
 }
 
+void
+nsBaseChannel::HandleAsyncRedirect(nsIChannel* newChannel)
+{
+  NS_ASSERTION(!mPump, """"Shouldn't have gotten here"""");
+  nsresult rv = Redirect(newChannel, nsIChannelEventSink::REDIRECT_INTERNAL,
+                         PR_TRUE);
+  if (NS_FAILED(rv)) {
+    // Notify our consumer ourselves
+    Cancel(rv);
+    mListener->OnStartRequest(this, mListenerContext);
+    mListener->OnStopRequest(this, mListenerContext, mStatus);
+    mListener = nsnull;
+    mListenerContext = nsnull;
+  }
+
+  if (mLoadGroup)
+    mLoadGroup->RemoveRequest(this, nsnull, mStatus);
+
+  // Drop notification callbacks to prevent cycles.
+  mCallbacks = nsnull;
+  CallbacksChanged();
+}
+
 //-----------------------------------------------------------------------------
 // nsBaseChannel::nsISupports
 
@@ -451,8 +484,15 @@ nsBaseChannel::Open(nsIInputStream **result)
   NS_ENSURE_TRUE(!mPump, NS_ERROR_IN_PROGRESS);
   NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_IN_PROGRESS);
 
-  nsresult rv = OpenContentStream(PR_FALSE, result);
-  if (rv == NS_ERROR_NOT_IMPLEMENTED)
+  nsCOMPtr<nsIChannel> chan;
+  nsresult rv = OpenContentStream(PR_FALSE, result, getter_AddRefs(chan));
+  NS_ASSERTION(!chan || !*result, """"Got both a channel and a stream?"""");
+  if (NS_SUCCEEDED(rv) && chan) {
+      rv = Redirect(chan, nsIChannelEventSink::REDIRECT_INTERNAL, PR_FALSE);
+      if (NS_FAILED(rv))
+          return rv;
+      rv = chan->Open(result);
+  } else if (rv == NS_ERROR_NOT_IMPLEMENTED)
     return NS_ImplementChannelOpen(this, result);
 
   mWasOpened = NS_SUCCEEDED(rv);
diff --git a/netwerk/base/src/nsBaseChannel.h b/netwerk/base/src/nsBaseChannel.h
index 4ead1b8..14f840e 100644
--- a/netwerk/base/src/nsBaseChannel.h
+++ b/netwerk/base/src/nsBaseChannel.h
@@ -52,6 +52,7 @@
 #include """"nsIInterfaceRequestor.h""""
 #include """"nsIProgressEventSink.h""""
 #include """"nsITransport.h""""
+#include """"nsThreadUtils.h""""
 
 //-----------------------------------------------------------------------------
 // nsBaseChannel is designed to be subclassed.  The subclass is responsible for
@@ -103,7 +104,12 @@ private:
   // need to implement ReadSegments.  If async is false, this method may return
   // NS_ERROR_NOT_IMPLEMENTED to cause the basechannel to implement Open in
   // terms of AsyncOpen (see NS_ImplementChannelOpen).
-  virtual nsresult OpenContentStream(PRBool async, nsIInputStream **stream) = 0;
+  // A callee is allowed to return an nsIChannel instead of an nsIInputStream.
+  // That case will be treated as a redirect to the new channel.  By default
+  // *channel will be set to null by the caller, so callees who don't want to
+  // return one an just not touch it.
+  virtual nsresult OpenContentStream(PRBool async, nsIInputStream **stream,
+                                     nsIChannel** channel) = 0;
 
   // The basechannel calls this method from its OnTransportStatus method to
   // determine whether to call nsIProgressEventSink::OnStatus in addition to
@@ -126,12 +132,14 @@ public:
   // Methods provided for use by the derived class:
 
   // Redirect to another channel.  This method takes care of notifying
-  // observers of this redirect as well as of opening the new channel.  It also
-  // cancels |this| with the status code NS_BINDING_REDIRECTED.  A failure
-  // return from this method means that the redirect could not be performed (no
-  // channel was opened; this channel wasn't canceled.)  The redirectFlags
-  // parameter consists of the flag values defined on nsIChannelEventSink.
-  nsresult Redirect(nsIChannel *newChannel, PRUint32 redirectFlags);
+  // observers of this redirect as well as of opening the new channel, if asked
+  // to do so.  It also cancels |this| with the status code
+  // NS_BINDING_REDIRECTED.  A failure return from this method means that the
+  // redirect could not be performed (no channel was opened; this channel
+  // wasn't canceled.)  The redirectFlags parameter consists of the flag values
+  // defined on nsIChannelEventSink.
+  nsresult Redirect(nsIChannel *newChannel, PRUint32 redirectFlags,
+                    PRBool openNewChannel);
 
   // Tests whether a type hint was set. Subclasses can use this to decide
   // whether to call SetContentType.
@@ -233,6 +241,31 @@ private:
     OnCallbacksChanged();
   }
 
+  // Handle an async redirect callback.  This will only be called if we
+  // returned success from AsyncOpen while posting a redirect runnable.
+  void HandleAsyncRedirect(nsIChannel* newChannel);
+
+  class RedirectRunnable : public nsRunnable
+  {
+  public:
+    RedirectRunnable(nsBaseChannel* chan, nsIChannel* newChannel)
+      : mChannel(chan), mNewChannel(newChannel)
+    {
+      NS_PRECONDITION(newChannel, """"Must have channel to redirect to"""");
+    }
+    
+    NS_IMETHOD Run()
+    {
+      mChannel->HandleAsyncRedirect(mNewChannel);
+      return NS_OK;
+    }
+
+  private:
+    nsRefPtr<nsBaseChannel> mChannel;
+    nsCOMPtr<nsIChannel> mNewChannel;
+  };
+  friend class RedirectRunnable;
+
   nsRefPtr<nsInputStreamPump>         mPump;
   nsCOMPtr<nsIInterfaceRequestor>     mCallbacks;
   nsCOMPtr<nsIProgressEventSink>      mProgressSink;
diff --git a/netwerk/base/src/nsInputStreamChannel.cpp b/netwerk/base/src/nsInputStreamChannel.cpp
index 0a32e67..fd35b9d 100644
--- a/netwerk/base/src/nsInputStreamChannel.cpp
+++ b/netwerk/base/src/nsInputStreamChannel.cpp
@@ -41,7 +41,8 @@
 // nsInputStreamChannel
 
 nsresult
-nsInputStreamChannel::OpenContentStream(PRBool async, nsIInputStream **result)
+nsInputStreamChannel::OpenContentStream(PRBool async, nsIInputStream **result,
+                                        nsIChannel** channel)
 {
   NS_ENSURE_TRUE(mContentStream, NS_ERROR_NOT_INITIALIZED);
 
diff --git a/netwerk/base/src/nsInputStreamChannel.h b/netwerk/base/src/nsInputStreamChannel.h
index 7d374d5..a3aad38 100644
--- a/netwerk/base/src/nsInputStreamChannel.h
+++ b/netwerk/base/src/nsInputStreamChannel.h
@@ -55,7 +55,8 @@ public:
 protected:
     virtual ~nsInputStreamChannel() {}
 
-    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
+    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
+                                       nsIChannel** channel);
 
 private:
     nsCOMPtr<nsIInputStream> mContentStream;
diff --git a/netwerk/protocol/data/src/nsDataChannel.cpp b/netwerk/protocol/data/src/nsDataChannel.cpp
index 106e51e..fa63c9f 100644
--- a/netwerk/protocol/data/src/nsDataChannel.cpp
+++ b/netwerk/protocol/data/src/nsDataChannel.cpp
@@ -51,7 +51,8 @@
 #include """"prmem.h""""
 
 nsresult
-nsDataChannel::OpenContentStream(PRBool async, nsIInputStream **result)
+nsDataChannel::OpenContentStream(PRBool async, nsIInputStream **result,
+                                 nsIChannel** channel)
 {
     NS_ENSURE_TRUE(URI(), NS_ERROR_NOT_INITIALIZED);
 
diff --git a/netwerk/protocol/data/src/nsDataChannel.h b/netwerk/protocol/data/src/nsDataChannel.h
index c6534a3..5543be9 100644
--- a/netwerk/protocol/data/src/nsDataChannel.h
+++ b/netwerk/protocol/data/src/nsDataChannel.h
@@ -52,7 +52,8 @@ public:
     }
 
 protected:
-    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
+    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
+                                       nsIChannel** channel);
 };
 
 #endif /* nsDataChannel_h___ */
diff --git a/netwerk/protocol/file/src/nsFileChannel.cpp b/netwerk/protocol/file/src/nsFileChannel.cpp
index 7513f44..2fff61d 100644
--- a/netwerk/protocol/file/src/nsFileChannel.cpp
+++ b/netwerk/protocol/file/src/nsFileChannel.cpp
@@ -307,7 +307,8 @@ nsFileChannel::MakeFileInputStream(nsIFile *file,
 }
 
 nsresult
-nsFileChannel::OpenContentStream(PRBool async, nsIInputStream **result)
+nsFileChannel::OpenContentStream(PRBool async, nsIInputStream **result,
+                                 nsIChannel** channel)
 {
   // NOTE: the resulting file is a clone, so it is safe to pass it to the
   //       file input stream which will be read on a background thread.
@@ -316,6 +317,24 @@ nsFileChannel::OpenContentStream(PRBool async, nsIInputStream **result)
   if (NS_FAILED(rv))
     return rv;
 
+  nsCOMPtr<nsIFileProtocolHandler> fileHandler;
+  rv = NS_GetFileProtocolHandler(getter_AddRefs(fileHandler));
+  if (NS_FAILED(rv))
+    return rv;
+    
+  nsCOMPtr<nsIURI> newURI;
+  rv = fileHandler->ReadURLFile(file, getter_AddRefs(newURI));
+  if (NS_SUCCEEDED(rv)) {
+    nsCOMPtr<nsIChannel> newChannel;
+    rv = NS_NewChannel(getter_AddRefs(newChannel), newURI);
+    if (NS_FAILED(rv))
+      return rv;
+
+    *result = nsnull;
+    newChannel.forget(channel);
+    return NS_OK;
+  }
+
   nsCOMPtr<nsIInputStream> stream;
 
   if (mUploadStream) {
diff --git a/netwerk/protocol/file/src/nsFileChannel.h b/netwerk/protocol/file/src/nsFileChannel.h
index cc559ab..be9cbfb 100644
--- a/netwerk/protocol/file/src/nsFileChannel.h
+++ b/netwerk/protocol/file/src/nsFileChannel.h
@@ -65,7 +65,8 @@ protected:
   nsresult MakeFileInputStream(nsIFile *file, nsCOMPtr<nsIInputStream> &stream,
                                nsCString &contentType);
 
-  virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
+  virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
+                                     nsIChannel** channel);
 
 private:
   nsCOMPtr<nsIInputStream> mUploadStream;
diff --git a/netwerk/protocol/file/src/nsFileProtocolHandler.cpp b/netwerk/protocol/file/src/nsFileProtocolHandler.cpp
index 29f5fcf..b7189a1b 100644
--- a/netwerk/protocol/file/src/nsFileProtocolHandler.cpp
+++ b/netwerk/protocol/file/src/nsFileProtocolHandler.cpp
@@ -278,30 +278,12 @@ nsFileProtocolHandler::NewURI(const nsACString &spec,
 NS_IMETHODIMP
 nsFileProtocolHandler::NewChannel(nsIURI *uri, nsIChannel **result)
 {
-    nsresult rv;
-
-    // This file may be a url file
-    nsCOMPtr<nsIFileURL> url(do_QueryInterface(uri));
-    if (url) {
-        nsCOMPtr<nsIFile> file;
-        rv = url->GetFile(getter_AddRefs(file));
-        if (NS_SUCCEEDED(rv)) {
-            nsCOMPtr<nsIURI> uri;
-            rv = ReadURLFile(file, getter_AddRefs(uri));
-            if (NS_SUCCEEDED(rv)) {
-                rv = NS_NewChannel(result, uri);
-                if (NS_SUCCEEDED(rv))
-                    return rv;
-            }
-        }
-    }
-
     nsFileChannel *chan = new nsFileChannel(uri);
     if (!chan)
         return NS_ERROR_OUT_OF_MEMORY;
     NS_ADDREF(chan);
 
-    rv = chan->Init();
+    nsresult rv = chan->Init();
     if (NS_FAILED(rv)) {
         NS_RELEASE(chan);
         return rv;
diff --git a/netwerk/protocol/ftp/src/nsFTPChannel.cpp b/netwerk/protocol/ftp/src/nsFTPChannel.cpp
index 688ebcb..7bc4743 100644
--- a/netwerk/protocol/ftp/src/nsFTPChannel.cpp
+++ b/netwerk/protocol/ftp/src/nsFTPChannel.cpp
@@ -143,7 +143,8 @@ nsFtpChannel::GetProxyInfo(nsIProxyInfo** aProxyInfo)
 //-----------------------------------------------------------------------------
 
 nsresult
-nsFtpChannel::OpenContentStream(PRBool async, nsIInputStream **result)
+nsFtpChannel::OpenContentStream(PRBool async, nsIInputStream **result,
+                                nsIChannel** channel)
 {
     if (!async)
         return NS_ERROR_NOT_IMPLEMENTED;
diff --git a/netwerk/protocol/ftp/src/nsFTPChannel.h b/netwerk/protocol/ftp/src/nsFTPChannel.h
index bec6464..314337e 100644
--- a/netwerk/protocol/ftp/src/nsFTPChannel.h
+++ b/netwerk/protocol/ftp/src/nsFTPChannel.h
@@ -117,7 +117,8 @@ public:
 
 protected:
     virtual ~nsFtpChannel() {}
-    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
+    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
+                                       nsIChannel** channel);
     virtual PRBool GetStatusArg(nsresult status, nsString &statusArg);
     virtual void OnCallbacksChanged();
 
diff --git a/netwerk/protocol/gopher/src/nsGopherChannel.cpp b/netwerk/protocol/gopher/src/nsGopherChannel.cpp
index d3fd802..317d73b 100644
--- a/netwerk/protocol/gopher/src/nsGopherChannel.cpp
+++ b/netwerk/protocol/gopher/src/nsGopherChannel.cpp
@@ -469,7 +469,8 @@ nsGopherChannel::GetProxyInfo(nsIProxyInfo** aProxyInfo)
 }
 
 nsresult
-nsGopherChannel::OpenContentStream(PRBool async, nsIInputStream **result)
+nsGopherChannel::OpenContentStream(PRBool async, nsIInputStream **result,
+                                   nsIChannel** channel)
 {
     // Implement nsIChannel::Open in terms of nsIChannel::AsyncOpen
     if (!async)
diff --git a/netwerk/protocol/gopher/src/nsGopherChannel.h b/netwerk/protocol/gopher/src/nsGopherChannel.h
index 4cfe9d8..ba9bcca 100644
--- a/netwerk/protocol/gopher/src/nsGopherChannel.h
+++ b/netwerk/protocol/gopher/src/nsGopherChannel.h
@@ -59,7 +59,8 @@ public:
 protected:
     virtual ~nsGopherChannel() {}
 
-    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result);
+    virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
+                                       nsIChannel** channel);
     virtual PRBool GetStatusArg(nsresult status, nsString &statusArg);
 
 private:"""
867b4f6a3b0fb08b302c0d50b21349ccdd12bd53,54657,443089,Jesse Ruderman,"Add crashtest for bug 443089
",1222379855,"""diff --git a/layout/mathml/crashtests/443089-1.xhtml b/layout/mathml/crashtests/443089-1.xhtml
new file mode 100644
index 0000000..2630cea
--- /dev/null
+++ b/layout/mathml/crashtests/443089-1.xhtml
@@ -0,0 +1,7 @@
+<html xmlns=""""http://www.w3.org/1999/xhtml"""">
+<head>
+</head>
+<body>
+<mtd xmlns=""""http://www.w3.org/1998/Math/MathML"""" id=""""mtd"""" rowspan=""""1073741825""""/>
+</body>
+</html>
diff --git a/layout/mathml/crashtests/crashtests.list b/layout/mathml/crashtests/crashtests.list
index b08b156..9f56522 100644
--- a/layout/mathml/crashtests/crashtests.list
+++ b/layout/mathml/crashtests/crashtests.list
@@ -38,3 +38,4 @@ load 405271-1.xml
 load 412237-1.xml
 load 413063-1.xhtml
 load 420420-1.xhtml
+load 443089-1.xhtml"""
4bfe89f47fa0675a05ca0130fac27a28da237435,55084,441360,Mats Palmgren,"Disable bug 441360 crash test on GTK2 for now (filed bug 455463).
",1221552286,"""diff --git a/gfx/thebes/crashtests/crashtests.list b/gfx/thebes/crashtests/crashtests.list
index bb42199..935f3a0 100644
--- a/gfx/thebes/crashtests/crashtests.list
+++ b/gfx/thebes/crashtests/crashtests.list
@@ -39,5 +39,5 @@ load 421393-1.html
 load 421813-1.html
 load 423270-1.html
 load 429899-1.html
-load 441360.html
+skip-if(MOZ_WIDGET_TOOLKIT==""""gtk2"""") load 441360.html # filed bug 455463 for gtk2
 """
100445e59ec55f27f800dfc57e90e74e7d6b8cb0,55087,441360,Mats Palmgren,"Crash test for bug 441360 (additional file).
",1221544098,"""diff --git a/gfx/thebes/crashtests/441360_data.gif b/gfx/thebes/crashtests/441360_data.gif
new file mode 100644
index 0000000..96532dc
Binary files /dev/null and b/gfx/thebes/crashtests/441360_data.gif differ"""
055991dde600d0b05ff2448e1e9c2be583a65a3c,55098,441360,Mats Palmgren,"Crash test for bug 441360.
",1221529020,"""diff --git a/gfx/thebes/crashtests/441360.html b/gfx/thebes/crashtests/441360.html
new file mode 100644
index 0000000..0f06414
--- /dev/null
+++ b/gfx/thebes/crashtests/441360.html
@@ -0,0 +1,39 @@
+<html><head>
+    <meta http-equiv=""""Content-Type"""" content=""""text/html; charset=iso-8859-1"""">
+    <title>Testcase for bug </title>
+    <style type=""""text/css"""">
+
+        html,body {
+            color:black; background-color:white; font-size:16px; padding:0; margin:0;
+        }
+	
+
+    </style>
+</head>
+<body>
+
+<div id=""""Image""""></div>
+
+<script>
+var v;
+function insertImage() {
+	var img_node = document.createElement('iframe');
+	img_node.src = """"441360_data.gif"""";
+	var image_div = document.getElementById('Image');
+	image_div.appendChild(img_node);
+}
+
+insertImage();
+v = document.body.offsetHeight;
+insertImage();
+v = document.body.offsetHeight;
+insertImage();
+v = document.body.offsetHeight;
+insertImage();
+v = document.body.offsetHeight;
+
+</script>
+
+
+</body>
+</html>
diff --git a/gfx/thebes/crashtests/crashtests.list b/gfx/thebes/crashtests/crashtests.list
index af49fb7..bb42199 100644
--- a/gfx/thebes/crashtests/crashtests.list
+++ b/gfx/thebes/crashtests/crashtests.list
@@ -39,4 +39,5 @@ load 421393-1.html
 load 421813-1.html
 load 423270-1.html
 load 429899-1.html
+load 441360.html
 """
b4683cd67bbd9f0a7a288ebd7ab32b5849047797,55873,452786,Igor Bukanov,"bug 452786 - optimizing JS date access. r=mrbkap
",1220257841,"""diff --git a/js/src/jsdate.cpp b/js/src/jsdate.cpp
index b635445..0230bd2 100644
--- a/js/src/jsdate.cpp
+++ b/js/src/jsdate.cpp
@@ -478,12 +478,15 @@ msFromTime(jsdouble t)
  * We use the first reseved slot to store UTC time, and the second for caching
  * the local time. The initial value of the cache entry is NaN.
  */
-#define UTC_TIME_SLOT           0
-#define LOCAL_TIME_SLOT         1
+const uint32 JSSLOT_UTC_TIME    = JSSLOT_PRIVATE;
+const uint32 JSSLOT_LOCAL_TIME  = JSSLOT_PRIVATE + 1;
+
+const uint32 DATE_RESERVED_SLOTS = 2;
 
 JSClass js_DateClass = {
     js_Date_str,
-    JSCLASS_HAS_RESERVED_SLOTS(2) |  JSCLASS_HAS_CACHED_PROTO(JSProto_Date),
+    JSCLASS_HAS_RESERVED_SLOTS(DATE_RESERVED_SLOTS) |
+    JSCLASS_HAS_CACHED_PROTO(JSProto_Date),
     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,
     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,   JS_FinalizeStub,
     JSCLASS_NO_OPTIONAL_MEMBERS
@@ -930,14 +933,9 @@ date_now(JSContext *cx, uintN argc, jsval *vp)
 static JSBool
 GetUTCTime(JSContext *cx, JSObject *obj, jsval *vp, jsdouble *dp)
 {
-    jsval v;
-
     if (!JS_InstanceOf(cx, obj, &js_DateClass, vp ? vp + 2 : NULL))
         return JS_FALSE;
-    if (!JS_GetReservedSlot(cx, obj, UTC_TIME_SLOT, &v))
-        return JS_FALSE;
-
-    *dp = *JSVAL_TO_DOUBLE(v);
+    *dp = *JSVAL_TO_DOUBLE(obj->fslots[JSSLOT_UTC_TIME]);
     return JS_TRUE;
 }
 
@@ -952,14 +950,12 @@ SetUTCTimePtr(JSContext *cx, JSObject *obj, jsval *vp, jsdouble *dp)
 {
     if (vp && !JS_InstanceOf(cx, obj, &js_DateClass, vp + 2))
         return JS_FALSE;
+    JS_ASSERT_IF(!vp, STOBJ_GET_CLASS(obj) == &js_DateClass);
 
     /* Invalidate local time cache. */
-    if (!JS_SetReservedSlot(cx, obj, LOCAL_TIME_SLOT,
-                            DOUBLE_TO_JSVAL(cx->runtime->jsNaN))) {
-        return JS_FALSE;
-    }
-
-    return JS_SetReservedSlot(cx, obj, UTC_TIME_SLOT, DOUBLE_TO_JSVAL(dp));
+    obj->fslots[JSSLOT_LOCAL_TIME] = DOUBLE_TO_JSVAL(cx->runtime->jsNaN);
+    obj->fslots[JSSLOT_UTC_TIME] = DOUBLE_TO_JSVAL(dp);
+    return JS_TRUE;
 }
 
 /*
@@ -985,8 +981,9 @@ GetAndCacheLocalTime(JSContext *cx, JSObject *obj, jsval *vp, jsdouble *dp)
     jsdouble result;
     jsdouble *cached;
 
-    if (!obj || !JS_GetReservedSlot(cx, obj, LOCAL_TIME_SLOT, &v))
+    if (!obj || !JS_InstanceOf(cx, obj, &js_DateClass, vp ? vp + 2 : NULL))
         return JS_FALSE;
+    v = obj->fslots[JSSLOT_LOCAL_TIME];
 
     result = *JSVAL_TO_DOUBLE(v);
 
@@ -1002,10 +999,7 @@ GetAndCacheLocalTime(JSContext *cx, JSObject *obj, jsval *vp, jsdouble *dp)
         if (!cached)
             return JS_FALSE;
 
-        if (!JS_SetReservedSlot(cx, obj, LOCAL_TIME_SLOT,
-                                DOUBLE_TO_JSVAL(cached))) {
-            return JS_FALSE;
-        }
+        obj->fslots[JSSLOT_LOCAL_TIME] = DOUBLE_TO_JSVAL(cached);
     }
 
     *dp = result;
@@ -2036,10 +2030,8 @@ date_constructor(JSContext *cx, JSObject* obj)
     if (!date)
         return NULL;
 
-    JS_SetReservedSlot(cx, obj, UTC_TIME_SLOT,
-                       DOUBLE_TO_JSVAL(date));
-    JS_SetReservedSlot(cx, obj, LOCAL_TIME_SLOT,
-                       DOUBLE_TO_JSVAL(cx->runtime->jsNaN));
+    obj->fslots[JSSLOT_UTC_TIME] = DOUBLE_TO_JSVAL(date);
+    obj->fslots[JSSLOT_LOCAL_TIME] = DOUBLE_TO_JSVAL(cx->runtime->jsNaN);
     return date;
 }
 """
bdf601b61ca72dab540b4c43c1dda659a786f72c,56199,441785,Mike Kaplinskiy,"Bug 441785 - ""crash when closing open rdf files or right click on tree after opening rdf files [@ nsXULTemplateQueryProcessorRDF::CheckIsSeparator]"" [r=Enn sr=jst]
",1219205806,"""diff --git a/content/xul/templates/src/crashtests/441785-1.rdf b/content/xul/templates/src/crashtests/441785-1.rdf
new file mode 100644
index 0000000..4be5565
--- /dev/null
+++ b/content/xul/templates/src/crashtests/441785-1.rdf
@@ -0,0 +1,263 @@
+<?xml version=""""1.0"""" encoding=""""utf-8""""?>
+<RDF:RDF xmlns:RDF=""""http://www.w3.org/1999/02/22-rdf-syntax-ns#"""" xmlns:row=""""http://dummy/rdf#"""" xmlns:NC=""""http://home.netscape.com/NC-rdf#"""">
+	<RDF:Bag about=""""urn:data:row"""">
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111110</row:id>
+				<row:title>FILE 1 -- A</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111111</row:id>
+				<row:title>FILE 1 -- B</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111110</row:id>
+				<row:title>FILE 1 -- C</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111111</row:id>
+				<row:title>FILE 1 -- D</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111112</row:id>
+				<row:title>FILE 1 -- E</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111110</row:id>
+				<row:title>FILE 1 -- F</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111114</row:id>
+				<row:title>FILE 1 -- G</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111111</row:id>
+				<row:title>FILE 1 -- H</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111118</row:id>
+				<row:title>FILE 1 -- I</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111116</row:id>
+				<row:title>FILE 1 -- J</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111110</row:id>
+				<row:title>FILE 1 -- K</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111119</row:id>
+				<row:title>FILE 1 -- L</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111116</row:id>
+				<row:title>FILE 1 -- M</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111111</row:id>
+				<row:title>FILE 1 -- N</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111113</row:id>
+				<row:title>FILE 1 -- O</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111111</row:id>
+				<row:title>FILE 1 -- P</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111117</row:id>
+				<row:title>FILE 1 -- Q</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111110</row:id>
+				<row:title>FILE 1 -- R</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111113</row:id>
+				<row:title>FILE 1 -- S</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111112</row:id>
+				<row:title>FILE 1 -- T</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111116</row:id>
+				<row:title>FILE 1 -- U</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111111</row:id>
+				<row:title>FILE 1 -- V</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111121</row:id>
+				<row:title>FILE 1 -- W</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111114</row:id>
+				<row:title>FILE 1 -- X</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111122</row:id>
+				<row:title>FILE 1 -- Y</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111113</row:id>
+				<row:title>FILE 1 -- Z</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111119</row:id>
+				<row:title>FILE 1 -- AA</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111117</row:id>
+				<row:title>FILE 1 -- BB</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111117</row:id>
+				<row:title>FILE 1 -- CC</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111117</row:id>
+				<row:title>FILE 1 -- DD</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111116</row:id>
+				<row:title>FILE 1 -- EE</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111124</row:id>
+				<row:title>FILE 1 -- FF</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111118</row:id>
+				<row:title>FILE 1 -- GG</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111117</row:id>
+				<row:title>FILE 1 -- HH</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111118</row:id>
+				<row:title>FILE 1 -- II</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111125</row:id>
+				<row:title>FILE 1 -- JJ</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111124</row:id>
+				<row:title>FILE 1 -- KK</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111132</row:id>
+				<row:title>FILE 1 -- LL</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111136</row:id>
+				<row:title>FILE 1 -- MM</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111123</row:id>
+				<row:title>FILE 1 -- NN</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111122</row:id>
+				<row:title>FILE 1 -- OO</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">111110</row:id>
+				<row:title>FILE 1 -- PP</row:title>
+			</RDF:Description>
+		</RDF:li>
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">1111116</row:id>
+				<row:title>FILE 1 -- QQ</row:title>
+			</RDF:Description>
+		</RDF:li>
+	</RDF:Bag>
+</RDF:RDF>
diff --git a/content/xul/templates/src/crashtests/441785-1.xul b/content/xul/templates/src/crashtests/441785-1.xul
new file mode 100644
index 0000000..c5ed66b
--- /dev/null
+++ b/content/xul/templates/src/crashtests/441785-1.xul
@@ -0,0 +1,54 @@
+<?xml version=""""1.0"""" ?>
+<?xml-stylesheet href=""""chrome://global/skin"""" type=""""text/css""""?>
+<window xmlns=""""http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"""" class=""""reftest-wait"""">
+   <tree flex=""""20"""" id=""""t"""" ref=""""urn:data:row"""" datasources="""""""" seltype=""""single"""" >
+     <treecols> 
+      <treecol flex=""""1"""" id=""""id"""" label=""""id"""" sort=""""rdf:http://dummy/rdf#id"""" />
+      <splitter class=""""tree-splitter""""/>
+      <treecol flex=""""1"""" id=""""title"""" label=""""title"""" sort=""""rdf:http://dummy/rdf#title"""" sortActive=""""true"""" sortDirection=""""ascending"""" /><splitter class=""""tree-splitter""""/>
+     </treecols>
+     <template>
+       <treechildren>
+         <treeitem uri=""""rdf:*"""" seltype=""""single"""">
+           <treerow >
+             <treecell label=""""rdf:http://dummy/rdf#id""""/>
+             <treecell label=""""rdf:http://dummy/rdf#title""""/>
+           </treerow>
+         </treeitem>
+       </treechildren>
+     </template>
+   </tree>
+
+<script type=""""application/x-javascript"""">
+<![CDATA[
+
+var tree = document.getElementById('t');
+
+function runTest() {
+  tree.setAttribute('datasources', '441785-1.rdf');
+  tree.setAttribute('datasources', '441785-2.rdf');
+  
+  setTimeout('continueTest()', 1000);
+}
+
+function continueTest() {
+  if (tree.view && tree.view.rowCount > 1) {
+    //netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
+    try {
+      window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
+              .getInterface(Components.interfaces.nsIDOMWindowUtils)
+              .garbageCollect();
+    } 
+    catch (e) { }
+    // Hit the bug, crash 
+    // (not exactly the same kind of crash as 441785, but from the same cause)
+    tree.parentNode.removeChild(tree);
+  }
+  document.documentElement.className = """""""";
+}
+
+window.addEventListener(""""load"""", runTest, false);
+
+]]>
+</script>
+</window>
diff --git a/content/xul/templates/src/crashtests/441785-2.rdf b/content/xul/templates/src/crashtests/441785-2.rdf
new file mode 100644
index 0000000..dca97ba
--- /dev/null
+++ b/content/xul/templates/src/crashtests/441785-2.rdf
@@ -0,0 +1,11 @@
+<?xml version=""""1.0"""" encoding=""""utf-8""""?>
+<RDF:RDF xmlns:RDF=""""http://www.w3.org/1999/02/22-rdf-syntax-ns#"""" xmlns:row=""""http://dummy/rdf#"""" xmlns:NC=""""http://home.netscape.com/NC-rdf#"""">
+	<RDF:Bag about=""""urn:data:row"""">
+		<RDF:li>
+			<RDF:Description>
+				<row:id NC:parseType=""""Integer"""">222220</row:id>
+				<row:title>FILE 2 -- A</row:title>
+			</RDF:Description>
+		</RDF:li>
+	</RDF:Bag>
+</RDF:RDF>
diff --git a/content/xul/templates/src/crashtests/crashtests.list b/content/xul/templates/src/crashtests/crashtests.list
index 4639f11..668460a 100644
--- a/content/xul/templates/src/crashtests/crashtests.list
+++ b/content/xul/templates/src/crashtests/crashtests.list
@@ -5,3 +5,4 @@ load 397148-1.xul
 load 404346-1.xul
 load 415019-1.xul
 load 417840-1.xul
+load 441785-1.xul
diff --git a/content/xul/templates/src/nsXULTemplateBuilder.cpp b/content/xul/templates/src/nsXULTemplateBuilder.cpp
index 2197e2d..ebbc31a 100644
--- a/content/xul/templates/src/nsXULTemplateBuilder.cpp
+++ b/content/xul/templates/src/nsXULTemplateBuilder.cpp
@@ -1111,8 +1111,10 @@ nsXULTemplateBuilder::AttributeChanged(nsIDocument* aDocument,
             Rebuild();
 
         // Check for a change to the 'datasources' attribute. If so, setup
-        // mDB by parsing the vew value and rebuild.
+        // mDB by parsing the new value and rebuild.
         else if (aAttribute == nsGkAtoms::datasources) {
+            Uninit(PR_FALSE);  // Reset results
+            
             PRBool shouldDelay;
             LoadDataSources(aDocument, &shouldDelay);
             if (!shouldDelay)"""
89f25aca2d3ce4cb8c1c38a37a10b8b774499cec,56257,447579,Boris Zbarsky,"Bug 447579.  Be a little more careful about inheriting principals for file URIs.  r=dveditz, sr=jst
",1219929381,"""diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
index 7da7802..fe3bebb 100644
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -7476,7 +7476,17 @@ nsDocShell::DoURILoad(nsIURI * aURI,
     nsCOMPtr<nsIPrincipal> ownerPrincipal(do_QueryInterface(aOwner));
     if (URIIsLocalFile(aURI) && ownerPrincipal &&
         NS_SUCCEEDED(ownerPrincipal->CheckMayLoad(aURI, PR_FALSE))) {
-        channel->SetOwner(aOwner);
+        // One more check here.  CheckMayLoad will always return true for the
+        // system principal, but we do NOT want to inherit in that case.
+        PRBool isSystem;
+        nsCOMPtr<nsIScriptSecurityManager> secMan =
+            do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
+        if (secMan &&
+            NS_SUCCEEDED(secMan->IsSystemPrincipal(ownerPrincipal,
+                                                   &isSystem)) &&
+            !isSystem) {
+            channel->SetOwner(aOwner);
+        }
     }
 
     nsCOMPtr<nsIScriptChannel> scriptChannel = do_QueryInterface(channel);"""
46319eca807a71a30a0baa699cee004c98a54be4,57008,439034,Johnny Stenback,"Followup cleanup for bug 439034, remove dead code and some silly code too. r+sr=jonas@sicking.cc
",1218841263,"""diff --git a/content/xml/document/src/nsXMLDocument.cpp b/content/xml/document/src/nsXMLDocument.cpp
index 673c98c..4a5daf6 100644
--- a/content/xml/document/src/nsXMLDocument.cpp
+++ b/content/xml/document/src/nsXMLDocument.cpp
@@ -254,29 +254,16 @@ nsXMLDocument::OnChannelRedirect(nsIChannel *aOldChannel,
 {
   NS_PRECONDITION(aNewChannel, """"Redirecting to null channel?"""");
 
-  nsCOMPtr<nsIURI> newLocation;
-  nsresult rv = aNewChannel->GetURI(getter_AddRefs(newLocation)); // The redirected URI
-  if (NS_FAILED(rv)) 
-    return rv;
-
-  nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
-
   nsCOMPtr<nsIURI> oldURI;
-  rv = aOldChannel->GetURI(getter_AddRefs(oldURI));
+  nsresult rv = aOldChannel->GetURI(getter_AddRefs(oldURI));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIURI> newURI;
   rv = aNewChannel->GetURI(getter_AddRefs(newURI));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  rv = nsContentUtils::GetSecurityManager()->
+  return nsContentUtils::GetSecurityManager()->
     CheckSameOriginURI(oldURI, newURI, PR_TRUE);
-
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  return NS_OK;
 }
 
 NS_IMETHODIMP"""
62e76f2eae88408414f7fd0348d892c02c998592,57926,443089,Bernd,"limit mathml row- and colspans as we do for html bug 443089 r/sr=bzbarsky
",1216220538,"""diff --git a/content/html/content/src/Makefile.in b/content/html/content/src/Makefile.in
index 74e3978..83d573c 100644
--- a/content/html/content/src/Makefile.in
+++ b/content/html/content/src/Makefile.in
@@ -153,6 +153,7 @@ INCLUDES	+= \
 		-I$(srcdir)/../../../events/src \
 		-I$(srcdir)/../../../xbl/src \
 		-I$(srcdir)/../../../../layout/style \
+		-I$(srcdir)/../../../../layout/tables \
 		-I$(srcdir) \
 		$(NULL)
 
diff --git a/content/html/content/src/nsHTMLTableCellElement.cpp b/content/html/content/src/nsHTMLTableCellElement.cpp
index 4ae8ae0..d657055 100644
--- a/content/html/content/src/nsHTMLTableCellElement.cpp
+++ b/content/html/content/src/nsHTMLTableCellElement.cpp
@@ -45,6 +45,7 @@
 #include """"nsPresContext.h""""
 #include """"nsRuleData.h""""
 #include """"nsIDocument.h""""
+#include """"celldata.h""""
 
 class nsHTMLTableCellElement : public nsGenericHTMLElement,
                                public nsIDOMHTMLTableCellElement
@@ -261,9 +262,6 @@ static const nsAttrValue::EnumTable kCellScopeTable[] = {
   { 0 }
 };
 
-#define MAX_ROWSPAN 8190 // celldata.h can not handle more
-#define MAX_COLSPAN 1000 // limit as IE and opera do
-
 PRBool
 nsHTMLTableCellElement::ParseAttribute(PRInt32 aNamespaceID,
                                        nsIAtom* aAttribute,
diff --git a/layout/mathml/base/src/nsMathMLmtableFrame.cpp b/layout/mathml/base/src/nsMathMLmtableFrame.cpp
index 76810e3..76084b2 100644
--- a/layout/mathml/base/src/nsMathMLmtableFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmtableFrame.cpp
@@ -51,6 +51,7 @@
 #include """"nsTableOuterFrame.h""""
 #include """"nsTableFrame.h""""
 #include """"nsTableCellFrame.h""""
+#include """"celldata.h""""
 
 #include """"nsMathMLmtableFrame.h""""
 
@@ -775,6 +776,7 @@ nsMathMLmtdFrame::GetRowSpan()
       rowspan = value.ToInteger(&error);
       if (error || rowspan < 0)
         rowspan = 1;
+      rowspan = PR_MIN(rowspan, MAX_ROWSPAN);
     }
   }
   return rowspan;
@@ -792,7 +794,7 @@ nsMathMLmtdFrame::GetColSpan()
     if (!value.IsEmpty()) {
       PRInt32 error;
       colspan = value.ToInteger(&error);
-      if (error || colspan < 0)
+      if (error || colspan < 0 || colspan > MAX_COLSPAN)
         colspan = 1;
     }
   }
diff --git a/layout/tables/celldata.h b/layout/tables/celldata.h
index 08c3b9d..44965e3 100644
--- a/layout/tables/celldata.h
+++ b/layout/tables/celldata.h
@@ -44,6 +44,10 @@ class nsTableCellFrame;
 class nsCellMap;
 class BCCellData;
 
+
+#define MAX_ROWSPAN 8190 // the cellmap can not handle more
+#define MAX_COLSPAN 1000 // limit as IE and opera do
+
 /** 
   * Data stored by nsCellMap to rationalize rowspan and colspan cells.
   */
diff --git a/xpcom/glue/nsTArray.cpp b/xpcom/glue/nsTArray.cpp
index 5932dff..b594526 100644
--- a/xpcom/glue/nsTArray.cpp
+++ b/xpcom/glue/nsTArray.cpp
@@ -65,7 +65,7 @@ nsTArray_base::EnsureCapacity(size_type capacity, size_type elemSize) {
   // doubling algorithm may not be able to allocate it.  Additionally we
   // couldn't fit in the Header::mCapacity member. Just bail out in cases
   // like that.  We don't want to be allocating 2 GB+ arrays anyway.
-  if (capacity * elemSize > size_type(-1)/2) {
+  if ((PRUint64)capacity * elemSize > size_type(-1)/2) {
     NS_ERROR(""""Attempting to allocate excessively large array"""");
     return PR_FALSE;
   }"""
f49fbea807e18e6a5c842b6dc1caa8dfa4516897,58083,441169,Reed Loden,"Branch merge for bug 441169, bug 22310, bug 430219, bug 443095, bug 443096, bug 441703, and bug 441360.
",1215858809,"""diff --git a/intl/locale/src/nsScriptableDateFormat.cpp b/intl/locale/src/nsScriptableDateFormat.cpp
index 0334f48..6e26b90 100644
--- a/intl/locale/src/nsScriptableDateFormat.cpp
+++ b/intl/locale/src/nsScriptableDateFormat.cpp
@@ -46,6 +46,7 @@
 #include """"nsIScriptableDateFormat.h""""
 #include """"nsCRT.h""""
 #include """"nsReadableUtils.h""""
+#include """"nsIPrefService.h""""
 
 static NS_DEFINE_CID(kLocaleServiceCID, NS_LOCALESERVICE_CID);
 static NS_DEFINE_CID(kDateTimeFormatCID, NS_DATETIMEFORMAT_CID);
@@ -114,14 +115,19 @@ NS_IMETHODIMP nsScriptableDateFormat::FormatDateTime(
 
   nsCOMPtr<nsILocale> locale;
   // re-initialise locale pointer only if the locale was given explicitly
-  if (!localeName.IsEmpty()) {
-    // get locale service
-    nsCOMPtr<nsILocaleService> localeService(do_GetService(kLocaleServiceCID, &rv));
-    NS_ENSURE_SUCCESS(rv, rv);
-    // get locale
-    rv = localeService->NewLocale(localeName, getter_AddRefs(locale));
+  if (localeName.IsEmpty()) {
+    nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
     NS_ENSURE_SUCCESS(rv, rv);
+    nsCString cLocaleName;
+    rv = prefs->GetCharPref(""""general.useragent.locale"""", getter_Copies(cLocaleName));
+    CopyUTF8toUTF16(cLocaleName, localeName);
   }
+  // get locale service
+  nsCOMPtr<nsILocaleService> localeService(do_GetService(kLocaleServiceCID, &rv));
+  NS_ENSURE_SUCCESS(rv, rv);
+  // get locale
+  rv = localeService->NewLocale(localeName, getter_AddRefs(locale));
+  NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIDateTimeFormat> dateTimeFormat(do_CreateInstance(kDateTimeFormatCID, &rv));
   NS_ENSURE_SUCCESS(rv, rv);
diff --git a/layout/base/nsDocumentViewer.cpp b/layout/base/nsDocumentViewer.cpp
index 52fb626..14018f4 100644
--- a/layout/base/nsDocumentViewer.cpp
+++ b/layout/base/nsDocumentViewer.cpp
@@ -377,8 +377,6 @@ private:
   nsresult GetPopupLinkNode(nsIDOMNode** aNode);
   nsresult GetPopupImageNode(nsIImageLoadingContent** aNode);
 
-  void DumpContentToPPM(const char* aFileName);
-
   void PrepareToStartLoad(void);
 
   nsresult SyncParentSubDocMap();"""
d75750dfa6a3ac17095da4b3453cca103fd10ea9,58090,441169,Johnathan Nightingale [johnath],"Bug 441169 - [r=bzbarsky sr=dveditz]
",1215858154,"""diff --git a/docshell/resources/content/netError.xhtml b/docshell/resources/content/netError.xhtml
index 7409ed4..5d59289 100644
--- a/docshell/resources/content/netError.xhtml
+++ b/docshell/resources/content/netError.xhtml
@@ -214,8 +214,34 @@
       function addDomainErrorLink() {
         // Rather than textContent, we need to treat description as HTML
         var sd = document.getElementById(""""errorShortDescText"""");
-        if (sd)
-          sd.innerHTML = getDescription();
+        if (sd) {
+          var desc = getDescription();
+          
+          // sanitize description text - see bug 441169
+          
+          // First, find the index of the <a> tag we care about, being careful not to
+          // use an over-greedy regex
+          var re = /<a id=""""cert_domain_link"""" title=""""([^""""]+)"""">/;
+          var result = re.exec(desc);
+          if(!result)
+            return;
+          
+          // Remove sd's existing children
+          sd.textContent = """""""";
+
+          // Everything up to the link should be text content
+          sd.appendChild(document.createTextNode(desc.slice(0, result.index)));
+          
+          // Now create the link itself
+          var anchorEl = document.createElement(""""a"""");
+          anchorEl.setAttribute(""""id"""", """"cert_domain_link"""");
+          anchorEl.setAttribute(""""title"""", result[1]);
+          anchorEl.appendChild(document.createTextNode(result[1]));
+          sd.appendChild(anchorEl);
+          
+          // Finally, append text for anything after the closing </a>
+          sd.appendChild(document.createTextNode(desc.slice(desc.indexOf(""""</a>"""") + """"</a>"""".length)));
+        }
 
         var link = document.getElementById('cert_domain_link');
         if (!link)
diff --git a/docshell/test/browser/Makefile.in b/docshell/test/browser/Makefile.in
index 06ddbc2..120614a 100644
--- a/docshell/test/browser/Makefile.in
+++ b/docshell/test/browser/Makefile.in
@@ -47,6 +47,7 @@ _BROWSER_TEST_FILES =	\
 		browser_bug349769.js \
 		browser_bug388121-1.js \
 		browser_bug388121-2.js \
+		browser_bug441169.js \
 		$(NULL)
 
 # the tests below use FUEL, which is a Firefox-specific feature
diff --git a/docshell/test/browser/browser_bug441169.js b/docshell/test/browser/browser_bug441169.js
new file mode 100644
index 0000000..6a7be2b
--- /dev/null
+++ b/docshell/test/browser/browser_bug441169.js
@@ -0,0 +1,26 @@
+/* Make sure that netError won't allow HTML injection through badcert parameters.  See bug 441169. */
+var newBrowser
+
+// An edited version of the standard neterror url which attempts to
+// insert a <span id=""""test_span""""> tag into the text.  We will navigate to this page
+// and ensure that the span tag is not parsed as HTML.
+var chromeURL = """"about:neterror?e=nssBadCert&u=https%3A//test.kuix.de/&c=UTF-8&d=This%20sentence%20should%20not%20be%20parsed%20to%20include%20a%20%3Cspan%20id=%22test_span%22%3Enamed%3C/span%3E%20span%20tag.%0A%0AThe%20certificate%20is%20only%20valid%20for%20%3Ca%20id=%22cert_domain_link%22%20title=%22kuix.de%22%3Ekuix.de%3C/a%3E%0A%0A(Error%20code%3A%20ssl_error_bad_cert_domain)"""";
+
+function test() {
+  waitForExplicitFinish();
+  
+  var newTab = gBrowser.addTab();
+  gBrowser.selectedTab = newTab;
+  newBrowser = gBrowser.getBrowserForTab(newTab);
+  
+  window.addEventListener(""""DOMContentLoaded"""", checkPage, false);
+  newBrowser.contentWindow.location = chromeURL;
+}
+
+function checkPage() {
+  
+  is(newBrowser.contentDocument.getElementById(""""test_span""""), null, """"Error message should not be parsed as HTML, and hence shouldn't include the 'test_span' element."""");
+  
+  gBrowser.removeCurrentTab();
+  finish();
+}"""
36c03fad94cd7994741d02424bb2b68ce78f1166,58466,441360,Mats Palmgren,"Fix bug 441360. r+sr=vlad
",1215475222,"""diff --git a/gfx/thebes/src/gfxQuartzSurface.cpp b/gfx/thebes/src/gfxQuartzSurface.cpp
index 9375bcb..39b55ab 100644
--- a/gfx/thebes/src/gfxQuartzSurface.cpp
+++ b/gfx/thebes/src/gfxQuartzSurface.cpp
@@ -42,7 +42,7 @@
 
 gfxQuartzSurface::gfxQuartzSurface(const gfxSize& size, gfxImageFormat format,
                                    PRBool aForPrinting)
-    : mSize(size), mForPrinting(aForPrinting)
+    : mCGContext(NULL), mSize(size), mForPrinting(aForPrinting)
 {
     unsigned int width = (unsigned int) floor(size.width);
     unsigned int height = (unsigned int) floor(size.height);"""
d8da75acbe2513e2c210ac765b150c780738e763,58600,441120,Gavin Sharp,"Bug 441120 / bug 221445: don't split URLs on '|' when passed on the command line, r=mconnor, r=dveditz
",1215117024,"""diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
index 35c2f08..811337e 100644
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -673,7 +673,13 @@ function BrowserStartup()
   gBrowser = document.getElementById(""""content"""");
 
   var uriToLoad = null;
-  // Check for window.arguments[0]. If present, use that for uriToLoad.
+
+  // window.arguments[0]: URI to load (string), or an nsISupportsArray of
+  //                      nsISupportsStrings to load
+  //                 [1]: character set (string)
+  //                 [2]: referrer (nsIURI)
+  //                 [3]: postData (nsIInputStream)
+  //                 [4]: allowThirdPartyFixup (bool)
   if (""""arguments"""" in window && window.arguments[0])
     uriToLoad = window.arguments[0];
 
@@ -686,9 +692,26 @@ function BrowserStartup()
 #else
 # only load url passed in when we're not page cycling
   if (uriToLoad && !gIsLoadingBlank) {
-    if (window.arguments.length >= 3)
+    if (uriToLoad instanceof Components.interfaces.nsISupportsArray) {
+      var count = uriToLoad.Count();
+      var specs = [];
+      for (var i = 0; i < count; i++) {
+        var urisstring = uriToLoad.GetElementAt(i).QueryInterface(Components.interfaces.nsISupportsString);
+        specs.push(urisstring.data);
+      }
+
+      // This function throws for certain malformed URIs, so use exception handling
+      // so that we don't disrupt startup
+      try {
+        gBrowser.loadTabs(specs, false, true);
+      } catch (e) {}
+    }
+    else if (window.arguments.length >= 3) {
       loadURI(uriToLoad, window.arguments[2], window.arguments[3] || null,
               window.arguments[4] || false);
+    }
+    // Note: loadOneOrMoreURIs *must not* be called if window.arguments.length >= 3.
+    // Such callers expect that window.arguments[0] is handled as a single URI.
     else
       loadOneOrMoreURIs(uriToLoad);
   }
@@ -4308,7 +4331,9 @@ nsBrowserAccess.prototype =
         // FIXME: Bug 408379. So how come this doesn't send the
         // referrer like the other loads do?
         var url = aURI ? aURI.spec : """"about:blank"""";
-        newWindow = openDialog(getBrowserURL(), """"_blank"""", """"all,dialog=no"""", url);
+        // Pass all params to openDialog to ensure that """"url"""" isn't passed through
+        // loadOneOrMoreURIs, which splits based on """"|""""
+        newWindow = openDialog(getBrowserURL(), """"_blank"""", """"all,dialog=no"""", url, null, null, null);
         break;
       case Ci.nsIBrowserDOMWindow.OPEN_NEWTAB :
         var win = this._getMostRecentBrowserWindow();
diff --git a/browser/components/nsBrowserContentHandler.js b/browser/components/nsBrowserContentHandler.js
index ee2e43f..0dad693 100644
--- a/browser/components/nsBrowserContentHandler.js
+++ b/browser/components/nsBrowserContentHandler.js
@@ -176,17 +176,60 @@ function copyPrefOverride() {
   }
 }
 
-function openWindow(parent, url, target, features, args) {
+// Flag used to indicate that the arguments to openWindow can be passed directly.
+const NO_EXTERNAL_URIS = 1;
+
+function openWindow(parent, url, target, features, args, noExternalArgs) {
   var wwatch = Components.classes[""""@mozilla.org/embedcomp/window-watcher;1""""]
                          .getService(nsIWindowWatcher);
 
-  var argstring;
-  if (args) {
-    argstring = Components.classes[""""@mozilla.org/supports-string;1""""]
+  if (noExternalArgs == NO_EXTERNAL_URIS) {
+    // Just pass in the defaultArgs directly
+    var argstring;
+    if (args) {
+      argstring = Components.classes[""""@mozilla.org/supports-string;1""""]
                             .createInstance(nsISupportsString);
-    argstring.data = args;
+      argstring.data = args;
+    }
+
+    return wwatch.openWindow(parent, url, target, features, argstring);
+  }
+  
+  // Pass an array to avoid the browser """"|""""-splitting behavior.
+  var argArray = Components.classes[""""@mozilla.org/supports-array;1""""]
+                    .createInstance(Components.interfaces.nsISupportsArray);
+
+  // add args to the arguments array
+  var stringArgs = null;
+  if (args instanceof Array) // array
+    stringArgs = args;
+  else if (args) // string
+    stringArgs = [args];
+
+  if (stringArgs) {
+    // put the URIs into argArray
+    var uriArray = Components.classes[""""@mozilla.org/supports-array;1""""]
+                       .createInstance(Components.interfaces.nsISupportsArray);
+    stringArgs.forEach(function (uri) {
+      var sstring = Components.classes[""""@mozilla.org/supports-string;1""""]
+                              .createInstance(nsISupportsString);
+      sstring.data = uri;
+      uriArray.AppendElement(sstring);
+    });
+    argArray.AppendElement(uriArray);
+  } else {
+    argArray.AppendElement(null);
   }
-  return wwatch.openWindow(parent, url, target, features, argstring);
+
+  // Pass these as null to ensure that we always trigger the """"single URL""""
+  // behavior in browser.js's BrowserStartup (which handles the window
+  // arguments)
+  argArray.AppendElement(null); // charset
+  argArray.AppendElement(null); // referer
+  argArray.AppendElement(null); // postData
+  argArray.AppendElement(null); // allowThirdPartyFixup
+
+  return wwatch.openWindow(parent, url, target, features, argArray);
 }
 
 function openPreferences() {
@@ -316,9 +359,10 @@ var nsBrowserContentHandler = {
   /* nsICommandLineHandler */
   handle : function bch_handle(cmdLine) {
     if (cmdLine.handleFlag(""""browser"""", false)) {
+      // Passing defaultArgs, so use NO_EXTERNAL_URIS
       openWindow(null, this.chromeURL, """"_blank"""",
                  """"chrome,dialog=no,all"""" + this.getFeatures(cmdLine),
-                 this.defaultArgs);
+                 this.defaultArgs, NO_EXTERNAL_URIS);
       cmdLine.preventDefault = true;
     }
 
@@ -379,9 +423,10 @@ var nsBrowserContentHandler = {
           if (remoteParams[0].toLowerCase() != """"openbrowser"""")
             throw NS_ERROR_ABORT;
 
+          // Passing defaultArgs, so use NO_EXTERNAL_URIS
           openWindow(null, this.chromeURL, """"_blank"""",
                      """"chrome,dialog=no,all"""" + this.getFeatures(cmdLine),
-                     this.defaultArgs);
+                     this.defaultArgs, NO_EXTERNAL_URIS);
           break;
 
         default:
@@ -442,7 +487,7 @@ var nsBrowserContentHandler = {
         var netutil = Components.classes[""""@mozilla.org/network/util;1""""]
                                 .getService(nsINetUtil);
         if (!netutil.URIChainHasFlags(uri, URI_INHERITS_SECURITY_CONTEXT)) {
-          openWindow(null, uri.spec, """"_blank"""", features, """""""");
+          openWindow(null, uri.spec, """"_blank"""", features);
           cmdLine.preventDefault = true;
         }
       }
@@ -774,23 +819,19 @@ var nsDefaultCommandLineHandler = {
         }
       }
 
-      var speclist = [];
-      for (uri in urilist) {
-        if (shouldLoadURI(urilist[uri]))
-          speclist.push(urilist[uri].spec);
-      }
-
-      if (speclist.length) {
+      var URLlist = urilist.filter(shouldLoadURI).map(function (u) u.spec);
+      if (URLlist.length) {
         openWindow(null, nsBrowserContentHandler.chromeURL, """"_blank"""",
                    """"chrome,dialog=no,all"""" + nsBrowserContentHandler.getFeatures(cmdLine),
-                   speclist.join(""""|""""));
+                   URLlist);
       }
 
     }
     else if (!cmdLine.preventDefault) {
+      // Passing defaultArgs, so use NO_EXTERNAL_URIS
       openWindow(null, nsBrowserContentHandler.chromeURL, """"_blank"""",
                  """"chrome,dialog=no,all"""" + nsBrowserContentHandler.getFeatures(cmdLine),
-                 nsBrowserContentHandler.defaultArgs);
+                 nsBrowserContentHandler.defaultArgs, NO_EXTERNAL_URIS);
     }
   },
 """
24a9995cdd329072840cab2870c3c6a5587f4568,58918,436741,Blake Kaplan,"Do not attempt to lock a non-native object. bug 436741, r=brendan
",1214389415,"""diff --git a/js/src/jsobj.cpp b/js/src/jsobj.cpp
index 46eb54f..696aab8 100644
--- a/js/src/jsobj.cpp
+++ b/js/src/jsobj.cpp
@@ -3343,7 +3343,8 @@ js_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, jsid id, uintN flags,
                         /* Resolved: juggle locks and lookup id again. */
                         if (obj2 != obj) {
                             JS_UNLOCK_OBJ(cx, obj);
-                            JS_LOCK_OBJ(cx, obj2);
+                            if (OBJ_IS_NATIVE(obj2))
+                                JS_LOCK_OBJ(cx, obj2);
                         }
                         protoIndex = 0;
                         for (proto = start; proto && proto != obj2;
@@ -3354,7 +3355,6 @@ js_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, jsid id, uintN flags,
                         if (!MAP_IS_NATIVE(&scope->map)) {
                             /* Whoops, newresolve handed back a foreign obj2. */
                             JS_ASSERT(obj2 != obj);
-                            JS_UNLOCK_OBJ(cx, obj2);
                             ok = OBJ_LOOKUP_PROPERTY(cx, obj2, id, objp, propp);
                             if (!ok || *propp)
                                 goto cleanup;
@@ -3375,7 +3375,8 @@ js_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, jsid id, uintN flags,
                             JS_ASSERT(obj2 == scope->object);
                             obj = obj2;
                         } else if (obj2 != obj) {
-                            JS_UNLOCK_OBJ(cx, obj2);
+                            if (OBJ_IS_NATIVE(obj2))
+                                JS_UNLOCK_OBJ(cx, obj2);
                             JS_LOCK_OBJ(cx, obj);
                         }
                     }"""
46039fd7e090336cadd7a6f4f2880882f80d9a3f,60134,430658,mozilla.mano@sent.com,"Bug 430658, r+a=mconnor.
",1209677922,"""diff --git a/browser/components/feeds/src/FeedWriter.js b/browser/components/feeds/src/FeedWriter.js
index 424a25e..c6bd595 100755
--- a/browser/components/feeds/src/FeedWriter.js
+++ b/browser/components/feeds/src/FeedWriter.js
@@ -394,8 +394,12 @@ FeedWriter.prototype = {
    */
   _setTitleText: function FW__setTitleText(container) {
     if (container.title) {
-      this._setContentText(TITLE_ID, container.title.plainText());
-      this._document.title = container.title.plainText();
+      var title = container.title.plainText();
+      this._setContentText(TITLE_ID, title);
+      this._contentSandbox.document = this._document;
+      this._contentSandbox.title = title;
+      var codeStr = """"document.title = title;""""
+      Cu.evalInSandbox(codeStr, this._contentSandbox);
     }
 
     var feed = container.QueryInterface(Ci.nsIFeed);
@@ -424,19 +428,21 @@ FeedWriter.prototype = {
                                                [parts.getPropertyAsAString(""""title"""")]);
       this._contentSandbox.feedTitleLink = feedTitleLink;
       this._contentSandbox.titleText = titleText;
-      var codeStr = """"feedTitleLink.setAttribute('title', titleText);"""";
+      this._contentSandbox.feedTitleText = this._document.getElementById(""""feedTitleText"""");
+      this._contentSandbox.titleImageWidth = parseInt(parts.getPropertyAsAString(""""width"""")) + 15;
+
+      // Fix the margin on the main title, so that the image doesn't run over
+      // the underline
+      var codeStr = """"feedTitleLink.setAttribute('title', titleText); """" +
+                    """"feedTitleText.style.marginRight = titleImageWidth + 'px';"""";
       Cu.evalInSandbox(codeStr, this._contentSandbox);
       this._contentSandbox.feedTitleLink = null;
       this._contentSandbox.titleText = null;
+      this._contentSandbox.feedTitleText = null;
+      this._contentSandbox.titleImageWidth = null;
 
       this._safeSetURIAttribute(feedTitleLink, """"href"""", 
                                 parts.getPropertyAsAString(""""link""""));
-
-      // Fix the margin on the main title, so that the image doesn't run over
-      // the underline
-      var feedTitleText = this._document.getElementById(""""feedTitleText"""");
-      var titleImageWidth = parseInt(parts.getPropertyAsAString(""""width"""")) + 15;
-      feedTitleText.style.marginRight = titleImageWidth + """"px"""";
     }
     catch (e) {
       LOG(""""Failed to set Title Image (this is benign): """" + e);
@@ -959,7 +965,6 @@ FeedWriter.prototype = {
 
       default:
         codeStr = """"header.className = 'feedBackground'; """";
-        header.className = """"feedBackground"""";
     }
 
 """
c78b818a5f1a5d2aba476c410c402046983f0a0d,60702,410156,rob_strong@exchangecode.com,"Relanding Bug 410156 - r=bsmedberg, approval1.9=beltzner, blocking-firefox3=beltzner
",1208551429,"""diff --git a/toolkit/components/commandlines/src/nsCommandLine.cpp b/toolkit/components/commandlines/src/nsCommandLine.cpp
index 70e34dc..c4b7933 100644
--- a/toolkit/components/commandlines/src/nsCommandLine.cpp
+++ b/toolkit/components/commandlines/src/nsCommandLine.cpp
@@ -95,6 +95,7 @@ protected:
 					void *aClosure);
 
   void appendArg(const char* arg);
+  void resolveShortcutURL(nsILocalFile* aFile, nsACString& outURL);
   nsresult EnumerateHandlers(EnumerateHandlersCallback aCallback, void *aClosure);
   nsresult EnumerateValidators(EnumerateValidatorsCallback aCallback, void *aClosure);
 
@@ -442,16 +443,26 @@ nsCommandLine::ResolveURI(const nsAString& aArgument, nsIURI* *aResult)
   nsCOMPtr<nsIIOService> io = do_GetIOService();
   NS_ENSURE_TRUE(io, NS_ERROR_OUT_OF_MEMORY);
 
+  nsCOMPtr<nsIURI> workingDirURI;
+  if (mWorkingDir) {
+    io->NewFileURI(mWorkingDir, getter_AddRefs(workingDirURI));
+  }
+
   nsCOMPtr<nsILocalFile> lf (do_CreateInstance(NS_LOCAL_FILE_CONTRACTID));
   rv = lf->InitWithPath(aArgument);
   if (NS_SUCCEEDED(rv)) {
     lf->Normalize();
-    return io->NewFileURI(lf, aResult);
-  }
+    nsCAutoString url;
+    // Try to resolve the url for .url files.
+    resolveShortcutURL(lf, url);
+    if (!url.IsEmpty()) {
+      return io->NewURI(url,
+                        nsnull,
+                        workingDirURI,
+                        aResult);
+    }
 
-  nsCOMPtr<nsIURI> workingDirURI;
-  if (mWorkingDir) {
-    io->NewFileURI(mWorkingDir, getter_AddRefs(workingDirURI));
+    return io->NewFileURI(lf, aResult);
   }
 
   return io->NewURI(NS_ConvertUTF16toUTF8(aArgument),
@@ -477,6 +488,22 @@ nsCommandLine::appendArg(const char* arg)
   mArgs.AppendString(warg);
 }
 
+void
+nsCommandLine::resolveShortcutURL(nsILocalFile* aFile, nsACString& outURL)
+{
+  nsCOMPtr<nsIFileProtocolHandler> fph;
+  nsresult rv = NS_GetFileProtocolHandler(getter_AddRefs(fph));
+  if (NS_FAILED(rv))
+    return;
+
+  nsCOMPtr<nsIURI> uri;
+  rv = fph->ReadURLFile(aFile, getter_AddRefs(uri));
+  if (NS_FAILED(rv))
+    return;
+
+  uri->GetSpec(outURL);
+}
+
 NS_IMETHODIMP
 nsCommandLine::Init(PRInt32 argc, char** argv, nsIFile* aWorkingDir,
                     PRUint32 aState)
diff --git a/toolkit/components/commandlines/test/Makefile.in b/toolkit/components/commandlines/test/Makefile.in
index 1e2e001..3076204 100644
--- a/toolkit/components/commandlines/test/Makefile.in
+++ b/toolkit/components/commandlines/test/Makefile.in
@@ -50,4 +50,12 @@ XPCSHELL_TESTS = \
                  unit \
                  $(NULL)
 
+ifeq ($(OS_ARCH),WINNT)
+XPCSHELL_TESTS += unit/win
+else
+ifneq (,$(filter-out OS2 Darwin,$(OS_ARCH)))
+XPCSHELL_TESTS += unit/unix
+endif
+endif
+
 include $(topsrcdir)/config/rules.mk
diff --git a/toolkit/components/commandlines/test/unit/unix/test_bug410156.js b/toolkit/components/commandlines/test/unit/unix/test_bug410156.js
new file mode 100644
index 0000000..82a2399
--- /dev/null
+++ b/toolkit/components/commandlines/test/unit/unix/test_bug410156.js
@@ -0,0 +1,43 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Command Line tests.
+ *
+ * The Initial Developer of the Original Code is
+ * Robert Strong <robert_bugzila@gmail.com>.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+function run_test() {
+  var clClass = Components.classes[""""@mozilla.org/toolkit/command-line;1""""];
+  var commandLine = clClass.createInstance();
+  var urlFile = do_get_file(""""toolkit/components/commandlines/test/unit/data/test_bug410156.desktop"""");
+  var uri = commandLine.resolveURI(urlFile.path);
+  do_check_eq(uri.spec, """"http://www.bug410156.com/"""");
+}
diff --git a/toolkit/components/commandlines/test/unit/win/test_bug410156.js b/toolkit/components/commandlines/test/unit/win/test_bug410156.js
new file mode 100644
index 0000000..d594416
--- /dev/null
+++ b/toolkit/components/commandlines/test/unit/win/test_bug410156.js
@@ -0,0 +1,43 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Command Line tests.
+ *
+ * The Initial Developer of the Original Code is
+ * Robert Strong <robert_bugzila@gmail.com>.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+function run_test() {
+  var clClass = Components.classes[""""@mozilla.org/toolkit/command-line;1""""];
+  var commandLine = clClass.createInstance();
+  var urlFile = do_get_file(""""toolkit/components/commandlines/test/unit/data/test_bug410156.url"""");
+  var uri = commandLine.resolveURI(urlFile.path);
+  do_check_eq(uri.spec, """"http://www.bug410156.com/"""");
+}"""
2ab18beb7d1afcf62f1be2ec82a2e388e320256f,60746,410156,rob_strong@exchangecode.com,"Backing out Bug 410156 due to test bustage
",1208474012,"""diff --git a/toolkit/components/commandlines/test/unit/test_bug410156.js.in b/toolkit/components/commandlines/test/unit/test_bug410156.js.in
deleted file mode 100644
index f9dc722..0000000
--- a/toolkit/components/commandlines/test/unit/test_bug410156.js.in
+++ /dev/null
@@ -1,55 +0,0 @@
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the """"License""""); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an """"AS IS"""" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Command Line tests.
- *
- * The Initial Developer of the Original Code is
- * Robert Strong <robert_bugzila@gmail.com>.
- * Portions created by the Initial Developer are Copyright (C) 2007
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the """"GPL""""), or
- * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-function run_test() {
-  const Cc = Components.classes;
-  var clClass = Cc[""""@mozilla.org/toolkit/command-line;1""""];
-  var commandLine = clClass.createInstance();
-
-#ifdef XP_WIN
-  var urlFile = do_get_file(""""toolkit/components/commandlines/test/unit/data/test_bug410156.url"""");
-  var uri = commandLine.resolveURI(urlFile.path);
-  do_check_eq(uri.spec, """"http://www.bug410156.com/"""");
-#endif
-
-#ifdef XP_UNIX
-#ifndef XP_MACOSX
-  var urlFile = do_get_file(""""toolkit/components/commandlines/test/unit/data/test_bug410156.desktop"""");
-  var uri = commandLine.resolveURI(urlFile.path);
-  do_check_eq(uri.spec, """"http://www.bug410156.com/"""");
-#endif
-#endif
-}"""
a99bc0593243eae143e88a96165d331fe3219f79,60747,410156,rob_strong@exchangecode.com,"Backing out Bug 410156 due to test bustage
",1208473506,"""diff --git a/toolkit/components/commandlines/src/nsCommandLine.cpp b/toolkit/components/commandlines/src/nsCommandLine.cpp
index c4b7933..70e34dc 100644
--- a/toolkit/components/commandlines/src/nsCommandLine.cpp
+++ b/toolkit/components/commandlines/src/nsCommandLine.cpp
@@ -95,7 +95,6 @@ protected:
 					void *aClosure);
 
   void appendArg(const char* arg);
-  void resolveShortcutURL(nsILocalFile* aFile, nsACString& outURL);
   nsresult EnumerateHandlers(EnumerateHandlersCallback aCallback, void *aClosure);
   nsresult EnumerateValidators(EnumerateValidatorsCallback aCallback, void *aClosure);
 
@@ -443,28 +442,18 @@ nsCommandLine::ResolveURI(const nsAString& aArgument, nsIURI* *aResult)
   nsCOMPtr<nsIIOService> io = do_GetIOService();
   NS_ENSURE_TRUE(io, NS_ERROR_OUT_OF_MEMORY);
 
-  nsCOMPtr<nsIURI> workingDirURI;
-  if (mWorkingDir) {
-    io->NewFileURI(mWorkingDir, getter_AddRefs(workingDirURI));
-  }
-
   nsCOMPtr<nsILocalFile> lf (do_CreateInstance(NS_LOCAL_FILE_CONTRACTID));
   rv = lf->InitWithPath(aArgument);
   if (NS_SUCCEEDED(rv)) {
     lf->Normalize();
-    nsCAutoString url;
-    // Try to resolve the url for .url files.
-    resolveShortcutURL(lf, url);
-    if (!url.IsEmpty()) {
-      return io->NewURI(url,
-                        nsnull,
-                        workingDirURI,
-                        aResult);
-    }
-
     return io->NewFileURI(lf, aResult);
   }
 
+  nsCOMPtr<nsIURI> workingDirURI;
+  if (mWorkingDir) {
+    io->NewFileURI(mWorkingDir, getter_AddRefs(workingDirURI));
+  }
+
   return io->NewURI(NS_ConvertUTF16toUTF8(aArgument),
                     nsnull,
                     workingDirURI,
@@ -488,22 +477,6 @@ nsCommandLine::appendArg(const char* arg)
   mArgs.AppendString(warg);
 }
 
-void
-nsCommandLine::resolveShortcutURL(nsILocalFile* aFile, nsACString& outURL)
-{
-  nsCOMPtr<nsIFileProtocolHandler> fph;
-  nsresult rv = NS_GetFileProtocolHandler(getter_AddRefs(fph));
-  if (NS_FAILED(rv))
-    return;
-
-  nsCOMPtr<nsIURI> uri;
-  rv = fph->ReadURLFile(aFile, getter_AddRefs(uri));
-  if (NS_FAILED(rv))
-    return;
-
-  uri->GetSpec(outURL);
-}
-
 NS_IMETHODIMP
 nsCommandLine::Init(PRInt32 argc, char** argv, nsIFile* aWorkingDir,
                     PRUint32 aState)
diff --git a/toolkit/components/commandlines/test/Makefile.in b/toolkit/components/commandlines/test/Makefile.in
index 09eccc7..1e2e001 100644
--- a/toolkit/components/commandlines/test/Makefile.in
+++ b/toolkit/components/commandlines/test/Makefile.in
@@ -45,16 +45,9 @@ VPATH		= @srcdir@
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= test_harness_commandlines
-TESTROOT	= $(shell cd $(DEPTH) && pwd)/_tests/xpcshell-simple/$(MODULE)
 
 XPCSHELL_TESTS = \
                  unit \
                  $(NULL)
 
 include $(topsrcdir)/config/rules.mk
-
-ifneq (,$(filter-out OS2 Darwin,$(OS_ARCH)))
-# Hack to allow preprocessing of test_bug410156.js
-libs:: unit/test_bug410156.js.in
-	$(PYTHON) $(MOZILLA_DIR)/config/Preprocessor.py $(DEFINES) $(ACDEFINES) $^ > $(TESTROOT)/unit/test_bug410156.js
-endif"""
7cd72d12b1717cbdf052b514dab60e87a449b56e,60748,410156,rob_strong@exchangecode.com,"Bustage fix for Bug 410156
",1208473193,"""diff --git a/toolkit/components/commandlines/test/Makefile.in b/toolkit/components/commandlines/test/Makefile.in
index 224b4f5..09eccc7 100644
--- a/toolkit/components/commandlines/test/Makefile.in
+++ b/toolkit/components/commandlines/test/Makefile.in
@@ -53,6 +53,8 @@ XPCSHELL_TESTS = \
 
 include $(topsrcdir)/config/rules.mk
 
+ifneq (,$(filter-out OS2 Darwin,$(OS_ARCH)))
 # Hack to allow preprocessing of test_bug410156.js
 libs:: unit/test_bug410156.js.in
 	$(PYTHON) $(MOZILLA_DIR)/config/Preprocessor.py $(DEFINES) $(ACDEFINES) $^ > $(TESTROOT)/unit/test_bug410156.js
+endif"""
b0d96465cb1b6647adbffb9e9716c6acf3b3706c,60752,410156,rob_strong@exchangecode.com,"Bug 410156 - r=bsmedberg, approval1.9=beltzner, blocking-firefox3=beltzner
",1208470819,"""diff --git a/toolkit/components/commandlines/src/nsCommandLine.cpp b/toolkit/components/commandlines/src/nsCommandLine.cpp
index 70e34dc..c4b7933 100644
--- a/toolkit/components/commandlines/src/nsCommandLine.cpp
+++ b/toolkit/components/commandlines/src/nsCommandLine.cpp
@@ -95,6 +95,7 @@ protected:
 					void *aClosure);
 
   void appendArg(const char* arg);
+  void resolveShortcutURL(nsILocalFile* aFile, nsACString& outURL);
   nsresult EnumerateHandlers(EnumerateHandlersCallback aCallback, void *aClosure);
   nsresult EnumerateValidators(EnumerateValidatorsCallback aCallback, void *aClosure);
 
@@ -442,16 +443,26 @@ nsCommandLine::ResolveURI(const nsAString& aArgument, nsIURI* *aResult)
   nsCOMPtr<nsIIOService> io = do_GetIOService();
   NS_ENSURE_TRUE(io, NS_ERROR_OUT_OF_MEMORY);
 
+  nsCOMPtr<nsIURI> workingDirURI;
+  if (mWorkingDir) {
+    io->NewFileURI(mWorkingDir, getter_AddRefs(workingDirURI));
+  }
+
   nsCOMPtr<nsILocalFile> lf (do_CreateInstance(NS_LOCAL_FILE_CONTRACTID));
   rv = lf->InitWithPath(aArgument);
   if (NS_SUCCEEDED(rv)) {
     lf->Normalize();
-    return io->NewFileURI(lf, aResult);
-  }
+    nsCAutoString url;
+    // Try to resolve the url for .url files.
+    resolveShortcutURL(lf, url);
+    if (!url.IsEmpty()) {
+      return io->NewURI(url,
+                        nsnull,
+                        workingDirURI,
+                        aResult);
+    }
 
-  nsCOMPtr<nsIURI> workingDirURI;
-  if (mWorkingDir) {
-    io->NewFileURI(mWorkingDir, getter_AddRefs(workingDirURI));
+    return io->NewFileURI(lf, aResult);
   }
 
   return io->NewURI(NS_ConvertUTF16toUTF8(aArgument),
@@ -477,6 +488,22 @@ nsCommandLine::appendArg(const char* arg)
   mArgs.AppendString(warg);
 }
 
+void
+nsCommandLine::resolveShortcutURL(nsILocalFile* aFile, nsACString& outURL)
+{
+  nsCOMPtr<nsIFileProtocolHandler> fph;
+  nsresult rv = NS_GetFileProtocolHandler(getter_AddRefs(fph));
+  if (NS_FAILED(rv))
+    return;
+
+  nsCOMPtr<nsIURI> uri;
+  rv = fph->ReadURLFile(aFile, getter_AddRefs(uri));
+  if (NS_FAILED(rv))
+    return;
+
+  uri->GetSpec(outURL);
+}
+
 NS_IMETHODIMP
 nsCommandLine::Init(PRInt32 argc, char** argv, nsIFile* aWorkingDir,
                     PRUint32 aState)
diff --git a/toolkit/components/commandlines/test/Makefile.in b/toolkit/components/commandlines/test/Makefile.in
index 1e2e001..224b4f5 100644
--- a/toolkit/components/commandlines/test/Makefile.in
+++ b/toolkit/components/commandlines/test/Makefile.in
@@ -45,9 +45,14 @@ VPATH		= @srcdir@
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= test_harness_commandlines
+TESTROOT	= $(shell cd $(DEPTH) && pwd)/_tests/xpcshell-simple/$(MODULE)
 
 XPCSHELL_TESTS = \
                  unit \
                  $(NULL)
 
 include $(topsrcdir)/config/rules.mk
+
+# Hack to allow preprocessing of test_bug410156.js
+libs:: unit/test_bug410156.js.in
+	$(PYTHON) $(MOZILLA_DIR)/config/Preprocessor.py $(DEFINES) $(ACDEFINES) $^ > $(TESTROOT)/unit/test_bug410156.js
diff --git a/toolkit/components/commandlines/test/unit/data/test_bug410156.desktop b/toolkit/components/commandlines/test/unit/data/test_bug410156.desktop
new file mode 100644
index 0000000..1847cdd
--- /dev/null
+++ b/toolkit/components/commandlines/test/unit/data/test_bug410156.desktop
@@ -0,0 +1,7 @@
+[Desktop Entry]
+Version=1.0
+Encoding=UTF-8
+Name=test_bug410156
+Type=Link
+URL=http://www.bug410156.com/
+Icon=gnome-fs-bookmark
diff --git a/toolkit/components/commandlines/test/unit/data/test_bug410156.url b/toolkit/components/commandlines/test/unit/data/test_bug410156.url
new file mode 100644
index 0000000..6920e1f
--- /dev/null
+++ b/toolkit/components/commandlines/test/unit/data/test_bug410156.url
@@ -0,0 +1,9 @@
+[InternetShortcut]
+URL=http://www.bug410156.com/
+IDList=
+HotKey=0
+[{000214A0-0000-0000-C000-000000000046}]
+Prop3=19,2
+[InternetShortcut.A]
+[InternetShortcut.W]
+URL=http://www.bug410156.com/
diff --git a/toolkit/components/commandlines/test/unit/test_bug410156.js.in b/toolkit/components/commandlines/test/unit/test_bug410156.js.in
new file mode 100644
index 0000000..f9dc722
--- /dev/null
+++ b/toolkit/components/commandlines/test/unit/test_bug410156.js.in
@@ -0,0 +1,55 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Command Line tests.
+ *
+ * The Initial Developer of the Original Code is
+ * Robert Strong <robert_bugzila@gmail.com>.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+function run_test() {
+  const Cc = Components.classes;
+  var clClass = Cc[""""@mozilla.org/toolkit/command-line;1""""];
+  var commandLine = clClass.createInstance();
+
+#ifdef XP_WIN
+  var urlFile = do_get_file(""""toolkit/components/commandlines/test/unit/data/test_bug410156.url"""");
+  var uri = commandLine.resolveURI(urlFile.path);
+  do_check_eq(uri.spec, """"http://www.bug410156.com/"""");
+#endif
+
+#ifdef XP_UNIX
+#ifndef XP_MACOSX
+  var urlFile = do_get_file(""""toolkit/components/commandlines/test/unit/data/test_bug410156.desktop"""");
+  var uri = commandLine.resolveURI(urlFile.path);
+  do_check_eq(uri.spec, """"http://www.bug410156.com/"""");
+#endif
+#endif
+}"""
df7951b2bafc97be9792fa6a14ce6b4935ef23a1,60791,411433,gavin@gavinsharp.com,"Bug 411433: properly handle file location URL in directory listings, patch by Masahiro Yamada <masa141421356@gmail.com>, r=biesi, sr=bzbarsky, a=damon
",1208377403,"""diff --git a/netwerk/streamconv/converters/nsIndexedToHTML.cpp b/netwerk/streamconv/converters/nsIndexedToHTML.cpp
index 0856ddc..6109b03 100644
--- a/netwerk/streamconv/converters/nsIndexedToHTML.cpp
+++ b/netwerk/streamconv/converters/nsIndexedToHTML.cpp
@@ -571,7 +571,10 @@ nsIndexedToHTML::OnStartRequest(nsIRequest* request, nsISupports *aContext) {
         // will prematurely close the string.  Go ahead an
         // add a base href.
         buffer.AppendLiteral(""""<base href=\"""""""");
-        AppendASCIItoUTF16(baseUri, buffer);
+        NS_ConvertUTF8toUTF16 utf16BaseURI(baseUri);
+        nsString htmlEscapedUri;
+        htmlEscapedUri.Adopt(nsEscapeHTML2(utf16BaseURI.get(), utf16BaseURI.Length()));
+        buffer.Append(htmlEscapedUri);
         buffer.AppendLiteral(""""\"""">\n"""");
     }
     else
@@ -601,7 +604,11 @@ nsIndexedToHTML::OnStartRequest(nsIRequest* request, nsISupports *aContext) {
         if (NS_FAILED(rv)) return rv;
 
         buffer.AppendLiteral(""""<p id=\""""UI_goUp\""""><a class=\""""up\"""" href=\"""""""");
-        AppendASCIItoUTF16(parentStr, buffer);
+
+        NS_ConvertUTF8toUTF16 utf16ParentStr(parentStr);
+        nsString htmlParentStr;
+        htmlParentStr.Adopt(nsEscapeHTML2(utf16ParentStr.get(), utf16ParentStr.Length()));
+        buffer.Append(htmlParentStr);
         buffer.AppendLiteral(""""\"""">"""");
         AppendNonAsciiToNCR(parentText, buffer);
         buffer.AppendLiteral(""""</a></p>\n"""");
@@ -894,8 +901,10 @@ nsIndexedToHTML::OnIndexAvailable(nsIRequest *aRequest,
         escFlags = esc_Forced | esc_OnlyASCII | esc_AlwaysCopy | esc_FileBaseName | esc_Colon | esc_Directory;
     }
     NS_EscapeURL(utf8UnEscapeSpec.get(), utf8UnEscapeSpec.Length(), escFlags, escapeBuf);
-
-    AppendUTF8toUTF16(escapeBuf, pushBuffer);
+    NS_ConvertUTF8toUTF16 utf16URI(escapeBuf);
+    nsString htmlEscapedURL;
+    htmlEscapedURL.Adopt(nsEscapeHTML2(utf16URI.get(), utf16URI.Length()));
+    pushBuffer.Append(htmlEscapedURL);
 
     pushBuffer.AppendLiteral(""""\"""">"""");
 """
86bd455bbb34c41688ae1b8d40cbd03abf81e73a,61823,418356,jst@mozilla.org,"Followup fix for bug 418356. Re-enable loading file:// URIs using the subscript loader. r+sr=bzbarsky@mit.edu
",1206076045,"""diff --git a/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp b/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp
index 78540d3..632fe32 100644
--- a/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp
+++ b/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp
@@ -54,14 +54,17 @@
 #include """"nsDependentString.h""""
 #include """"nsAutoPtr.h""""
 #include """"nsNetUtil.h""""
+#include """"nsIProtocolHandler.h""""
+#include """"nsIFileURL.h""""
 
 #include """"jsapi.h""""
+#include """"jsdbgapi.h""""
 
 /* load() error msgs, XXX localize? */
 #define LOAD_ERROR_NOSERVICE """"Error creating IO Service.""""
 #define LOAD_ERROR_NOURI """"Error creating URI (invalid URL scheme?)""""
 #define LOAD_ERROR_NOSCHEME """"Failed to get URI scheme.  This is bad.""""
-#define LOAD_ERROR_URI_NOT_CHROME """"Trying to load a non-chrome URI.""""
+#define LOAD_ERROR_URI_NOT_LOCAL """"Trying to load a non-local URI.""""
 #define LOAD_ERROR_NOSTREAM  """"Error opening input stream (invalid filename?)""""
 #define LOAD_ERROR_NOCONTENT """"ContentLength not available (not a local URL?)""""
 #define LOAD_ERROR_BADREAD   """"File Read Error.""""
@@ -139,11 +142,10 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
         rv = secman->GetSystemPrincipal(getter_AddRefs(mSystemPrincipal));
         if (NS_FAILED(rv) || !mSystemPrincipal)
             return rv;
-
     }
 
     JSAutoRequest ar(cx);
-    
+
     char     *url;
     JSObject *target_obj = nsnull;
     ok = JS_ConvertArguments (cx, argc, argv, """"s / o"""", &url, &target_obj);
@@ -153,7 +155,7 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
         /* let the exception raised by JS_ConvertArguments show through */
         return NS_OK;
     }
-    
+
     if (!target_obj)
     {
         /* if the user didn't provide an object to eval onto, find the global
@@ -225,6 +227,25 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
     nsCAutoString uriStr;
     nsCAutoString scheme;
 
+    JSStackFrame* frame = nsnull;
+    JSScript* script = nsnull;
+
+    // Figure out who's calling us
+    do
+    {
+        frame = JS_FrameIterator(cx, &frame);
+
+        if (frame)
+            script = JS_GetFrameScript(cx, frame);
+    } while (frame && !script);
+
+    if (!script)
+    {
+        // No script means we don't know who's calling, bail.
+
+        return NS_ERROR_FAILURE;
+    }
+
     nsCOMPtr<nsIIOService> serv = do_GetService(NS_IOSERVICE_CONTRACTID);
     if (!serv)
     {
@@ -240,14 +261,36 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
         goto return_exception;
     }
 
-    rv = uri->GetScheme(scheme);
+    rv = uri->GetSpec(uriStr);
     if (NS_FAILED(rv)) {
+        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOSPEC);
+        goto return_exception;
+    }    
+
+    rv = uri->GetScheme(scheme);
+    if (NS_FAILED(rv))
+    {
         errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOSCHEME);
         goto return_exception;
     }
-    if (!scheme.EqualsLiteral(""""chrome"""")) {
-        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_URI_NOT_CHROME);
-        goto return_exception;
+
+    if (!scheme.EqualsLiteral(""""chrome""""))
+    {
+        // This might be a URI to a local file, though!
+        nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(uri);
+        if (!fileURL)
+        {
+            errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_URI_NOT_LOCAL);
+            goto return_exception;
+        }
+
+        // For file URIs prepend the filename with the filename of the
+        // calling script, and """" -> """". See bug 418356.
+        nsCAutoString tmp(JS_GetScriptFilename(cx, script));
+        tmp.AppendLiteral("""" -> """");
+        tmp.Append(uriStr);
+
+        uriStr = tmp;
     }        
         
     rv = NS_OpenURI(getter_AddRefs(instream), uri, serv,
@@ -296,12 +339,6 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
         goto return_exception;
     }
 
-    rv = uri->GetSpec(uriStr);
-    if (NS_FAILED(rv)) {
-        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOSPEC);
-        goto return_exception;
-    }    
-
     /* set our own error reporter so we can report any bad things as catchable
      * exceptions, including the source/line number */
     er = JS_SetErrorReporter (cx, mozJSLoaderErrorReporter);"""
ef2388f368078136951c1b657162a24bff54aa3f,62034,418356,bzbarsky@mit.edu,"Set the right url in the script and don't allow loading non-chrome scripts. Bug 418356, r+sr=jst
",1205812013,"""diff --git a/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp b/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp
index 2c771e4..78540d3 100644
--- a/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp
+++ b/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp
@@ -52,16 +52,22 @@
 #include """"nsIInputStream.h""""
 #include """"nsNetCID.h""""
 #include """"nsDependentString.h""""
+#include """"nsAutoPtr.h""""
+#include """"nsNetUtil.h""""
 
 #include """"jsapi.h""""
 
 /* load() error msgs, XXX localize? */
 #define LOAD_ERROR_NOSERVICE """"Error creating IO Service.""""
-#define LOAD_ERROR_NOCHANNEL """"Error creating channel (invalid URL scheme?)""""
+#define LOAD_ERROR_NOURI """"Error creating URI (invalid URL scheme?)""""
+#define LOAD_ERROR_NOSCHEME """"Failed to get URI scheme.  This is bad.""""
+#define LOAD_ERROR_URI_NOT_CHROME """"Trying to load a non-chrome URI.""""
 #define LOAD_ERROR_NOSTREAM  """"Error opening input stream (invalid filename?)""""
 #define LOAD_ERROR_NOCONTENT """"ContentLength not available (not a local URL?)""""
 #define LOAD_ERROR_BADREAD   """"File Read Error.""""
 #define LOAD_ERROR_READUNDERFLOW """"File Read Error (underflow.)""""
+#define LOAD_ERROR_NOPRINCIPALS """"Failed to get principals.""""
+#define LOAD_ERROR_NOSPEC """"Failed to get URI spec.  This is bad.""""
 
 // We just use the same reporter as the component loader
 extern void JS_DLL_CALLBACK
@@ -207,7 +213,7 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
     PRInt32   len = -1;
     PRUint32  readcount = 0;  // Total amount of data read
     PRUint32  lastReadCount = 0;  // Amount of data read in last Read() call
-    char     *buf = nsnull;
+    nsAutoArrayPtr<char> buf;
     
     JSString        *errmsg;
     JSErrorReporter  er;
@@ -215,6 +221,9 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
     
     nsCOMPtr<nsIChannel>     chan;
     nsCOMPtr<nsIInputStream> instream;
+    nsCOMPtr<nsIURI> uri;
+    nsCAutoString uriStr;
+    nsCAutoString scheme;
 
     nsCOMPtr<nsIIOService> serv = do_GetService(NS_IOSERVICE_CONTRACTID);
     if (!serv)
@@ -223,15 +232,27 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
         goto return_exception;
     }
 
-    rv = serv->NewChannel(nsDependentCString(url), nsnull, static_cast<nsIURI *>(nsnull),
-                          getter_AddRefs(chan));
-    if (NS_FAILED(rv))
-    {
-        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOCHANNEL);
+    // Make sure to explicitly create the URI, since we'll need the
+    // canonicalized spec.
+    rv = NS_NewURI(getter_AddRefs(uri), url, nsnull, serv);
+    if (NS_FAILED(rv)) {
+        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOURI);
         goto return_exception;
     }
 
-    rv = chan->Open (getter_AddRefs(instream));
+    rv = uri->GetScheme(scheme);
+    if (NS_FAILED(rv)) {
+        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOSCHEME);
+        goto return_exception;
+    }
+    if (!scheme.EqualsLiteral(""""chrome"""")) {
+        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_URI_NOT_CHROME);
+        goto return_exception;
+    }        
+        
+    rv = NS_OpenURI(getter_AddRefs(instream), uri, serv,
+                    nsnull, nsnull, nsIRequest::LOAD_NORMAL,
+                    getter_AddRefs(chan));
     if (NS_FAILED(rv))
     {
         errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOSTREAM);
@@ -271,34 +292,35 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
      * destructor */
     rv = mSystemPrincipal->GetJSPrincipals(cx, &jsPrincipals);
     if (NS_FAILED(rv) || !jsPrincipals) {
-        delete[] buf;
-        return rv;
+        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOPRINCIPALS);
+        goto return_exception;
     }
 
+    rv = uri->GetSpec(uriStr);
+    if (NS_FAILED(rv)) {
+        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOSPEC);
+        goto return_exception;
+    }    
+
     /* set our own error reporter so we can report any bad things as catchable
      * exceptions, including the source/line number */
     er = JS_SetErrorReporter (cx, mozJSLoaderErrorReporter);
 
     ok = JS_EvaluateScriptForPrincipals (cx, target_obj, jsPrincipals,
-                                         buf, len, url, 1, rval);        
+                                         buf, len, uriStr.get(), 1, rval);        
     /* repent for our evil deeds */
     JS_SetErrorReporter (cx, er);
 
     cc->SetExceptionWasThrown (!ok);
     cc->SetReturnValueWasSet (ok);
 
-    delete[] buf;
     JSPRINCIPALS_DROP(cx, jsPrincipals);
     return NS_OK;
 
  return_exception:
-    if (buf)
-        delete[] buf;
-
     JS_SetPendingException (cx, STRING_TO_JSVAL(errmsg));
     cc->SetExceptionWasThrown (JS_TRUE);
     return NS_OK;
-
 }
 
 #endif /* NO_SUBSCRIPT_LOADER */"""
2e14e2d1ebe2c2c7ac6c6edf165dd64d0e7666b5,62212,419846,jst@mozilla.org,"Fixing bug 419846. Only let chrome documents load scripts from the fastload files. r=enndeakin@gmail.com, sr=bzbarsky@mit.edu
",1205448585,"""diff --git a/content/xul/document/src/nsXULDocument.cpp b/content/xul/document/src/nsXULDocument.cpp
index 5f4f764..f526c5e 100644
--- a/content/xul/document/src/nsXULDocument.cpp
+++ b/content/xul/document/src/nsXULDocument.cpp
@@ -3200,7 +3200,9 @@ nsXULDocument::LoadScript(nsXULPrototypeScript* aScriptProto, PRBool* aBlock)
     // Load a transcluded script
     nsresult rv;
 
-    if (aScriptProto->mScriptObject.mObject) {
+    PRBool isChromeDoc = IsChromeURI(mDocumentURI);
+
+    if (isChromeDoc && aScriptProto->mScriptObject.mObject) {
         rv = ExecuteScript(aScriptProto);
 
         // Ignore return value from execution, and don't block
@@ -3213,7 +3215,7 @@ nsXULDocument::LoadScript(nsXULPrototypeScript* aScriptProto, PRBool* aBlock)
     // XXXbe the cache relies on aScriptProto's GC root!
     PRBool useXULCache = nsXULPrototypeCache::GetInstance()->IsEnabled();
 
-    if (useXULCache) {
+    if (isChromeDoc && useXULCache) {
         PRUint32 fetchedLang = nsIProgrammingLanguage::UNKNOWN;
         void *newScriptObject =
             nsXULPrototypeCache::GetInstance()->GetScript("""
9b37b914868e264b821394947841a9c9b70be023,62564,419848,mrbkap@gmail.com,"Don't assume that chrome:// implies system principals. bug 419848, r=brendan sr=jst
",1204843978,"""diff --git a/dom/src/base/nsJSTimeoutHandler.cpp b/dom/src/base/nsJSTimeoutHandler.cpp
index ffa2579..03fe368 100644
--- a/dom/src/base/nsJSTimeoutHandler.cpp
+++ b/dom/src/base/nsJSTimeoutHandler.cpp
@@ -254,17 +254,12 @@ nsJSScriptTimeoutHandler::Init(nsGlobalWindow *aWindow, PRBool *aIsInterval,
     mExpr = expr;
 
     nsIPrincipal *prin = aWindow->GetPrincipal();
-    JSPrincipals *jsprins;
-    rv = prin->GetJSPrincipals(cx, &jsprins);
-    NS_ENSURE_SUCCESS(rv, rv);
 
     // Get the calling location.
     const char *filename;
-    if (nsJSUtils::GetCallingLocation(cx, &filename, &mLineNo, jsprins)) {
+    if (nsJSUtils::GetCallingLocation(cx, &filename, &mLineNo, prin)) {
       mFileName.Assign(filename);
     }
-
-    JSPRINCIPALS_DROP(cx, jsprins);
   } else if (funobj) {
     rv = NS_HOLD_JS_OBJECTS(this, nsJSScriptTimeoutHandler);
     NS_ENSURE_SUCCESS(rv, rv);
diff --git a/dom/src/base/nsJSUtils.cpp b/dom/src/base/nsJSUtils.cpp
index 7da71a8..068cf4c 100644
--- a/dom/src/base/nsJSUtils.cpp
+++ b/dom/src/base/nsJSUtils.cpp
@@ -62,7 +62,7 @@
 
 JSBool
 nsJSUtils::GetCallingLocation(JSContext* aContext, const char* *aFilename,
-                              PRUint32* aLineno, JSPrincipals* aPrincipals)
+                              PRUint32* aLineno, nsIPrincipal* aPrincipal)
 {
   // Get the current filename and line number
   JSStackFrame* frame = nsnull;
@@ -78,32 +78,24 @@ nsJSUtils::GetCallingLocation(JSContext* aContext, const char* *aFilename,
   if (script) {
     // If aPrincipals is non-null then our caller is asking us to ensure
     // that the filename we return does not have elevated privileges.
-    if (aPrincipals) {
-      // The principals might not be in the script, but we can always
-      // find the right principals in the frame's callee.
-      JSPrincipals* scriptPrins = JS_GetScriptPrincipals(aContext, script);
-      if (!scriptPrins) {
-        JSObject *callee = JS_GetFrameCalleeObject(aContext, frame);
-        nsCOMPtr<nsIPrincipal> prin;
+    if (aPrincipal) {
+      uint32 flags = JS_GetScriptFilenameFlags(script);
+
+      // Use the principal for the filename if it shouldn't be receiving
+      // implicit XPCNativeWrappers.
+      PRBool system;
+      if (flags & JSFILENAME_PROTECTED) {
         nsIScriptSecurityManager *ssm = nsContentUtils::GetSecurityManager();
-        if (NS_FAILED(ssm->GetObjectPrincipal(aContext, callee,
-                                              getter_AddRefs(prin))) ||
-            !prin) {
-          return JS_FALSE;
-        }
 
-        prin->GetJSPrincipals(aContext, &scriptPrins);
+        if (NS_FAILED(ssm->IsSystemPrincipal(aPrincipal, &system)) || !system) {
+          JSPrincipals* jsprins;
+          aPrincipal->GetJSPrincipals(aContext, &jsprins);
 
-        // The script has a reference to the principals.
-        JSPRINCIPALS_DROP(aContext, scriptPrins);
-      }
-
-      // Return the weaker of the two principals if they differ.
-      if (scriptPrins != aPrincipals &&
-          scriptPrins->subsume(scriptPrins, aPrincipals)) {
-        *aFilename = aPrincipals->codebase;
-        *aLineno = 0;
-        return JS_TRUE;
+          *aFilename = jsprins->codebase;
+          *aLineno = 0;
+          JSPRINCIPALS_DROP(aContext, jsprins);
+          return JS_TRUE;
+        }
       }
     }
 
diff --git a/dom/src/base/nsJSUtils.h b/dom/src/base/nsJSUtils.h
index faacd0e..9c3d990 100644
--- a/dom/src/base/nsJSUtils.h
+++ b/dom/src/base/nsJSUtils.h
@@ -52,12 +52,13 @@
 class nsIDOMEventListener;
 class nsIScriptContext;
 class nsIScriptGlobalObject;
+class nsIPrincipal;
 
 class nsJSUtils
 {
 public:
   static JSBool GetCallingLocation(JSContext* aContext, const char* *aFilename,
-                                   PRUint32* aLineno, JSPrincipals* aPrincipals);
+                                   PRUint32* aLineno, nsIPrincipal* aPrincipal);
 
   static jsval ConvertStringToJSVal(const nsString& aProp,
                                     JSContext* aContext);
diff --git a/js/src/jsfun.c b/js/src/jsfun.c
index a584e62..072aba0 100644
--- a/js/src/jsfun.c
+++ b/js/src/jsfun.c
@@ -1758,13 +1758,7 @@ Function(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
     caller = JS_GetScriptedCaller(cx, fp);
     if (caller) {
         principals = JS_EvalFramePrincipals(cx, fp, caller);
-        if (principals == caller->script->principals) {
-            filename = caller->script->filename;
-            lineno = js_PCToLineNumber(cx, caller->script, caller->pc);
-        } else {
-            filename = principals->codebase;
-            lineno = 0;
-        }
+        filename = js_ComputeFilename(cx, caller, principals, &lineno);
     } else {
         filename = NULL;
         lineno = 0;
diff --git a/js/src/jsobj.c b/js/src/jsobj.c
index 5909075..22ccb2f9 100644
--- a/js/src/jsobj.c
+++ b/js/src/jsobj.c
@@ -1133,6 +1133,23 @@ bad:
     return NULL;
 }
 
+const char *
+js_ComputeFilename(JSContext *cx, JSStackFrame *caller,
+                   JSPrincipals *principals, uintN *linenop)
+{
+    uint32 flags;
+
+    flags = JS_GetScriptFilenameFlags(caller->script);
+    if ((flags & JSFILENAME_PROTECTED) &&
+        strcmp(principals->codebase, """"[System Principal]"""")) {
+        *linenop = 0;
+        return principals->codebase;
+    }
+
+    *linenop = js_PCToLineNumber(cx, caller->script, caller->pc);
+    return caller->script->filename;
+}
+
 static JSBool
 obj_eval(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
@@ -1271,13 +1288,7 @@ obj_eval(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
     str = JSVAL_TO_STRING(argv[0]);
     if (caller) {
         principals = JS_EvalFramePrincipals(cx, fp, caller);
-        if (principals == caller->script->principals) {
-            file = caller->script->filename;
-            line = js_PCToLineNumber(cx, caller->script, caller->pc);
-        } else {
-            file = principals->codebase;
-            line = 0;
-        }
+        file = js_ComputeFilename(cx, caller, principals, &line);
     } else {
         file = NULL;
         line = 0;
diff --git a/js/src/jsobj.h b/js/src/jsobj.h
index ba7506e..c9d4113 100644
--- a/js/src/jsobj.h
+++ b/js/src/jsobj.h
@@ -699,6 +699,10 @@ js_CheckPrincipalsAccess(JSContext *cx, JSObject *scopeobj,
 extern JSObject *
 js_GetWrappedObject(JSContext *cx, JSObject *obj);
 
+/* NB: Infallible. */
+extern const char *
+js_ComputeFilename(JSContext *cx, JSStackFrame *caller,
+                   JSPrincipals *principals, uintN *linenop);
 JS_END_EXTERN_C
 
 #endif /* jsobj_h___ */
diff --git a/js/src/jsscript.c b/js/src/jsscript.c
index 7dc9dbc..54f0589 100644
--- a/js/src/jsscript.c
+++ b/js/src/jsscript.c
@@ -241,9 +241,8 @@ script_compile_sub(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
             fp->scopeChain = scopeobj;  /* for the compiler's benefit */
         }
 
-        file = caller->script->filename;
-        line = js_PCToLineNumber(cx, caller->script, caller->pc);
         principals = JS_EvalFramePrincipals(cx, fp, caller);
+        file = js_ComputeFilename(cx, caller, principals, &line);
     } else {
         file = NULL;
         line = 0;"""
3a3f477fd4ceb3e1391243438e116ab3532f8af7,62726,419848,jst@mozilla.org,"Backing out fix for bug 419848 due to feed code breakage.
",1204609149,"""diff --git a/content/base/src/nsScriptLoader.cpp b/content/base/src/nsScriptLoader.cpp
index 2358ddf..f7caf28 100644
--- a/content/base/src/nsScriptLoader.cpp
+++ b/content/base/src/nsScriptLoader.cpp
@@ -427,7 +427,8 @@ nsScriptLoader::ProcessScriptElement(nsIScriptElement *aElement)
   if (scriptURI) {
     // Check that the containing page is allowed to load this URI.
     rv = nsContentUtils::GetSecurityManager()->
-      CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), scriptURI, 0);
+      CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), scriptURI,
+                                nsIScriptSecurityManager::ALLOW_CHROME);
 
     NS_ENSURE_SUCCESS(rv, rv);
 
diff --git a/content/xml/document/src/nsXMLContentSink.cpp b/content/xml/document/src/nsXMLContentSink.cpp
index 58d0dd5..dd058b5 100644
--- a/content/xml/document/src/nsXMLContentSink.cpp
+++ b/content/xml/document/src/nsXMLContentSink.cpp
@@ -767,7 +767,8 @@ nsXMLContentSink::ProcessStyleLink(nsIContent* aElement,
     // Do security check
     nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
     rv = secMan->
-      CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), url, 0);
+      CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), url,
+                                nsIScriptSecurityManager::ALLOW_CHROME);
     NS_ENSURE_SUCCESS(rv, NS_OK);
 
     // Do content policy check
diff --git a/content/xul/document/src/nsXULContentSink.cpp b/content/xul/document/src/nsXULContentSink.cpp
index dc7b0f7..48d257b 100644
--- a/content/xul/document/src/nsXULContentSink.cpp
+++ b/content/xul/document/src/nsXULContentSink.cpp
@@ -1158,7 +1158,8 @@ XULContentSinkImpl::OpenScript(const PRUnichar** aAttributes,
                   if (NS_SUCCEEDED(rv)) {
                       rv = mSecMan->
                           CheckLoadURIWithPrincipal(doc->NodePrincipal(),
-                                                    script->mSrcURI, 0);
+                                                    script->mSrcURI,
+                                                    nsIScriptSecurityManager::ALLOW_CHROME);
                   }
               }
           }"""
082518bf797515a10855d927e0b9af68a9c05683,62727,419848,jst@mozilla.org,"Fixing bug 419848. Tighten rules about what JS files content can load. r+sr=jonas@sicking.cc
",1204604253,"""diff --git a/content/base/src/nsScriptLoader.cpp b/content/base/src/nsScriptLoader.cpp
index f7caf28..2358ddf 100644
--- a/content/base/src/nsScriptLoader.cpp
+++ b/content/base/src/nsScriptLoader.cpp
@@ -427,8 +427,7 @@ nsScriptLoader::ProcessScriptElement(nsIScriptElement *aElement)
   if (scriptURI) {
     // Check that the containing page is allowed to load this URI.
     rv = nsContentUtils::GetSecurityManager()->
-      CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), scriptURI,
-                                nsIScriptSecurityManager::ALLOW_CHROME);
+      CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), scriptURI, 0);
 
     NS_ENSURE_SUCCESS(rv, rv);
 
diff --git a/content/xml/document/src/nsXMLContentSink.cpp b/content/xml/document/src/nsXMLContentSink.cpp
index dd058b5..58d0dd5 100644
--- a/content/xml/document/src/nsXMLContentSink.cpp
+++ b/content/xml/document/src/nsXMLContentSink.cpp
@@ -767,8 +767,7 @@ nsXMLContentSink::ProcessStyleLink(nsIContent* aElement,
     // Do security check
     nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
     rv = secMan->
-      CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), url,
-                                nsIScriptSecurityManager::ALLOW_CHROME);
+      CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), url, 0);
     NS_ENSURE_SUCCESS(rv, NS_OK);
 
     // Do content policy check
diff --git a/content/xul/document/src/nsXULContentSink.cpp b/content/xul/document/src/nsXULContentSink.cpp
index 48d257b..dc7b0f7 100644
--- a/content/xul/document/src/nsXULContentSink.cpp
+++ b/content/xul/document/src/nsXULContentSink.cpp
@@ -1158,8 +1158,7 @@ XULContentSinkImpl::OpenScript(const PRUnichar** aAttributes,
                   if (NS_SUCCEEDED(rv)) {
                       rv = mSecMan->
                           CheckLoadURIWithPrincipal(doc->NodePrincipal(),
-                                                    script->mSrcURI,
-                                                    nsIScriptSecurityManager::ALLOW_CHROME);
+                                                    script->mSrcURI, 0);
                   }
               }
           }"""
fc394cc44d6f25883c22b7b778daf2c8190a64a2,63275,415034,dveditz@cruzio.com,"bug 415034 prevent URIs with userinfo but no username. r=biesi, sr=bsmedberg, blocking1.9+
",1203557081,"""diff --git a/netwerk/base/src/nsStandardURL.cpp b/netwerk/base/src/nsStandardURL.cpp
index 0d1ccf9..e64bb52 100644
--- a/netwerk/base/src/nsStandardURL.cpp
+++ b/netwerk/base/src/nsStandardURL.cpp
@@ -1126,7 +1126,7 @@ nsStandardURL::SetUserPass(const nsACString &input)
 
     if (userpass.IsEmpty()) {
         // remove user:pass
-        if (mUsername.mLen >= 0) {
+        if (mUsername.mLen > 0) {
             if (mPassword.mLen > 0)
                 mUsername.mLen += (mPassword.mLen + 1);
             mUsername.mLen++;
@@ -1263,7 +1263,7 @@ nsStandardURL::SetPassword(const nsACString &input)
         NS_ERROR(""""cannot set password on no-auth url"""");
         return NS_ERROR_UNEXPECTED;
     }
-    if (mUsername.mLen < 0) {
+    if (mUsername.mLen <= 0) {
         NS_ERROR(""""cannot set password without existing username"""");
         return NS_ERROR_FAILURE;
     }
diff --git a/netwerk/base/src/nsURLParsers.cpp b/netwerk/base/src/nsURLParsers.cpp
index d099c49..4ed66ef 100644
--- a/netwerk/base/src/nsURLParsers.cpp
+++ b/netwerk/base/src/nsURLParsers.cpp
@@ -531,9 +531,16 @@ nsAuthURLParser::ParseUserInfo(const char *userinfo, PRInt32 userinfoLen,
     if (userinfoLen < 0)
         userinfoLen = strlen(userinfo);
 
+    if (userinfoLen == 0)
+        return NS_ERROR_MALFORMED_URI;
+
     const char *p = (const char *) memchr(userinfo, ':', userinfoLen);
     if (p) {
         // userinfo = <username:password>
+        if (p == userinfo) {
+            // must have a username!
+            return NS_ERROR_MALFORMED_URI;
+        }
         SET_RESULT(username, 0, p - userinfo);
         SET_RESULT(password, p - userinfo + 1, userinfoLen - (p - userinfo + 1));
     }"""
de111dfc9a4b661902f5501e37c8e3b6af3244b1,64138,413250,dveditz@cruzio.com,"bug 413250 additional patch to catch double escaped chrome URIs too. r/sr=bsmedberg, a=beltzner
",1201831152,"""diff --git a/chrome/src/nsChromeRegistry.cpp b/chrome/src/nsChromeRegistry.cpp
index 8be54be..3dc16d5 100644
--- a/chrome/src/nsChromeRegistry.cpp
+++ b/chrome/src/nsChromeRegistry.cpp
@@ -679,14 +679,26 @@ nsChromeRegistry::Canonify(nsIURL* aChromeURL)
     aChromeURL->SetPath(path);
   }
   else {
-    nsCAutoString filePath;
-    rv = aChromeURL->GetFilePath(filePath);
-    NS_ENSURE_SUCCESS(rv, rv);
-    filePath.SetLength(nsUnescapeCount(filePath.BeginWriting()));
-
-    if (filePath.Find(NS_LITERAL_CSTRING("""".."""")) != kNotFound ||
-        filePath.FindChar(':') != kNotFound) {
-      return NS_ERROR_DOM_BAD_URI;
+    // prevent directory traversals ("""".."""")
+    // path is already unescaped once, but uris can get unescaped twice
+    const char* curChar = path.BeginReading();
+    const char* end = path.EndReading();
+    while (curChar < end) {
+      switch (*curChar) {
+        case ':':
+          return NS_ERROR_DOM_BAD_URI;
+        case '.':
+          if (*(curChar+1) == '.')
+            return NS_ERROR_DOM_BAD_URI;
+        case '%':
+          // chrome: URIs with double-escapes are trying to trick us.
+          // watch for %2e, and %25 in case someone triple unescapes
+          if (*(curChar+1) == '2' &&
+               ( *(curChar+2) == 'e' || *(curChar+2) == 'E' || 
+                 *(curChar+2) == '5' ))
+            return NS_ERROR_DOM_BAD_URI;
+      }
+      ++curChar;
     }
   }
 
@@ -744,7 +756,7 @@ nsChromeRegistry::ConvertChromeURL(nsIURI* aChromeURI, nsIURI* *aResult)
   else if (provider.EqualsLiteral(""""skin"""")) {
     baseURI = entry->skins.GetBase(mSelectedSkin, nsProviderArray::ANY);
   }
-  else {
+  else if (provider.EqualsLiteral(""""content"""")) {
     baseURI = entry->baseURI;
   }
 """
c634330912faddb1ada1a6a4e05d3eee150d5573,64625,413250,dveditz@cruzio.com,"bug 413250 fix chrome: URI scheme traversal. r=Neil, sr=bsmedberg
",1201244272,"""diff --git a/chrome/src/nsChromeRegistry.cpp b/chrome/src/nsChromeRegistry.cpp
index 1efeace..8be54be 100644
--- a/chrome/src/nsChromeRegistry.cpp
+++ b/chrome/src/nsChromeRegistry.cpp
@@ -682,9 +682,10 @@ nsChromeRegistry::Canonify(nsIURL* aChromeURL)
     nsCAutoString filePath;
     rv = aChromeURL->GetFilePath(filePath);
     NS_ENSURE_SUCCESS(rv, rv);
+    filePath.SetLength(nsUnescapeCount(filePath.BeginWriting()));
 
-    if (filePath.Find(NS_LITERAL_CSTRING("""".."""")) != -1 ||
-        filePath.FindChar(':') != -1) {
+    if (filePath.Find(NS_LITERAL_CSTRING("""".."""")) != kNotFound ||
+        filePath.FindChar(':') != kNotFound) {
       return NS_ERROR_DOM_BAD_URI;
     }
   }
diff --git a/rdf/chrome/src/nsChromeRegistry.cpp b/rdf/chrome/src/nsChromeRegistry.cpp
index d960d2b..20a4437 100644
--- a/rdf/chrome/src/nsChromeRegistry.cpp
+++ b/rdf/chrome/src/nsChromeRegistry.cpp
@@ -81,6 +81,7 @@
 #include """"nsLayoutCID.h""""
 #include """"prio.h""""
 #include """"nsInt64.h""""
+#include """"nsEscape.h""""
 #include """"nsIDirectoryService.h""""
 #include """"nsILocalFile.h""""
 #include """"nsAppDirectoryServiceDefs.h""""
@@ -388,26 +389,16 @@ SplitURL(nsIURI *aChromeURI, nsCString& aPackage, nsCString& aProvider, nsCStrin
   } else {
     // Protect against URIs containing .. that reach up out of the
     // chrome directory to grant chrome privileges to non-chrome files.
-    int depth = 0;
-    PRBool sawSlash = PR_TRUE;  // .. at the beginning is suspect as well as /..
-    for (const char* p=aFile.get(); *p; p++) {
-      if (sawSlash) {
-        if (p[0] == '.' && p[1] == '.'){
-          depth--;    // we have /.., decrement depth.
-        } else {
-          static const char escape[] = """"%2E%2E"""";
-          if (PL_strncasecmp(p, escape, sizeof(escape)-1) == 0)
-            depth--;   // we have the HTML-escaped form of /.., decrement depth.
-        }
-      } else if (p[0] != '/') {
-        depth++;        // we have /x for some x that is not /
-      }
-      sawSlash = (p[0] == '/');
-
-      if (depth < 0) {
-        return NS_ERROR_FAILURE;
-      }
+    PRInt32 origLen = aFile.Length();
+    PRInt32 newLen = nsUnescapeCount(aFile.BeginWriting());
+    if (origLen != newLen) {
+        aFile.SetLength(newLen);
+        nofile = PR_TRUE; // let caller know path is modified
     }
+
+    if (aFile.Find(NS_LITERAL_CSTRING("""".."""")) != kNotFound ||
+        aFile.FindChar(':') != kNotFound)
+      return NS_ERROR_FAILURE;
   }
   if (aModified)
     *aModified = nofile;"""
b60e291de9920f0a430c22b8782f29e7adf40476,66758,400556,bzbarsky@mit.edu,"Fix bug 400556 by tearing down editor a little earlier.  r+sr=peterv
",1196647636,"""diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
index 4ec7878..834bae7 100644
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -1004,6 +1004,12 @@ nsDocShell::FirePageHideNotification(PRBool aIsUnload)
         }
     }
 
+    // Now make sure our editor, if any, is torn down before we go
+    // any farther.
+    if (mEditorData) {
+        mEditorData->TearDownEditor();
+    }
+
     return NS_OK;
 }
 
diff --git a/docshell/base/nsDocShellEditorData.cpp b/docshell/base/nsDocShellEditorData.cpp
index a26d675..9b69dce 100644
--- a/docshell/base/nsDocShellEditorData.cpp
+++ b/docshell/base/nsDocShellEditorData.cpp
@@ -68,6 +68,12 @@ nsDocShellEditorData::nsDocShellEditorData(nsIDocShell* inOwningDocShell)
 ----------------------------------------------------------------------------*/
 nsDocShellEditorData::~nsDocShellEditorData()
 {
+  TearDownEditor();
+}
+
+void
+nsDocShellEditorData::TearDownEditor()
+{
   if (mEditingSession)
   {
     nsCOMPtr<nsIDOMWindow> domWindow = do_GetInterface(mDocShell);
diff --git a/docshell/base/nsDocShellEditorData.h b/docshell/base/nsDocShellEditorData.h
index b624b1a..8007796 100644
--- a/docshell/base/nsDocShellEditorData.h
+++ b/docshell/base/nsDocShellEditorData.h
@@ -66,7 +66,7 @@ public:
               ~nsDocShellEditorData();
               
 
-              // set a flag to say this frame should be editable when the next url loads
+  // set a flag to say this frame should be editable when the next url loads
   nsresult    MakeEditable(PRBool inWaitForUriLoad);
   
   PRBool      GetEditable();
@@ -84,6 +84,9 @@ public:
               // set the editor on this docShell
   nsresult    SetEditor(nsIEditor *inEditor);
 
+  // Tear down the editor on this docshell, if any.
+  void        TearDownEditor();
+
 protected:              
 
   nsresult    EnsureEditingSession();"""
8f09eba75980622c22c3484cbfb14f768da59149,66955,403331,dcamp@mozilla.com,"Bug 403331: update JAR channel URIs after a redirect.  r=bz, r=jwalden (mochitest changes), sr=dveditz
",1196138100,"""diff --git a/modules/libjar/nsIJARURI.idl b/modules/libjar/nsIJARURI.idl
index 0728027..2685c8f 100644
--- a/modules/libjar/nsIJARURI.idl
+++ b/modules/libjar/nsIJARURI.idl
@@ -47,7 +47,7 @@
  *
  * The nsIURL methods operate on the <jar-entry> part of the spec.
  */
-[scriptable, uuid(d2746619-1724-4f42-8ca8-dacaf1b269d6)]
+[scriptable, uuid(b0922a89-f87b-4cb5-8612-305a285fcca7)]
 interface nsIJARURI : nsIURL {
 
     /**
@@ -61,4 +61,10 @@ interface nsIJARURI : nsIURL {
      * value may contain %-escaped byte sequences.
      */
     attribute AUTF8String JAREntry;
+
+    /**
+     * Create a clone of the JAR URI with a new root URI (the URI for the
+     * actual JAR file).
+     */
+    nsIJARURI cloneWithJARFile(in nsIURI jarFile);
 };
diff --git a/modules/libjar/nsJARChannel.cpp b/modules/libjar/nsJARChannel.cpp
index afa122c..a4e1460 100644
--- a/modules/libjar/nsJARChannel.cpp
+++ b/modules/libjar/nsJARChannel.cpp
@@ -701,15 +701,40 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
                                  nsresult       status,
                                  nsIFile       *file)
 {
+    nsresult rv;
+
     // Grab the security info from our base channel
     nsCOMPtr<nsIChannel> channel(do_QueryInterface(request));
-    if (channel)
+    if (channel) {
         channel->GetSecurityInfo(getter_AddRefs(mSecurityInfo));
-    
+
+        PRUint32 loadFlags;
+        channel->GetLoadFlags(&loadFlags);
+        if (loadFlags & LOAD_REPLACE) {
+            mLoadFlags |= LOAD_REPLACE;
+
+            if (!mOriginalURI) {
+                SetOriginalURI(mJarURI);
+            }
+
+            nsCOMPtr<nsIURI> innerURI;
+            rv = channel->GetURI(getter_AddRefs(innerURI));
+            if (NS_SUCCEEDED(rv)) {
+                nsCOMPtr<nsIJARURI> newURI;
+                rv = mJarURI->CloneWithJARFile(innerURI,
+                                               getter_AddRefs(newURI));
+                if (NS_SUCCEEDED(rv)) {
+                    mJarURI = newURI;
+                }
+            }
+            status = rv;
+        }
+    }
+
     if (NS_SUCCEEDED(status)) {
         mJarFile = file;
     
-        nsresult rv = CreateJarInput(nsnull);
+        rv = CreateJarInput(nsnull);
         if (NS_SUCCEEDED(rv)) {
             // create input stream pump
             rv = NS_NewInputStreamPump(getter_AddRefs(mPump), mJarInput);
diff --git a/modules/libjar/nsJARURI.cpp b/modules/libjar/nsJARURI.cpp
index 3631745..064ef0a 100644
--- a/modules/libjar/nsJARURI.cpp
+++ b/modules/libjar/nsJARURI.cpp
@@ -499,31 +499,11 @@ nsJARURI::Clone(nsIURI **result)
 {
     nsresult rv;
 
-    nsCOMPtr<nsIURI> newJARFile;
-    rv = mJARFile->Clone(getter_AddRefs(newJARFile));
-    if (NS_FAILED(rv)) return rv;
-
-    NS_TryToSetImmutable(newJARFile);
-
-    nsCOMPtr<nsIURI> newJAREntryURI;
-    rv = mJAREntry->Clone(getter_AddRefs(newJAREntryURI));
+    nsCOMPtr<nsIJARURI> uri;
+    rv = CloneWithJARFile(mJARFile, getter_AddRefs(uri));
     if (NS_FAILED(rv)) return rv;
 
-    nsCOMPtr<nsIURL> newJAREntry(do_QueryInterface(newJAREntryURI));
-    NS_ASSERTION(newJAREntry, """"This had better QI to nsIURL!"""");
-    
-    nsJARURI* uri = new nsJARURI();
-    if (uri) {
-        NS_ADDREF(uri);
-        uri->mJARFile = newJARFile;
-        uri->mJAREntry = newJAREntry;
-        *result = uri;
-        rv = NS_OK;
-    } else {
-        rv = NS_ERROR_OUT_OF_MEMORY;
-    }
-
-    return rv;
+    return CallQueryInterface(uri, result);
 }
 
 NS_IMETHODIMP
@@ -785,6 +765,42 @@ nsJARURI::SetJAREntry(const nsACString &entryPath)
                           getter_AddRefs(mJAREntry));
 }
 
+NS_IMETHODIMP
+nsJARURI::CloneWithJARFile(nsIURI *jarFile, nsIJARURI **result)
+{
+    if (!jarFile) {
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    nsresult rv;
+
+    nsCOMPtr<nsIURI> newJARFile;
+    rv = jarFile->Clone(getter_AddRefs(newJARFile));
+    if (NS_FAILED(rv)) return rv;
+
+    NS_TryToSetImmutable(newJARFile);
+
+    nsCOMPtr<nsIURI> newJAREntryURI;
+    rv = mJAREntry->Clone(getter_AddRefs(newJAREntryURI));
+    if (NS_FAILED(rv)) return rv;
+
+    nsCOMPtr<nsIURL> newJAREntry(do_QueryInterface(newJAREntryURI));
+    NS_ASSERTION(newJAREntry, """"This had better QI to nsIURL!"""");
+    
+    nsJARURI* uri = new nsJARURI();
+    if (uri) {
+        NS_ADDREF(uri);
+        uri->mJARFile = newJARFile;
+        uri->mJAREntry = newJAREntry;
+        *result = uri;
+        rv = NS_OK;
+    } else {
+        rv = NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    return rv;
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 
 NS_IMETHODIMP
diff --git a/modules/libjar/test/Makefile.in b/modules/libjar/test/Makefile.in
index 346e090..5d8d391 100644
--- a/modules/libjar/test/Makefile.in
+++ b/modules/libjar/test/Makefile.in
@@ -47,4 +47,8 @@ MODULE		= test_libjar
 
 XPCSHELL_TESTS = unit
 
+ifdef MOZ_MOCHITEST
+DIRS		+= mochitest
+endif
+
 include $(topsrcdir)/config/rules.mk
diff --git a/modules/libjar/test/mochitest/Makefile.in b/modules/libjar/test/mochitest/Makefile.in
new file mode 100644
index 0000000..9f3cf83
--- /dev/null
+++ b/modules/libjar/test/mochitest/Makefile.in
@@ -0,0 +1,54 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the """"License""""); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an """"AS IS"""" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Mozilla Foundation.
+# Portions created by the Initial Developer are Copyright (C) 2007
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the """"GPL""""),
+# or the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+relativesrcdir  = modules/libjar/test/mochitest
+
+include $(DEPTH)/config/autoconf.mk
+include $(topsrcdir)/config/rules.mk
+
+_TEST_FILES = \
+		test_bug403331.html    \
+		bug403331.zip          \
+		bug403331.zip^headers^ \
+		$(NULL)
+
+libs:: $(_TEST_FILES)
+	$(INSTALL) $(foreach f,$^,""""$f"""") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
diff --git a/modules/libjar/test/mochitest/bug403331.zip b/modules/libjar/test/mochitest/bug403331.zip
new file mode 100644
index 0000000..48ba268
Binary files /dev/null and b/modules/libjar/test/mochitest/bug403331.zip differ
diff --git a/modules/libjar/test/mochitest/bug403331.zip^headers^ b/modules/libjar/test/mochitest/bug403331.zip^headers^
new file mode 100644
index 0000000..28b8aa0
--- /dev/null
+++ b/modules/libjar/test/mochitest/bug403331.zip^headers^
@@ -0,0 +1 @@
+Content-Type: application/java-archive
diff --git a/modules/libjar/test/mochitest/test_bug403331.html b/modules/libjar/test/mochitest/test_bug403331.html
new file mode 100644
index 0000000..8b46ef9
--- /dev/null
+++ b/modules/libjar/test/mochitest/test_bug403331.html
@@ -0,0 +1,46 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=403331
+-->
+<head>
+  <title>Test for Bug 403331</title>
+  <script type=""""text/javascript"""" src=""""/MochiKit/MochiKit.js""""></script>
+  <script type=""""text/javascript"""" src=""""/tests/SimpleTest/SimpleTest.js""""></script>        
+  <link rel=""""stylesheet"""" type=""""text/css"""" href=""""/tests/SimpleTest/test.css"""" />
+</head>
+<body>
+
+<iframe id=""""testFrame""""></iframe>
+
+<pre id=""""test"""">
+<script class=""""testbody"""" type=""""text/javascript"""">
+
+/** Test for Bug 403331 **/
+
+SimpleTest.waitForExplicitFinish();
+
+function runTest() {
+  var testFrame = document.getElementById('testFrame');
+
+  // Try a redirected load from another domain to this one.
+
+  testFrame.onload = function() {
+    // If properly redirected, we'll be able to access elements in the loaded
+    // document.
+    var item = testFrame.contentDocument.getElementById('testitem');
+    is(item.textContent, """"testcontents"""", """"Should be able to access the child document"""");
+
+    SimpleTest.finish();
+  }
+
+  testFrame.src = """"jar:http://example.org:80/redirect?http://localhost:8888/tests/modules/libjar/test/mochitest/bug403331.zip!/test.html"""";
+}
+
+addLoadEvent(runTest);
+
+</script>
+</pre>
+
+</body>
+</html>
diff --git a/testing/mochitest/server.js b/testing/mochitest/server.js
index 6666714..0280e3c 100644
--- a/testing/mochitest/server.js
+++ b/testing/mochitest/server.js
@@ -140,6 +140,8 @@ function runServer()
   if (environment[""""CLOSE_WHEN_DONE""""])
     server.registerPathHandler(""""/server/shutdown"""", serverShutdown);
 
+  server.registerPathHandler(""""/redirect"""", redirect);
+
   server.setIndexHandler(defaultDirHandler);
   server.start(SERVER_PORT);
 
@@ -198,6 +200,12 @@ function serverShutdown(metadata, response)
   otherDomainServer.stop();
 }
 
+function redirect(metadata, response)
+{
+  response.setStatusLine(""""1.1"""", 301, """"Moved Permanently"""");
+  response.setHeader(""""Location"""", metadata.queryString);
+}
+
 //
 // DIRECTORY LISTINGS
 //"""
445bb23f66273fe9f7f3287f9db99c318bc16659,67514,402649,bzbarsky@mit.edu,"Base our referrer on the URI of the principal executing the code, not on the URI of the document currently loaded in the window associated to the context we're running on.  Bug 402649, r+sr=jst
",1194808285,"""diff --git a/dom/src/base/nsGlobalWindow.h b/dom/src/base/nsGlobalWindow.h
index f11e600..397b9f5 100644
--- a/dom/src/base/nsGlobalWindow.h
+++ b/dom/src/base/nsGlobalWindow.h
@@ -847,7 +847,6 @@ protected:
   nsresult SetHrefWithContext(JSContext* cx, const nsAString& aHref,
                               PRBool aReplace);
 
-  nsresult GetSourceURL(JSContext* cx, nsIURI** sourceURL);
   nsresult GetSourceBaseURL(JSContext* cx, nsIURI** sourceURL);
   nsresult GetSourceDocument(JSContext* cx, nsIDocument** aDocument);
 
diff --git a/dom/src/base/nsLocation.cpp b/dom/src/base/nsLocation.cpp
index ad9d8c2..386c780 100644
--- a/dom/src/base/nsLocation.cpp
+++ b/dom/src/base/nsLocation.cpp
@@ -223,8 +223,7 @@ nsLocation::CheckURL(nsIURI* aURI, nsIDocShellLoadInfo** aLoadInfo)
         !principal)
       return NS_ERROR_FAILURE;
     owner = do_QueryInterface(principal);
-
-    GetSourceURL(cx, getter_AddRefs(sourceURI));
+    principal->GetURI(getter_AddRefs(sourceURI));
   }
 
   // Create load info
@@ -1028,17 +1027,3 @@ nsLocation::GetSourceBaseURL(JSContext* cx, nsIURI** sourceURL)
 
   return rv;
 }
-
-nsresult
-nsLocation::GetSourceURL(JSContext* cx, nsIURI** sourceURL)
-{
-  nsCOMPtr<nsIDocument> doc;
-  nsresult rv = GetSourceDocument(cx, getter_AddRefs(doc));
-  if (doc) {
-    NS_IF_ADDREF(*sourceURL = doc->GetDocumentURI());
-  } else {
-    *sourceURL = nsnull;
-  }
-
-  return rv;
-}"""
3722a502c31aaf81090cc46e28bd3d5d35ace7ff,75431,436741,mrbkap%gmail.com,"Do not attempt to lock a non-native object. bug 436741, r=brendan a=ss
",1218479375,"""diff --git a/js/src/jsobj.c b/js/src/jsobj.c
index 88aef74..0a8c026 100644
--- a/js/src/jsobj.c
+++ b/js/src/jsobj.c
@@ -3344,7 +3344,8 @@ js_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, jsid id, uintN flags,
                         /* Resolved: juggle locks and lookup id again. */
                         if (obj2 != obj) {
                             JS_UNLOCK_OBJ(cx, obj);
-                            JS_LOCK_OBJ(cx, obj2);
+                            if (OBJ_IS_NATIVE(obj2))
+                                JS_LOCK_OBJ(cx, obj2);
                         }
                         protoIndex = 0;
                         for (proto = start; proto && proto != obj2;
@@ -3355,7 +3356,6 @@ js_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, jsid id, uintN flags,
                         if (!MAP_IS_NATIVE(&scope->map)) {
                             /* Whoops, newresolve handed back a foreign obj2. */
                             JS_ASSERT(obj2 != obj);
-                            JS_UNLOCK_OBJ(cx, obj2);
                             ok = OBJ_LOOKUP_PROPERTY(cx, obj2, id, objp, propp);
                             if (!ok || *propp)
                                 goto cleanup;
@@ -3376,7 +3376,8 @@ js_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, jsid id, uintN flags,
                             JS_ASSERT(obj2 == scope->object);
                             obj = obj2;
                         } else if (obj2 != obj) {
-                            JS_UNLOCK_OBJ(cx, obj2);
+                            if (OBJ_IS_NATIVE(obj2))
+                                JS_UNLOCK_OBJ(cx, obj2);
                             JS_LOCK_OBJ(cx, obj);
                         }
                     }"""
445ad42a2d156a8e194beb39725b51e495c83b69,75563,443089,bmlk%gmx.de,"limit mathml row- and colspans as we do for html bug 443089 r/sr=bzbarsky a=siedler
",1217831818,"""diff --git a/content/html/content/src/Makefile.in b/content/html/content/src/Makefile.in
index 0a5b977..c8737bd 100644
--- a/content/html/content/src/Makefile.in
+++ b/content/html/content/src/Makefile.in
@@ -143,6 +143,7 @@ INCLUDES	+= \
 		-I$(srcdir)/../../../events/src \
 		-I$(srcdir)/../../../xbl/src \
 		-I$(srcdir)/../../../../layout/style \
+		-I$(srcdir)/../../../../layout/tables \
 		-I$(srcdir) \
 		$(NULL)
 
diff --git a/content/html/content/src/nsHTMLTableCellElement.cpp b/content/html/content/src/nsHTMLTableCellElement.cpp
index 4ae8ae0..d657055 100644
--- a/content/html/content/src/nsHTMLTableCellElement.cpp
+++ b/content/html/content/src/nsHTMLTableCellElement.cpp
@@ -45,6 +45,7 @@
 #include """"nsPresContext.h""""
 #include """"nsRuleData.h""""
 #include """"nsIDocument.h""""
+#include """"celldata.h""""
 
 class nsHTMLTableCellElement : public nsGenericHTMLElement,
                                public nsIDOMHTMLTableCellElement
@@ -261,9 +262,6 @@ static const nsAttrValue::EnumTable kCellScopeTable[] = {
   { 0 }
 };
 
-#define MAX_ROWSPAN 8190 // celldata.h can not handle more
-#define MAX_COLSPAN 1000 // limit as IE and opera do
-
 PRBool
 nsHTMLTableCellElement::ParseAttribute(PRInt32 aNamespaceID,
                                        nsIAtom* aAttribute,
diff --git a/layout/mathml/base/src/nsMathMLmtableFrame.cpp b/layout/mathml/base/src/nsMathMLmtableFrame.cpp
index e64ba40..fc50aec 100644
--- a/layout/mathml/base/src/nsMathMLmtableFrame.cpp
+++ b/layout/mathml/base/src/nsMathMLmtableFrame.cpp
@@ -51,6 +51,7 @@
 #include """"nsTableOuterFrame.h""""
 #include """"nsTableFrame.h""""
 #include """"nsTableCellFrame.h""""
+#include """"celldata.h""""
 
 #include """"nsMathMLmtableFrame.h""""
 
@@ -775,6 +776,7 @@ nsMathMLmtdFrame::GetRowSpan()
       rowspan = value.ToInteger(&error);
       if (error || rowspan < 0)
         rowspan = 1;
+      rowspan = PR_MIN(rowspan, MAX_ROWSPAN);
     }
   }
   return rowspan;
@@ -792,7 +794,7 @@ nsMathMLmtdFrame::GetColSpan()
     if (!value.IsEmpty()) {
       PRInt32 error;
       colspan = value.ToInteger(&error);
-      if (error || colspan < 0)
+      if (error || colspan < 0 || colspan > MAX_COLSPAN)
         colspan = 1;
     }
   }
diff --git a/layout/tables/celldata.h b/layout/tables/celldata.h
index 08c3b9d..44965e3 100644
--- a/layout/tables/celldata.h
+++ b/layout/tables/celldata.h
@@ -44,6 +44,10 @@ class nsTableCellFrame;
 class nsCellMap;
 class BCCellData;
 
+
+#define MAX_ROWSPAN 8190 // the cellmap can not handle more
+#define MAX_COLSPAN 1000 // limit as IE and opera do
+
 /** 
   * Data stored by nsCellMap to rationalize rowspan and colspan cells.
   */
diff --git a/xpcom/glue/nsTArray.cpp b/xpcom/glue/nsTArray.cpp
index 5932dff..b594526 100644
--- a/xpcom/glue/nsTArray.cpp
+++ b/xpcom/glue/nsTArray.cpp
@@ -65,7 +65,7 @@ nsTArray_base::EnsureCapacity(size_type capacity, size_type elemSize) {
   // doubling algorithm may not be able to allocate it.  Additionally we
   // couldn't fit in the Header::mCapacity member. Just bail out in cases
   // like that.  We don't want to be allocating 2 GB+ arrays anyway.
-  if (capacity * elemSize > size_type(-1)/2) {
+  if ((PRUint64)capacity * elemSize > size_type(-1)/2) {
     NS_ERROR(""""Attempting to allocate excessively large array"""");
     return PR_FALSE;
   }"""
90fd9d99bd27752a488e7c1f1da275c133782971,76093,441360,reed%reedloden.com,"Bug 441360 - [p=mats.palmgren@bredband.net (Mats Palmgren) r+sr=vlad a=beltzner]
",1214892773,"""diff --git a/gfx/thebes/src/gfxQuartzSurface.cpp b/gfx/thebes/src/gfxQuartzSurface.cpp
index 9375bcb..39b55ab 100644
--- a/gfx/thebes/src/gfxQuartzSurface.cpp
+++ b/gfx/thebes/src/gfxQuartzSurface.cpp
@@ -42,7 +42,7 @@
 
 gfxQuartzSurface::gfxQuartzSurface(const gfxSize& size, gfxImageFormat format,
                                    PRBool aForPrinting)
-    : mSize(size), mForPrinting(aForPrinting)
+    : mCGContext(NULL), mSize(size), mForPrinting(aForPrinting)
 {
     unsigned int width = (unsigned int) floor(size.width);
     unsigned int height = (unsigned int) floor(size.height);"""
02622ca047332186b3bddf0e6226d01a9e8a882e,76095,441169,reed%reedloden.com,"Bug 441169 - [p=johnath@mozilla.com (Johnathan Nightingale [johnath]) r=bzbarsky sr=dveditz a=beltzner]
",1214892458,"""diff --git a/docshell/resources/content/netError.xhtml b/docshell/resources/content/netError.xhtml
index 7409ed4..5d59289 100644
--- a/docshell/resources/content/netError.xhtml
+++ b/docshell/resources/content/netError.xhtml
@@ -214,8 +214,34 @@
       function addDomainErrorLink() {
         // Rather than textContent, we need to treat description as HTML
         var sd = document.getElementById(""""errorShortDescText"""");
-        if (sd)
-          sd.innerHTML = getDescription();
+        if (sd) {
+          var desc = getDescription();
+          
+          // sanitize description text - see bug 441169
+          
+          // First, find the index of the <a> tag we care about, being careful not to
+          // use an over-greedy regex
+          var re = /<a id=""""cert_domain_link"""" title=""""([^""""]+)"""">/;
+          var result = re.exec(desc);
+          if(!result)
+            return;
+          
+          // Remove sd's existing children
+          sd.textContent = """""""";
+
+          // Everything up to the link should be text content
+          sd.appendChild(document.createTextNode(desc.slice(0, result.index)));
+          
+          // Now create the link itself
+          var anchorEl = document.createElement(""""a"""");
+          anchorEl.setAttribute(""""id"""", """"cert_domain_link"""");
+          anchorEl.setAttribute(""""title"""", result[1]);
+          anchorEl.appendChild(document.createTextNode(result[1]));
+          sd.appendChild(anchorEl);
+          
+          // Finally, append text for anything after the closing </a>
+          sd.appendChild(document.createTextNode(desc.slice(desc.indexOf(""""</a>"""") + """"</a>"""".length)));
+        }
 
         var link = document.getElementById('cert_domain_link');
         if (!link)
diff --git a/docshell/test/browser/Makefile.in b/docshell/test/browser/Makefile.in
index 06ddbc2..120614a 100644
--- a/docshell/test/browser/Makefile.in
+++ b/docshell/test/browser/Makefile.in
@@ -47,6 +47,7 @@ _BROWSER_TEST_FILES =	\
 		browser_bug349769.js \
 		browser_bug388121-1.js \
 		browser_bug388121-2.js \
+		browser_bug441169.js \
 		$(NULL)
 
 # the tests below use FUEL, which is a Firefox-specific feature
diff --git a/docshell/test/browser/browser_bug441169.js b/docshell/test/browser/browser_bug441169.js
new file mode 100644
index 0000000..6a7be2b
--- /dev/null
+++ b/docshell/test/browser/browser_bug441169.js
@@ -0,0 +1,26 @@
+/* Make sure that netError won't allow HTML injection through badcert parameters.  See bug 441169. */
+var newBrowser
+
+// An edited version of the standard neterror url which attempts to
+// insert a <span id=""""test_span""""> tag into the text.  We will navigate to this page
+// and ensure that the span tag is not parsed as HTML.
+var chromeURL = """"about:neterror?e=nssBadCert&u=https%3A//test.kuix.de/&c=UTF-8&d=This%20sentence%20should%20not%20be%20parsed%20to%20include%20a%20%3Cspan%20id=%22test_span%22%3Enamed%3C/span%3E%20span%20tag.%0A%0AThe%20certificate%20is%20only%20valid%20for%20%3Ca%20id=%22cert_domain_link%22%20title=%22kuix.de%22%3Ekuix.de%3C/a%3E%0A%0A(Error%20code%3A%20ssl_error_bad_cert_domain)"""";
+
+function test() {
+  waitForExplicitFinish();
+  
+  var newTab = gBrowser.addTab();
+  gBrowser.selectedTab = newTab;
+  newBrowser = gBrowser.getBrowserForTab(newTab);
+  
+  window.addEventListener(""""DOMContentLoaded"""", checkPage, false);
+  newBrowser.contentWindow.location = chromeURL;
+}
+
+function checkPage() {
+  
+  is(newBrowser.contentDocument.getElementById(""""test_span""""), null, """"Error message should not be parsed as HTML, and hence shouldn't include the 'test_span' element."""");
+  
+  gBrowser.removeCurrentTab();
+  finish();
+}"""
8be881e19d34353aa00eba180312a7f60a0af150,76099,441120,gavin%gavinsharp.com,"Bug 441120: r=mconnor, sr=dveditz, a=beltzner
",1214891532,"""diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
index 77c426a..288becb 100644
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -673,7 +673,13 @@ function BrowserStartup()
   gBrowser = document.getElementById(""""content"""");
 
   var uriToLoad = null;
-  // Check for window.arguments[0]. If present, use that for uriToLoad.
+
+  // window.arguments[0]: URI to load (string), or an nsISupportsArray of
+  //                      nsISupportsStrings to load
+  //                 [1]: character set (string)
+  //                 [2]: referrer (nsIURI)
+  //                 [3]: postData (nsIInputStream)
+  //                 [4]: allowThirdPartyFixup (bool)
   if (""""arguments"""" in window && window.arguments[0])
     uriToLoad = window.arguments[0];
 
@@ -686,9 +692,26 @@ function BrowserStartup()
 #else
 # only load url passed in when we're not page cycling
   if (uriToLoad && !gIsLoadingBlank) {
-    if (window.arguments.length >= 3)
+    if (uriToLoad instanceof Components.interfaces.nsISupportsArray) {
+      var count = uriToLoad.Count();
+      var specs = [];
+      for (var i = 0; i < count; i++) {
+        var urisstring = uriToLoad.GetElementAt(i).QueryInterface(Components.interfaces.nsISupportsString);
+        specs.push(urisstring.data);
+      }
+
+      // This function throws for certain malformed URIs, so use exception handling
+      // so that we don't disrupt startup
+      try {
+        gBrowser.loadTabs(specs, false, true);
+      } catch (e) {}
+    }
+    else if (window.arguments.length >= 3) {
       loadURI(uriToLoad, window.arguments[2], window.arguments[3] || null,
               window.arguments[4] || false);
+    }
+    // Note: loadOneOrMoreURIs *must not* be called if window.arguments.length >= 3.
+    // Such callers expect that window.arguments[0] is handled as a single URI.
     else
       loadOneOrMoreURIs(uriToLoad);
   }
@@ -4310,7 +4333,9 @@ nsBrowserAccess.prototype =
         // FIXME: Bug 408379. So how come this doesn't send the
         // referrer like the other loads do?
         var url = aURI ? aURI.spec : """"about:blank"""";
-        newWindow = openDialog(getBrowserURL(), """"_blank"""", """"all,dialog=no"""", url);
+        // Pass all params to openDialog to ensure that """"url"""" isn't passed through
+        // loadOneOrMoreURIs, which splits based on """"|""""
+        newWindow = openDialog(getBrowserURL(), """"_blank"""", """"all,dialog=no"""", url, null, null, null);
         break;
       case Ci.nsIBrowserDOMWindow.OPEN_NEWTAB :
         var win = this._getMostRecentBrowserWindow();
diff --git a/browser/components/nsBrowserContentHandler.js b/browser/components/nsBrowserContentHandler.js
index ee2e43f..2e3308a 100644
--- a/browser/components/nsBrowserContentHandler.js
+++ b/browser/components/nsBrowserContentHandler.js
@@ -176,17 +176,52 @@ function copyPrefOverride() {
   }
 }
 
+function splitPipesIntoArray(aSpec) {
+  var specs = aSpec.split(""""|"""");
+  if (specs.length > 1)
+    return specs;
+
+  return aSpec;
+}
+
 function openWindow(parent, url, target, features, args) {
   var wwatch = Components.classes[""""@mozilla.org/embedcomp/window-watcher;1""""]
                          .getService(nsIWindowWatcher);
 
-  var argstring;
-  if (args) {
-    argstring = Components.classes[""""@mozilla.org/supports-string;1""""]
-                            .createInstance(nsISupportsString);
-    argstring.data = args;
+  var argArray = Components.classes[""""@mozilla.org/supports-array;1""""]
+                    .createInstance(Components.interfaces.nsISupportsArray);
+
+  // add args to the arguments array
+  var stringArgs = null;
+  if (args instanceof Array) // array
+    stringArgs = args;
+  else if (args) // string
+    stringArgs = [args];
+
+  if (stringArgs) {
+    // put the URIs into argArray
+    var uriArray = Components.classes[""""@mozilla.org/supports-array;1""""]
+                       .createInstance(Components.interfaces.nsISupportsArray);
+    stringArgs.forEach(function (uri) {
+      var sstring = Components.classes[""""@mozilla.org/supports-string;1""""]
+                              .createInstance(nsISupportsString);
+      sstring.data = uri;
+      uriArray.AppendElement(sstring);
+    });
+    argArray.AppendElement(uriArray);
+  } else {
+    argArray.AppendElement(null);
   }
-  return wwatch.openWindow(parent, url, target, features, argstring);
+
+  // Pass these as null to ensure that we always trigger the """"single URL""""
+  // behavior in browser.js's BrowserStartup (which handles the window
+  // arguments)
+  argArray.AppendElement(null); // charset
+  argArray.AppendElement(null); // referer
+  argArray.AppendElement(null); // postData
+  argArray.AppendElement(null); // allowThirdPartyFixup
+
+  return wwatch.openWindow(parent, url, target, features, argArray);
 }
 
 function openPreferences() {
@@ -318,7 +353,7 @@ var nsBrowserContentHandler = {
     if (cmdLine.handleFlag(""""browser"""", false)) {
       openWindow(null, this.chromeURL, """"_blank"""",
                  """"chrome,dialog=no,all"""" + this.getFeatures(cmdLine),
-                 this.defaultArgs);
+                 splitPipesIntoArray(this.defaultArgs));
       cmdLine.preventDefault = true;
     }
 
@@ -381,7 +416,7 @@ var nsBrowserContentHandler = {
 
           openWindow(null, this.chromeURL, """"_blank"""",
                      """"chrome,dialog=no,all"""" + this.getFeatures(cmdLine),
-                     this.defaultArgs);
+                     splitPipesIntoArray(this.defaultArgs));
           break;
 
         default:
@@ -442,7 +477,7 @@ var nsBrowserContentHandler = {
         var netutil = Components.classes[""""@mozilla.org/network/util;1""""]
                                 .getService(nsINetUtil);
         if (!netutil.URIChainHasFlags(uri, URI_INHERITS_SECURITY_CONTEXT)) {
-          openWindow(null, uri.spec, """"_blank"""", features, """""""");
+          openWindow(null, uri.spec, """"_blank"""", features);
           cmdLine.preventDefault = true;
         }
       }
@@ -774,23 +809,18 @@ var nsDefaultCommandLineHandler = {
         }
       }
 
-      var speclist = [];
-      for (uri in urilist) {
-        if (shouldLoadURI(urilist[uri]))
-          speclist.push(urilist[uri].spec);
-      }
-
-      if (speclist.length) {
+      var URLlist = urilist.filter(shouldLoadURI).map(function (u) u.spec);
+      if (URLlist.length) {
         openWindow(null, nsBrowserContentHandler.chromeURL, """"_blank"""",
                    """"chrome,dialog=no,all"""" + nsBrowserContentHandler.getFeatures(cmdLine),
-                   speclist.join(""""|""""));
+                   URLlist);
       }
 
     }
     else if (!cmdLine.preventDefault) {
       openWindow(null, nsBrowserContentHandler.chromeURL, """"_blank"""",
                  """"chrome,dialog=no,all"""" + nsBrowserContentHandler.getFeatures(cmdLine),
-                 nsBrowserContentHandler.defaultArgs);
+                 splitPipesIntoArray(nsBrowserContentHandler.defaultArgs));
     }
   },
 """
230e62ff8f90427f2ec3b53adb99b895517eeecf,77492,430658,mozilla.mano%sent.com,"Bug 430658, r+a=mconnor.
",1209677922,"""diff --git a/browser/components/feeds/src/FeedWriter.js b/browser/components/feeds/src/FeedWriter.js
index 424a25e..c6bd595 100755
--- a/browser/components/feeds/src/FeedWriter.js
+++ b/browser/components/feeds/src/FeedWriter.js
@@ -394,8 +394,12 @@ FeedWriter.prototype = {
    */
   _setTitleText: function FW__setTitleText(container) {
     if (container.title) {
-      this._setContentText(TITLE_ID, container.title.plainText());
-      this._document.title = container.title.plainText();
+      var title = container.title.plainText();
+      this._setContentText(TITLE_ID, title);
+      this._contentSandbox.document = this._document;
+      this._contentSandbox.title = title;
+      var codeStr = """"document.title = title;""""
+      Cu.evalInSandbox(codeStr, this._contentSandbox);
     }
 
     var feed = container.QueryInterface(Ci.nsIFeed);
@@ -424,19 +428,21 @@ FeedWriter.prototype = {
                                                [parts.getPropertyAsAString(""""title"""")]);
       this._contentSandbox.feedTitleLink = feedTitleLink;
       this._contentSandbox.titleText = titleText;
-      var codeStr = """"feedTitleLink.setAttribute('title', titleText);"""";
+      this._contentSandbox.feedTitleText = this._document.getElementById(""""feedTitleText"""");
+      this._contentSandbox.titleImageWidth = parseInt(parts.getPropertyAsAString(""""width"""")) + 15;
+
+      // Fix the margin on the main title, so that the image doesn't run over
+      // the underline
+      var codeStr = """"feedTitleLink.setAttribute('title', titleText); """" +
+                    """"feedTitleText.style.marginRight = titleImageWidth + 'px';"""";
       Cu.evalInSandbox(codeStr, this._contentSandbox);
       this._contentSandbox.feedTitleLink = null;
       this._contentSandbox.titleText = null;
+      this._contentSandbox.feedTitleText = null;
+      this._contentSandbox.titleImageWidth = null;
 
       this._safeSetURIAttribute(feedTitleLink, """"href"""", 
                                 parts.getPropertyAsAString(""""link""""));
-
-      // Fix the margin on the main title, so that the image doesn't run over
-      // the underline
-      var feedTitleText = this._document.getElementById(""""feedTitleText"""");
-      var titleImageWidth = parseInt(parts.getPropertyAsAString(""""width"""")) + 15;
-      feedTitleText.style.marginRight = titleImageWidth + """"px"""";
     }
     catch (e) {
       LOG(""""Failed to set Title Image (this is benign): """" + e);
@@ -959,7 +965,6 @@ FeedWriter.prototype = {
 
       default:
         codeStr = """"header.className = 'feedBackground'; """";
-        header.className = """"feedBackground"""";
     }
 
 """
a18c9170fd6157b0f3c264d6151b3d369e8d14ce,78018,412363,philringnalda%gmail.com,"Bug 412363 - Buffer overflow in external MIME bodies, p=ebirol@gmail.com (Emre Birol), r=dveditz, sr=dmose
",1208586342,"""diff --git a/mailnews/mime/src/mimeebod.cpp b/mailnews/mime/src/mimeebod.cpp
index cc58a86..8c98679 100644
--- a/mailnews/mime/src/mimeebod.cpp
+++ b/mailnews/mime/src/mimeebod.cpp
@@ -177,6 +177,7 @@ MimeExternalBody_make_url(const char *ct,
               const char *svr, const char *subj, const char *body)
 {
   char *s;
+  PRUint32 slen;
   if (!at)
   {
     return 0;
@@ -185,16 +186,18 @@ MimeExternalBody_make_url(const char *ct,
   {
     if (!site || !name)
       return 0;
-    s = (char *) PR_MALLOC(strlen(name) + strlen(site) +
-                           (dir  ? strlen(dir) : 0) + 20);
+	  
+    slen = strlen(name) + strlen(site) + (dir ? strlen(dir) : 0) + 20;
+    s = (char *) PR_MALLOC(slen);
+
     if (!s) return 0;
-    PL_strcpy(s, """"ftp://"""");
-    PL_strcat(s, site);
-    PL_strcat(s, """"/"""");
-    if (dir) PL_strcat(s, (dir[0] == '/' ? dir+1 : dir));
+    PL_strncpyz(s, """"ftp://"""", slen);
+    PL_strcatn(s, slen, site);
+    PL_strcatn(s, slen, """"/"""");
+    if (dir) PL_strcatn(s, slen, (dir[0] == '/' ? dir+1 : dir));
     if (s[strlen(s)-1] != '/')
-      PL_strcat(s, """"/"""");
-    PL_strcat(s, name);
+      PL_strcatn(s, slen, """"/"""");
+    PL_strcatn(s, slen, name);
     return s;
   }
   else if (!PL_strcasecmp(at, """"local-file"""") || !PL_strcasecmp(at, """"afs""""))
@@ -219,40 +222,42 @@ MimeExternalBody_make_url(const char *ct,
     return 0;            /* never, if not Unix. */
 #endif /* !XP_UNIX */
 
-    s = (char *) PR_MALLOC(strlen(name)*3 + 20);
+    slen = (strlen(name) * 3 + 20);
+    s = (char *) PR_MALLOC(slen);
     if (!s) return 0;
-    PL_strcpy(s, """"file:"""");
+    PL_strncpyz(s, """"file:"""", slen);
 
     nsCString s2;
     MsgEscapeString(nsDependentCString(name), nsINetUtil::ESCAPE_URL_PATH, s2);
-    PL_strcat(s, s2.get());
+    PL_strcatn(s, slen, s2.get());
     return s;
   }
 else if (!PL_strcasecmp(at, """"mail-server""""))
 {
   if (!svr)
     return 0;
-  s = (char *) PR_MALLOC(strlen(svr)*4 +
-                         (subj ? strlen(subj)*4 : 0) +
-                         (body ? strlen(body)*4 : 0) + 20);
+	
+  slen =  (strlen(svr)*4 + (subj ? strlen(subj)*4 : 0) +
+                         (body ? strlen(body)*4 : 0) + 25); // dpv xxx: why 4x? %xx escaping should be 3x
+  s = (char *) PR_MALLOC(slen);
   if (!s) return 0;
-  PL_strcpy(s, """"mailto:"""");
+  PL_strncpyz(s, """"mailto:"""", slen);
 
   nsCString s2;
   MsgEscapeString(nsDependentCString(svr), nsINetUtil::ESCAPE_XALPHAS, s2);
-  PL_strcat(s, s2.get());
+  PL_strcatn(s, slen, s2.get());
 
   if (subj)
     {
       MsgEscapeString(nsDependentCString(subj), nsINetUtil::ESCAPE_XALPHAS, s2);
-      PL_strcat(s, """"?subject="""");
-      PL_strcat(s, s2.get());
+      PL_strcatn(s, slen, """"?subject="""");
+      PL_strcatn(s, slen, s2.get());
     }
   if (body)
     {
       MsgEscapeString(nsDependentCString(body), nsINetUtil::ESCAPE_XALPHAS, s2);
-      PL_strcat(s, (subj ? """"&body="""" : """"?body=""""));
-      PL_strcat(s, s2.get());
+      PL_strcatn(s, slen, (subj ? """"&body="""" : """"?body=""""));
+      PL_strcatn(s, slen, s2.get());
     }
   return s;
 }
@@ -318,19 +323,21 @@ MimeExternalBody_parse_eof (MimeObject *obj, PRBool abort_p)
     /* the *internal* content-type */
     ct = MimeHeaders_get(bod->hdrs, HEADER_CONTENT_TYPE,
                          PR_TRUE, PR_FALSE);
-
-    h = (char *) PR_MALLOC((at ? strlen(at) : 0) +
-                           (lexp ? strlen(lexp) : 0) +
-                           (size ? strlen(size) : 0) +
-                           (perm ? strlen(perm) : 0) +
-                           (dir ? strlen(dir) : 0) +
-                           (mode ? strlen(mode) : 0) +
-                           (name ? strlen(name) : 0) +
-                           (site ? strlen(site) : 0) +
-                           (svr ? strlen(svr) : 0) +
-                           (subj ? strlen(subj) : 0) +
-                           (ct ? strlen(ct) : 0) +
-                           (url ? strlen(url) : 0) + 100);
+						 
+    PRUint32 hlen = ((at ? strlen(at) : 0) +
+                    (lexp ? strlen(lexp) : 0) +
+                    (size ? strlen(size) : 0) +
+                    (perm ? strlen(perm) : 0) +
+                    (dir ? strlen(dir) : 0) +
+                    (mode ? strlen(mode) : 0) +
+                    (name ? strlen(name) : 0) +
+                    (site ? strlen(site) : 0) +
+                    (svr ? strlen(svr) : 0) +
+                    (subj ? strlen(subj) : 0) +
+                    (ct ? strlen(ct) : 0) +
+                    (url ? strlen(url) : 0) + 100);
+					
+	h = (char *) PR_MALLOC(hlen);
     if (!h)
     {
       status = MIME_OUT_OF_MEMORY;
@@ -362,9 +369,9 @@ MimeExternalBody_parse_eof (MimeObject *obj, PRBool abort_p)
 # define FROB(STR,VAR) \
     if (VAR) \
     { \
-      PL_strcpy(h, STR """": """"); \
-        PL_strcat(h, VAR); \
-          PL_strcat(h, MSG_LINEBREAK); \
+      PL_strncpyz(h, STR """": """", hlen); \
+        PL_strcatn(h, hlen, VAR); \
+          PL_strcatn(h, hlen, MSG_LINEBREAK); \
             status = MimeHeaders_parse_line(h, strlen(h), hdrs); \
               if (status < 0) goto FAIL; \
     }
@@ -381,7 +388,7 @@ MimeExternalBody_parse_eof (MimeObject *obj, PRBool abort_p)
     FROB(""""Expiration"""",  lexp);
     FROB(""""Subject"""",    subj);
 # undef FROB
-    PL_strcpy(h, MSG_LINEBREAK);
+    PL_strncpyz(h, MSG_LINEBREAK, hlen);
     status = MimeHeaders_parse_line(h, strlen(h), hdrs);
     if (status < 0) goto FAIL;
 """
417a40c386148f5931af09548eb1ea3b26734bb6,78026,410156,rob_strong%exchangecode.com,"Relanding Bug 410156 - r=bsmedberg, approval1.9=beltzner, blocking-firefox3=beltzner
",1208551430,"""diff --git a/toolkit/components/commandlines/src/nsCommandLine.cpp b/toolkit/components/commandlines/src/nsCommandLine.cpp
index 70e34dc..c4b7933 100644
--- a/toolkit/components/commandlines/src/nsCommandLine.cpp
+++ b/toolkit/components/commandlines/src/nsCommandLine.cpp
@@ -95,6 +95,7 @@ protected:
 					void *aClosure);
 
   void appendArg(const char* arg);
+  void resolveShortcutURL(nsILocalFile* aFile, nsACString& outURL);
   nsresult EnumerateHandlers(EnumerateHandlersCallback aCallback, void *aClosure);
   nsresult EnumerateValidators(EnumerateValidatorsCallback aCallback, void *aClosure);
 
@@ -442,16 +443,26 @@ nsCommandLine::ResolveURI(const nsAString& aArgument, nsIURI* *aResult)
   nsCOMPtr<nsIIOService> io = do_GetIOService();
   NS_ENSURE_TRUE(io, NS_ERROR_OUT_OF_MEMORY);
 
+  nsCOMPtr<nsIURI> workingDirURI;
+  if (mWorkingDir) {
+    io->NewFileURI(mWorkingDir, getter_AddRefs(workingDirURI));
+  }
+
   nsCOMPtr<nsILocalFile> lf (do_CreateInstance(NS_LOCAL_FILE_CONTRACTID));
   rv = lf->InitWithPath(aArgument);
   if (NS_SUCCEEDED(rv)) {
     lf->Normalize();
-    return io->NewFileURI(lf, aResult);
-  }
+    nsCAutoString url;
+    // Try to resolve the url for .url files.
+    resolveShortcutURL(lf, url);
+    if (!url.IsEmpty()) {
+      return io->NewURI(url,
+                        nsnull,
+                        workingDirURI,
+                        aResult);
+    }
 
-  nsCOMPtr<nsIURI> workingDirURI;
-  if (mWorkingDir) {
-    io->NewFileURI(mWorkingDir, getter_AddRefs(workingDirURI));
+    return io->NewFileURI(lf, aResult);
   }
 
   return io->NewURI(NS_ConvertUTF16toUTF8(aArgument),
@@ -477,6 +488,22 @@ nsCommandLine::appendArg(const char* arg)
   mArgs.AppendString(warg);
 }
 
+void
+nsCommandLine::resolveShortcutURL(nsILocalFile* aFile, nsACString& outURL)
+{
+  nsCOMPtr<nsIFileProtocolHandler> fph;
+  nsresult rv = NS_GetFileProtocolHandler(getter_AddRefs(fph));
+  if (NS_FAILED(rv))
+    return;
+
+  nsCOMPtr<nsIURI> uri;
+  rv = fph->ReadURLFile(aFile, getter_AddRefs(uri));
+  if (NS_FAILED(rv))
+    return;
+
+  uri->GetSpec(outURL);
+}
+
 NS_IMETHODIMP
 nsCommandLine::Init(PRInt32 argc, char** argv, nsIFile* aWorkingDir,
                     PRUint32 aState)
diff --git a/toolkit/components/commandlines/test/Makefile.in b/toolkit/components/commandlines/test/Makefile.in
index 1e2e001..3076204 100644
--- a/toolkit/components/commandlines/test/Makefile.in
+++ b/toolkit/components/commandlines/test/Makefile.in
@@ -50,4 +50,12 @@ XPCSHELL_TESTS = \
                  unit \
                  $(NULL)
 
+ifeq ($(OS_ARCH),WINNT)
+XPCSHELL_TESTS += unit/win
+else
+ifneq (,$(filter-out OS2 Darwin,$(OS_ARCH)))
+XPCSHELL_TESTS += unit/unix
+endif
+endif
+
 include $(topsrcdir)/config/rules.mk
diff --git a/toolkit/components/commandlines/test/unit/unix/test_bug410156.js b/toolkit/components/commandlines/test/unit/unix/test_bug410156.js
new file mode 100644
index 0000000..82a2399
--- /dev/null
+++ b/toolkit/components/commandlines/test/unit/unix/test_bug410156.js
@@ -0,0 +1,43 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Command Line tests.
+ *
+ * The Initial Developer of the Original Code is
+ * Robert Strong <robert_bugzila@gmail.com>.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+function run_test() {
+  var clClass = Components.classes[""""@mozilla.org/toolkit/command-line;1""""];
+  var commandLine = clClass.createInstance();
+  var urlFile = do_get_file(""""toolkit/components/commandlines/test/unit/data/test_bug410156.desktop"""");
+  var uri = commandLine.resolveURI(urlFile.path);
+  do_check_eq(uri.spec, """"http://www.bug410156.com/"""");
+}
diff --git a/toolkit/components/commandlines/test/unit/win/test_bug410156.js b/toolkit/components/commandlines/test/unit/win/test_bug410156.js
new file mode 100644
index 0000000..d594416
--- /dev/null
+++ b/toolkit/components/commandlines/test/unit/win/test_bug410156.js
@@ -0,0 +1,43 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the """"License""""); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an """"AS IS"""" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Command Line tests.
+ *
+ * The Initial Developer of the Original Code is
+ * Robert Strong <robert_bugzila@gmail.com>.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the """"GPL""""), or
+ * the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+function run_test() {
+  var clClass = Components.classes[""""@mozilla.org/toolkit/command-line;1""""];
+  var commandLine = clClass.createInstance();
+  var urlFile = do_get_file(""""toolkit/components/commandlines/test/unit/data/test_bug410156.url"""");
+  var uri = commandLine.resolveURI(urlFile.path);
+  do_check_eq(uri.spec, """"http://www.bug410156.com/"""");
+}"""
964bb6caa885c7dfd197a6df0539acbe9e7afe9b,78088,410156,rob_strong%exchangecode.com,"Backing out Bug 410156 due to test bustage
",1208474012,"""diff --git a/toolkit/components/commandlines/test/unit/test_bug410156.js.in b/toolkit/components/commandlines/test/unit/test_bug410156.js.in
deleted file mode 100644
index e69de29..0000000"""
6704a97d9c754613653acff54297884dd87c4af6,78089,410156,rob_strong%exchangecode.com,"Backing out Bug 410156 due to test bustage
",1208473506,"""diff --git a/toolkit/components/commandlines/src/nsCommandLine.cpp b/toolkit/components/commandlines/src/nsCommandLine.cpp
index c4b7933..70e34dc 100644
--- a/toolkit/components/commandlines/src/nsCommandLine.cpp
+++ b/toolkit/components/commandlines/src/nsCommandLine.cpp
@@ -95,7 +95,6 @@ protected:
 					void *aClosure);
 
   void appendArg(const char* arg);
-  void resolveShortcutURL(nsILocalFile* aFile, nsACString& outURL);
   nsresult EnumerateHandlers(EnumerateHandlersCallback aCallback, void *aClosure);
   nsresult EnumerateValidators(EnumerateValidatorsCallback aCallback, void *aClosure);
 
@@ -443,28 +442,18 @@ nsCommandLine::ResolveURI(const nsAString& aArgument, nsIURI* *aResult)
   nsCOMPtr<nsIIOService> io = do_GetIOService();
   NS_ENSURE_TRUE(io, NS_ERROR_OUT_OF_MEMORY);
 
-  nsCOMPtr<nsIURI> workingDirURI;
-  if (mWorkingDir) {
-    io->NewFileURI(mWorkingDir, getter_AddRefs(workingDirURI));
-  }
-
   nsCOMPtr<nsILocalFile> lf (do_CreateInstance(NS_LOCAL_FILE_CONTRACTID));
   rv = lf->InitWithPath(aArgument);
   if (NS_SUCCEEDED(rv)) {
     lf->Normalize();
-    nsCAutoString url;
-    // Try to resolve the url for .url files.
-    resolveShortcutURL(lf, url);
-    if (!url.IsEmpty()) {
-      return io->NewURI(url,
-                        nsnull,
-                        workingDirURI,
-                        aResult);
-    }
-
     return io->NewFileURI(lf, aResult);
   }
 
+  nsCOMPtr<nsIURI> workingDirURI;
+  if (mWorkingDir) {
+    io->NewFileURI(mWorkingDir, getter_AddRefs(workingDirURI));
+  }
+
   return io->NewURI(NS_ConvertUTF16toUTF8(aArgument),
                     nsnull,
                     workingDirURI,
@@ -488,22 +477,6 @@ nsCommandLine::appendArg(const char* arg)
   mArgs.AppendString(warg);
 }
 
-void
-nsCommandLine::resolveShortcutURL(nsILocalFile* aFile, nsACString& outURL)
-{
-  nsCOMPtr<nsIFileProtocolHandler> fph;
-  nsresult rv = NS_GetFileProtocolHandler(getter_AddRefs(fph));
-  if (NS_FAILED(rv))
-    return;
-
-  nsCOMPtr<nsIURI> uri;
-  rv = fph->ReadURLFile(aFile, getter_AddRefs(uri));
-  if (NS_FAILED(rv))
-    return;
-
-  uri->GetSpec(outURL);
-}
-
 NS_IMETHODIMP
 nsCommandLine::Init(PRInt32 argc, char** argv, nsIFile* aWorkingDir,
                     PRUint32 aState)
diff --git a/toolkit/components/commandlines/test/Makefile.in b/toolkit/components/commandlines/test/Makefile.in
index 09eccc7..1e2e001 100644
--- a/toolkit/components/commandlines/test/Makefile.in
+++ b/toolkit/components/commandlines/test/Makefile.in
@@ -45,16 +45,9 @@ VPATH		= @srcdir@
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= test_harness_commandlines
-TESTROOT	= $(shell cd $(DEPTH) && pwd)/_tests/xpcshell-simple/$(MODULE)
 
 XPCSHELL_TESTS = \
                  unit \
                  $(NULL)
 
 include $(topsrcdir)/config/rules.mk
-
-ifneq (,$(filter-out OS2 Darwin,$(OS_ARCH)))
-# Hack to allow preprocessing of test_bug410156.js
-libs:: unit/test_bug410156.js.in
-	$(PYTHON) $(MOZILLA_DIR)/config/Preprocessor.py $(DEFINES) $(ACDEFINES) $^ > $(TESTROOT)/unit/test_bug410156.js
-endif"""
cce66412e05f8a92267c0619856f1aa6bb0f52fb,78090,410156,rob_strong%exchangecode.com,"Bustage fix for Bug 410156
",1208473193,"""diff --git a/toolkit/components/commandlines/test/Makefile.in b/toolkit/components/commandlines/test/Makefile.in
index 224b4f5..09eccc7 100644
--- a/toolkit/components/commandlines/test/Makefile.in
+++ b/toolkit/components/commandlines/test/Makefile.in
@@ -53,6 +53,8 @@ XPCSHELL_TESTS = \
 
 include $(topsrcdir)/config/rules.mk
 
+ifneq (,$(filter-out OS2 Darwin,$(OS_ARCH)))
 # Hack to allow preprocessing of test_bug410156.js
 libs:: unit/test_bug410156.js.in
 	$(PYTHON) $(MOZILLA_DIR)/config/Preprocessor.py $(DEFINES) $(ACDEFINES) $^ > $(TESTROOT)/unit/test_bug410156.js
+endif"""
cb35546b41b7bbabe3cbb3cc04a60726282eaf99,78094,410156,rob_strong%exchangecode.com,"Bug 410156 - r=bsmedberg, approval1.9=beltzner, blocking-firefox3=beltzner
",1208470820,"""diff --git a/toolkit/components/commandlines/src/nsCommandLine.cpp b/toolkit/components/commandlines/src/nsCommandLine.cpp
index 70e34dc..c4b7933 100644
--- a/toolkit/components/commandlines/src/nsCommandLine.cpp
+++ b/toolkit/components/commandlines/src/nsCommandLine.cpp
@@ -95,6 +95,7 @@ protected:
 					void *aClosure);
 
   void appendArg(const char* arg);
+  void resolveShortcutURL(nsILocalFile* aFile, nsACString& outURL);
   nsresult EnumerateHandlers(EnumerateHandlersCallback aCallback, void *aClosure);
   nsresult EnumerateValidators(EnumerateValidatorsCallback aCallback, void *aClosure);
 
@@ -442,16 +443,26 @@ nsCommandLine::ResolveURI(const nsAString& aArgument, nsIURI* *aResult)
   nsCOMPtr<nsIIOService> io = do_GetIOService();
   NS_ENSURE_TRUE(io, NS_ERROR_OUT_OF_MEMORY);
 
+  nsCOMPtr<nsIURI> workingDirURI;
+  if (mWorkingDir) {
+    io->NewFileURI(mWorkingDir, getter_AddRefs(workingDirURI));
+  }
+
   nsCOMPtr<nsILocalFile> lf (do_CreateInstance(NS_LOCAL_FILE_CONTRACTID));
   rv = lf->InitWithPath(aArgument);
   if (NS_SUCCEEDED(rv)) {
     lf->Normalize();
-    return io->NewFileURI(lf, aResult);
-  }
+    nsCAutoString url;
+    // Try to resolve the url for .url files.
+    resolveShortcutURL(lf, url);
+    if (!url.IsEmpty()) {
+      return io->NewURI(url,
+                        nsnull,
+                        workingDirURI,
+                        aResult);
+    }
 
-  nsCOMPtr<nsIURI> workingDirURI;
-  if (mWorkingDir) {
-    io->NewFileURI(mWorkingDir, getter_AddRefs(workingDirURI));
+    return io->NewFileURI(lf, aResult);
   }
 
   return io->NewURI(NS_ConvertUTF16toUTF8(aArgument),
@@ -477,6 +488,22 @@ nsCommandLine::appendArg(const char* arg)
   mArgs.AppendString(warg);
 }
 
+void
+nsCommandLine::resolveShortcutURL(nsILocalFile* aFile, nsACString& outURL)
+{
+  nsCOMPtr<nsIFileProtocolHandler> fph;
+  nsresult rv = NS_GetFileProtocolHandler(getter_AddRefs(fph));
+  if (NS_FAILED(rv))
+    return;
+
+  nsCOMPtr<nsIURI> uri;
+  rv = fph->ReadURLFile(aFile, getter_AddRefs(uri));
+  if (NS_FAILED(rv))
+    return;
+
+  uri->GetSpec(outURL);
+}
+
 NS_IMETHODIMP
 nsCommandLine::Init(PRInt32 argc, char** argv, nsIFile* aWorkingDir,
                     PRUint32 aState)
diff --git a/toolkit/components/commandlines/test/Makefile.in b/toolkit/components/commandlines/test/Makefile.in
index 1e2e001..224b4f5 100644
--- a/toolkit/components/commandlines/test/Makefile.in
+++ b/toolkit/components/commandlines/test/Makefile.in
@@ -45,9 +45,14 @@ VPATH		= @srcdir@
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= test_harness_commandlines
+TESTROOT	= $(shell cd $(DEPTH) && pwd)/_tests/xpcshell-simple/$(MODULE)
 
 XPCSHELL_TESTS = \
                  unit \
                  $(NULL)
 
 include $(topsrcdir)/config/rules.mk
+
+# Hack to allow preprocessing of test_bug410156.js
+libs:: unit/test_bug410156.js.in
+	$(PYTHON) $(MOZILLA_DIR)/config/Preprocessor.py $(DEFINES) $(ACDEFINES) $^ > $(TESTROOT)/unit/test_bug410156.js
diff --git a/toolkit/components/commandlines/test/unit/data/test_bug410156.desktop b/toolkit/components/commandlines/test/unit/data/test_bug410156.desktop
new file mode 100644
index 0000000..1847cdd
--- /dev/null
+++ b/toolkit/components/commandlines/test/unit/data/test_bug410156.desktop
@@ -0,0 +1,7 @@
+[Desktop Entry]
+Version=1.0
+Encoding=UTF-8
+Name=test_bug410156
+Type=Link
+URL=http://www.bug410156.com/
+Icon=gnome-fs-bookmark
diff --git a/toolkit/components/commandlines/test/unit/data/test_bug410156.url b/toolkit/components/commandlines/test/unit/data/test_bug410156.url
new file mode 100644
index 0000000..6920e1f
--- /dev/null
+++ b/toolkit/components/commandlines/test/unit/data/test_bug410156.url
@@ -0,0 +1,9 @@
+[InternetShortcut]
+URL=http://www.bug410156.com/
+IDList=
+HotKey=0
+[{000214A0-0000-0000-C000-000000000046}]
+Prop3=19,2
+[InternetShortcut.A]
+[InternetShortcut.W]
+URL=http://www.bug410156.com/
diff --git a/toolkit/components/commandlines/test/unit/test_bug410156.js.in b/toolkit/components/commandlines/test/unit/test_bug410156.js.in
new file mode 100644
index 0000000..e69de29"""
eebf20daa852867ca554f63a56d4e83698a185bd,78147,413874,mats.palmgren%bredband.net,"Bustage fix for bug 413874.
",1208385123,"""diff --git a/mailnews/mime/src/nsMsgHeaderParser.cpp b/mailnews/mime/src/nsMsgHeaderParser.cpp
index 45c539c..73eb8f9 100644
--- a/mailnews/mime/src/nsMsgHeaderParser.cpp
+++ b/mailnews/mime/src/nsMsgHeaderParser.cpp
@@ -1533,7 +1533,8 @@ msg_remove_duplicate_addresses(const char *addrs, const char *other_addrs,
     }
   }
   
-  PRUint32 outlen = size3 + 1;
+  PRUint32 outlen;
+  outlen = size3 + 1;
   output = (char *)PR_Malloc(outlen);
   if (!output) goto FAIL;
 """
4c3127345fa26438e6449d74234bd226aa823bbb,78156,411433,gavin%gavinsharp.com,"Bug 411433: properly handle file location URL in directory listings, patch by Masahiro Yamada <masa141421356@gmail.com>, r=biesi, sr=bzbarsky, a=damon
",1208377403,"""diff --git a/netwerk/streamconv/converters/nsIndexedToHTML.cpp b/netwerk/streamconv/converters/nsIndexedToHTML.cpp
index 0856ddc..6109b03 100644
--- a/netwerk/streamconv/converters/nsIndexedToHTML.cpp
+++ b/netwerk/streamconv/converters/nsIndexedToHTML.cpp
@@ -571,7 +571,10 @@ nsIndexedToHTML::OnStartRequest(nsIRequest* request, nsISupports *aContext) {
         // will prematurely close the string.  Go ahead an
         // add a base href.
         buffer.AppendLiteral(""""<base href=\"""""""");
-        AppendASCIItoUTF16(baseUri, buffer);
+        NS_ConvertUTF8toUTF16 utf16BaseURI(baseUri);
+        nsString htmlEscapedUri;
+        htmlEscapedUri.Adopt(nsEscapeHTML2(utf16BaseURI.get(), utf16BaseURI.Length()));
+        buffer.Append(htmlEscapedUri);
         buffer.AppendLiteral(""""\"""">\n"""");
     }
     else
@@ -601,7 +604,11 @@ nsIndexedToHTML::OnStartRequest(nsIRequest* request, nsISupports *aContext) {
         if (NS_FAILED(rv)) return rv;
 
         buffer.AppendLiteral(""""<p id=\""""UI_goUp\""""><a class=\""""up\"""" href=\"""""""");
-        AppendASCIItoUTF16(parentStr, buffer);
+
+        NS_ConvertUTF8toUTF16 utf16ParentStr(parentStr);
+        nsString htmlParentStr;
+        htmlParentStr.Adopt(nsEscapeHTML2(utf16ParentStr.get(), utf16ParentStr.Length()));
+        buffer.Append(htmlParentStr);
         buffer.AppendLiteral(""""\"""">"""");
         AppendNonAsciiToNCR(parentText, buffer);
         buffer.AppendLiteral(""""</a></p>\n"""");
@@ -894,8 +901,10 @@ nsIndexedToHTML::OnIndexAvailable(nsIRequest *aRequest,
         escFlags = esc_Forced | esc_OnlyASCII | esc_AlwaysCopy | esc_FileBaseName | esc_Colon | esc_Directory;
     }
     NS_EscapeURL(utf8UnEscapeSpec.get(), utf8UnEscapeSpec.Length(), escFlags, escapeBuf);
-
-    AppendUTF8toUTF16(escapeBuf, pushBuffer);
+    NS_ConvertUTF8toUTF16 utf16URI(escapeBuf);
+    nsString htmlEscapedURL;
+    htmlEscapedURL.Adopt(nsEscapeHTML2(utf16URI.get(), utf16URI.Length()));
+    pushBuffer.Append(htmlEscapedURL);
 
     pushBuffer.AppendLiteral(""""\"""">"""");
 """
8e825eefdaf228e08027d2b89563cf7319fe06e4,78165,413874,gavin%gavinsharp.com,"Bug 413874: tidy up string usage in mailnews, patch by Emre Birol <ebirol@gmail.com>, r=bienvenu, sr=dveditz
",1208376381,"""diff --git a/mailnews/mime/src/comi18n.cpp b/mailnews/mime/src/comi18n.cpp
index 454c134..8923475 100644
--- a/mailnews/mime/src/comi18n.cpp
+++ b/mailnews/mime/src/comi18n.cpp
@@ -203,7 +203,7 @@ PRInt32 generate_encodedwords(char *pUTF8, const char *charset, char method, cha
   char  encodedword_head[kMAX_CSNAME+4+1];
   nsCAutoString _charset;
   char  *pUTF8Head = nsnull, cUTF8Tmp = 0;
-  PRInt32   olen = 0, offset, linelen = output_carryoverlen, convlen = 0;
+  PRInt32   olen = 0, obufsize = outlen, offset, linelen = output_carryoverlen, convlen = 0;
   PRInt32   encodedword_headlen = 0, encodedword_taillen = foldingonly ? 0 : 2; // """"?=""""
   nsresult rv;
 
@@ -324,18 +324,20 @@ PRInt32 generate_encodedwords(char *pUTF8, const char *charset, char method, cha
     }
     else {
       /* no folding needed, let's fall thru */
-      strcpy(o, encodedword_head);
+      PL_strncpyz(o, encodedword_head, obufsize);
       olen += encodedword_headlen;
       linelen += encodedword_headlen;
+      obufsize -= encodedword_headlen;
       o += encodedword_headlen;
       if (!foldingonly)
         *pUCS2 = 0;
     }
   }
   else {
-    strcpy(o, """"\r\n """");
+    PL_strncpyz(o, """"\r\n """", obufsize);
     olen += 3;
     o += 3;
+    obufsize -= 3;
     linelen = 1;
   }
 
@@ -344,9 +346,10 @@ PRInt32 generate_encodedwords(char *pUTF8, const char *charset, char method, cha
   */
 
   while ((foldingonly ? *pUTF8 : *pUCS2) && (olen < outlen)) {
-    strcpy(o, encodedword_head);
+    PL_strncpyz(o, encodedword_head, obufsize);
     olen += encodedword_headlen;
     linelen += encodedword_headlen;
+    obufsize -= encodedword_headlen;
     o += encodedword_headlen;
     olen += encodedword_taillen;
     if (foldingonly)
@@ -393,8 +396,9 @@ PRInt32 generate_encodedwords(char *pUTF8, const char *charset, char method, cha
 process_lastline:
         PRInt32 enclen;
         if (foldingonly) {
-          strcpy(o, pUTF8Head);
+          PL_strncpyz(o, pUTF8Head, obufsize);
           enclen = strlen(o);
+          obufsize -= enclen;
           o += enclen;
           *pUTF8 = cUTF8Tmp;
         }
@@ -405,12 +409,15 @@ process_lastline:
             enclen = intlmime_encode_q((const unsigned char *)ibuf, strlen(ibuf), o);
           PR_Free(ibuf);
           o += enclen;
-          strcpy(o, """"?="""");
+          obufsize -= enclen;
+          PL_strncpyz(o, """"?="""", obufsize);
         }
         o += encodedword_taillen;
+        obufsize -= encodedword_taillen;
         olen += enclen;
         if (foldingonly ? *pUTF8 : *pUCS2) { /* not last line */
-          strcpy(o, """"\r\n """");
+          PL_strncpyz(o, """"\r\n """", obufsize);
+          obufsize -= 3;
           o += 3;
           olen += 3;
           linelen = 1;
@@ -676,7 +683,7 @@ char * apply_rfc2047_encoding(const char *_src, PRBool structured, const char *c
           break;
         }
         if (list->next) {
-          strcpy(outputtail, """", """");
+          PL_strncpyz(outputtail, """", """", outputlen);
           cursor += 2;
           outputtail += 2;
           outputlen -= 2;
@@ -705,7 +712,7 @@ char * apply_rfc2047_encoding(const char *_src, PRBool structured, const char *c
       if (cursor + skiplen + overhead < foldlen) {
         char tmp = *(spacepos + 1);
         *(spacepos + 1) = '\0';
-        strcpy(output, src);
+        PL_strncpyz(output, src, outputlen);
         output += skiplen;
         outputlen -= skiplen;
         cursor += skiplen;
diff --git a/mailnews/mime/src/mimedrft.cpp b/mailnews/mime/src/mimedrft.cpp
index 7ca42b3..3e56a8f 100644
--- a/mailnews/mime/src/mimedrft.cpp
+++ b/mailnews/mime/src/mimedrft.cpp
@@ -1507,13 +1507,14 @@ mime_parse_stream_complete (nsMIMESession *stream)
                 bodyLen = strlen(body);
               }
 
-              char* newbody = (char *)PR_MALLOC (bodyLen + 12); //+11 chars for <pre> & </pre> tags
+              PRUint32 newbodylen = bodyLen + 12; //+11 chars for <pre> & </pre> tags
+              char* newbody = (char *)PR_MALLOC (newbodylen);
               if (newbody)
               {
                 *newbody = 0;
-                PL_strcat(newbody, """"<PRE>"""");
-                PL_strcat(newbody, body);
-                PL_strcat(newbody, """"</PRE>"""");
+                PL_strcatn(newbody, newbodylen, """"<PRE>"""");
+                PL_strcatn(newbody, newbodylen, body);
+                PL_strcatn(newbody, newbodylen, """"</PRE>"""");
                 PR_Free(body);
                 body = newbody;
               }
diff --git a/mailnews/mime/src/mimeeobj.cpp b/mailnews/mime/src/mimeeobj.cpp
index 988d735..2502d35 100644
--- a/mailnews/mime/src/mimeeobj.cpp
+++ b/mailnews/mime/src/mimeeobj.cpp
@@ -160,7 +160,8 @@ MimeExternalObject_parse_begin (MimeObject *obj)
     else
     {
       const char *p = """"Part """";
-      char *s = (char *)PR_MALLOC(strlen(p) + strlen(id) + 1);
+      PRUint32 slen = strlen(p) + strlen(id) + 1;
+      char *s = (char *)PR_MALLOC(slen);
       if (!s)
       {
         PR_Free(id);
@@ -170,8 +171,8 @@ MimeExternalObject_parse_begin (MimeObject *obj)
       // we have a valid id
       if (id)
         id_name = mime_find_suggested_name_of_part(id, obj);
-      PL_strcpy(s, p);
-      PL_strcat(s, id);
+      PL_strncpyz(s, p, slen);
+      PL_strcatn(s, slen, id);
       PR_Free(id);
       id = s;
     }
diff --git a/mailnews/mime/src/mimefilt.cpp b/mailnews/mime/src/mimefilt.cpp
index 324289f..c7fab02 100644
--- a/mailnews/mime/src/mimefilt.cpp
+++ b/mailnews/mime/src/mimefilt.cpp
@@ -185,14 +185,13 @@ test_image_make_image_html(void *image_data)
             """"an inlined image would have gone here for<BR>"""");
   const char *suffix = """"</TD></TR></TABLE></CENTER><P>"""";
 #endif
-  char *buf;
-  buf = (char *) PR_MALLOC (strlen (prefix) + strlen (suffix) +
-               strlen (url) + 20);
+  PRUint32 buflen = strlen (prefix) + strlen (suffix) + strlen (url) + 20;
+  char *buf = (char *) PR_MALLOC (buflen);
   if (!buf) return 0;
   *buf = 0;
-  PL_strcat (buf, prefix);
-  PL_strcat (buf, url);
-  PL_strcat (buf, suffix);
+  PL_strcatn (buf, buflen, prefix);
+  PL_strcatn (buf, buflen, url);
+  PL_strcatn (buf, buflen, suffix);
   return buf;
 }
 
diff --git a/mailnews/mime/src/mimei.cpp b/mailnews/mime/src/mimei.cpp
index 136ec49..3c8a17a 100644
--- a/mailnews/mime/src/mimei.cpp
+++ b/mailnews/mime/src/mimei.cpp
@@ -1087,15 +1087,16 @@ mime_part_address(MimeObject *obj)
     return strdup(buf);
     else
     {
-      char *s = (char *)PR_MALLOC(strlen(higher) + strlen(buf) + 3);
+      PRUint32 slen = strlen(higher) + strlen(buf) + 3;
+      char *s = (char *)PR_MALLOC(slen);
       if (!s)
       {
         PR_Free(higher);
         return 0;  /* MIME_OUT_OF_MEMORY */
       }
-      PL_strcpy(s, higher);
-      PL_strcat(s, """"."""");
-      PL_strcat(s, buf);
+      PL_strncpyz(s, higher, slen);
+      PL_strcatn(s, slen, """"."""");
+      PL_strcatn(s, slen, buf);
       PR_Free(higher);
       return s;
     }
@@ -1229,7 +1230,8 @@ mime_set_url_part(const char *url, const char *part, PRBool append_p)
           }
   }
 
-  result = (char *) PR_MALLOC(strlen(url) + strlen(part) + 10);
+  PRUint32 resultlen = strlen(url) + strlen(part) + 10;
+  result = (char *) PR_MALLOC(resultlen);
   if (!result) return 0;
 
   if (part_begin)
@@ -1248,17 +1250,17 @@ mime_set_url_part(const char *url, const char *part, PRBool append_p)
   }
   else
   {
-    PL_strcpy(result, url);
+    PL_strncpyz(result, url, resultlen);
     if (got_q)
-    PL_strcat(result, """"&part="""");
+    PL_strcatn(result, resultlen, """"&part="""");
     else
-    PL_strcat(result, """"?part="""");
+    PL_strcatn(result, resultlen, """"?part="""");
   }
 
-  PL_strcat(result, part);
+  PL_strcatn(result, resultlen, part);
 
   if (part_end && *part_end)
-  PL_strcat(result, part_end);
+  PL_strcatn(result, resultlen, part_end);
 
   /* Semi-broken kludge to omit a trailing """"?part=0"""". */
   {
@@ -1287,15 +1289,15 @@ mime_set_url_imap_part(const char *url, const char *imappart, const char *libmim
     *whereCurrent = 0;
   }
 
-  result = (char *) PR_MALLOC(strlen(url) + strlen(imappart) + strlen(libmimepart) + 17);
+  PRUint32 resultLen = strlen(url) + strlen(imappart) + strlen(libmimepart) + 17;
+  result = (char *) PR_MALLOC(resultLen);
   if (!result) return 0;
 
-  PL_strcpy(result, url);
-  PL_strcat(result, """"/;section="""");
-  PL_strcat(result, imappart);
-  PL_strcat(result, """"?part="""");
-  PL_strcat(result, libmimepart);
-  result[strlen(result)] = 0;
+  PL_strncpyz(result, url, resultLen);
+  PL_strcatn(result, resultLen, """"/;section="""");
+  PL_strcatn(result, resultLen, imappart);
+  PL_strcatn(result, resultLen, """"?part="""");
+  PL_strcatn(result, resultLen, libmimepart);
 
   if (whereCurrent)
     *whereCurrent = '/';
@@ -1605,11 +1607,11 @@ mime_parse_url_options(const char *url, MimeDisplayOptions *options)
    else if (strcmp(options->part_to_load, """"1""""))  /* not 1 */
    {
      const char *prefix = """"1."""";
-     char *s = (char *) PR_MALLOC(strlen(options->part_to_load) +
-       strlen(prefix) + 1);
+     PRUint32 slen = strlen(options->part_to_load) + strlen(prefix) + 1;
+     char *s = (char *) PR_MALLOC(slen);
      if (!s) return MIME_OUT_OF_MEMORY;
-     PL_strcpy(s, prefix);
-     PL_strcat(s, options->part_to_load);
+     PL_strncpyz(s, prefix, slen);
+     PL_strcatn(s, slen, options->part_to_load);
      PR_Free(options->part_to_load);
      options->part_to_load = s;
    }
diff --git a/mailnews/mime/src/mimemoz2.cpp b/mailnews/mime/src/mimemoz2.cpp
index 513e3af..fb56e8b 100644
--- a/mailnews/mime/src/mimemoz2.cpp
+++ b/mailnews/mime/src/mimemoz2.cpp
@@ -1209,15 +1209,15 @@ mime_image_make_image_html(void *image_closure)
   else
     url = mid->url;
 
-  buf = (char *) PR_MALLOC (strlen(prefix) + strlen(suffix) +
-                            strlen(url) + 20) ;
+  PRUint32 buflen = strlen(prefix) + strlen(suffix) + strlen(url) + 20;
+  buf = (char *) PR_MALLOC (buflen);
   if (!buf)
     return 0;
   *buf = 0;
 
-  PL_strcat (buf, prefix);
-  PL_strcat (buf, url);
-  PL_strcat (buf, suffix);
+  PL_strcatn (buf, buflen, prefix);
+  PL_strcatn (buf, buflen, url);
+  PL_strcatn (buf, buflen, suffix);
   return buf;
 }
 
diff --git a/mailnews/mime/src/mimemsg.cpp b/mailnews/mime/src/mimemsg.cpp
index 729b734..859b56f 100644
--- a/mailnews/mime/src/mimemsg.cpp
+++ b/mailnews/mime/src/mimemsg.cpp
@@ -244,7 +244,7 @@ MimeMessage_parse_line (const char *aLine, PRInt32 aLength, MimeObject *obj)
       char *s = (char *)PR_MALLOC(length + MSG_LINEBREAK_LEN + 1);
       if (!s) return MIME_OUT_OF_MEMORY;
       memcpy(s, line, length);
-      PL_strcpy(s + length, MSG_LINEBREAK);
+      PL_strncpyz(s + length, MSG_LINEBREAK, MSG_LINEBREAK_LEN);
       status = kid->clazz->parse_buffer (s, length + MSG_LINEBREAK_LEN, kid);
       PR_Free(s);
       return status;
diff --git a/mailnews/mime/src/mimethtm.cpp b/mailnews/mime/src/mimethtm.cpp
index 1cbd307..992dc30 100644
--- a/mailnews/mime/src/mimethtm.cpp
+++ b/mailnews/mime/src/mimethtm.cpp
@@ -116,7 +116,8 @@ MimeInlineTextHTML_parse_begin (MimeObject *obj)
 
     if (base_hdr)
     {
-      char *buf = (char *) PR_MALLOC(strlen(base_hdr) + 20);
+      PRUint32 buflen = strlen(base_hdr) + 20;
+      char *buf = (char *) PR_MALLOC(buflen);
       const char *in;
       char *out;
       if (!buf)
@@ -129,7 +130,7 @@ MimeInlineTextHTML_parse_begin (MimeObject *obj)
         mail header to be wrapped reasonably.  Creators are supposed
         to insert whitespace every 40 characters or less.
       */
-      PL_strcpy(buf, """"<BASE HREF=\"""""""");
+      PL_strncpyz(buf, """"<BASE HREF=\"""""""", buflen);
       out = buf + strlen(buf);
 
       for (in = base_hdr; *in; in++)
diff --git a/mailnews/mime/src/mimetric.cpp b/mailnews/mime/src/mimetric.cpp
index 50bd077..a975db9 100644
--- a/mailnews/mime/src/mimetric.cpp
+++ b/mailnews/mime/src/mimetric.cpp
@@ -120,11 +120,12 @@ MimeRichtextConvert (const char *line, PRInt32 length,
     if (!IS_SPACE (*this_start)) break;
     if (this_start >= line + length) /* blank line */
     {
-      PL_strcpy (*obufferP, """"<BR>"""");
+      PL_strncpyz (*obufferP, """"<BR>"""", *obuffer_sizeP);
       return output_fn (*obufferP, strlen(*obufferP), closure);
     }
   }
 
+  PRUint32 outlen = (PRUint32) *obuffer_sizeP;
   out = *obufferP;
   *out = 0;
 
@@ -132,6 +133,7 @@ MimeRichtextConvert (const char *line, PRInt32 length,
   last_end = line;
   this_start = last_end;
   this_end = this_start;
+  PRUint32 addedlen = 0;
   while (this_end < data_end)
   {
     /* Skip forward to next special character. */
@@ -161,24 +163,34 @@ MimeRichtextConvert (const char *line, PRInt32 length,
       memcpy (out, last_end, this_start - last_end);
       out += this_start - last_end;
       *out = 0;
+      outlen -= (this_start - last_end);
     }
 
     if (this_start >= data_end)
     break;
     else if (*this_start == '&')
     {
-      PL_strcpy (out, """"&amp;""""); out += strlen (out);
+      PL_strncpyz (out, """"&amp;"""", outlen); 
+      addedlen = strlen(out);
+      outlen -= addedlen; 
+      out += addedlen;
     }
     else if (*this_start == '>')
     {
-      PL_strcpy (out, """"&gt;""""); out += strlen (out);
+      PL_strncpyz (out, """"&gt;"""", outlen); 
+      addedlen = strlen(out); 
+      outlen -= addedlen; 
+      out += addedlen;
     }
     else if (enriched_p &&
          this_start < data_end + 1 &&
          this_start[0] == '<' &&
          this_start[1] == '<')
     {
-      PL_strcpy (out, """"&lt;""""); out += strlen (out);
+      PL_strncpyz (out, """"&lt;"""", outlen); 
+      addedlen = strlen(out); 
+      outlen -= addedlen; 
+      out += addedlen;
     }
     else if (this_start != this_end)
     {
@@ -312,13 +324,17 @@ MimeRichtextConvert (const char *line, PRInt32 length,
 
       if (this_start[1] == '/')
       {
-        if (tag_close) PL_strcpy (out, tag_close);
-        out += strlen (out);
+        if (tag_close) PL_strncpyz (out, tag_close, outlen);
+        addedlen = strlen (out);
+        outlen -= addedlen;
+        out += addedlen;
       }
       else
       {
-        if (tag_open) PL_strcpy (out, tag_open);
-        out += strlen (out);
+        if (tag_open) PL_strncpyz (out, tag_open, outlen);
+        addedlen = strlen (out);
+        outlen -= addedlen;
+        out += addedlen;
       }
     }
 
diff --git a/mailnews/mime/src/mimeunty.cpp b/mailnews/mime/src/mimeunty.cpp
index a7f04d5..09c19e8 100644
--- a/mailnews/mime/src/mimeunty.cpp
+++ b/mailnews/mime/src/mimeunty.cpp
@@ -319,47 +319,48 @@ MimeUntypedText_open_subpart (MimeObject *obj,
   uty->open_hdrs = MimeHeaders_new();
   if (!uty->open_hdrs) return MIME_OUT_OF_MEMORY;
 
-  h = (char *) PR_MALLOC(strlen(type) +
-            (enc ? strlen(enc) : 0) +
-            (desc ? strlen(desc) : 0) +
-            (name ? strlen(name) : 0) +
-            100);
+  PRUint32 hlen = strlen(type) +
+                (enc ? strlen(enc) : 0) +
+                (desc ? strlen(desc) : 0) +
+                (name ? strlen(name) : 0) +
+                100;
+  h = (char *) PR_MALLOC(hlen);
   if (!h) return MIME_OUT_OF_MEMORY;
 
-  PL_strcpy(h, HEADER_CONTENT_TYPE """": """");
-  PL_strcat(h, type);
-  PL_strcat(h, MSG_LINEBREAK);
+  PL_strncpyz(h, HEADER_CONTENT_TYPE """": """", hlen);
+  PL_strcatn(h, hlen, type);
+  PL_strcatn(h, hlen, MSG_LINEBREAK);
   status = MimeHeaders_parse_line(h, strlen(h), uty->open_hdrs);
   if (status < 0) goto FAIL;
 
   if (enc)
   {
-    PL_strcpy(h, HEADER_CONTENT_TRANSFER_ENCODING """": """");
-    PL_strcat(h, enc);
-    PL_strcat(h, MSG_LINEBREAK);
+    PL_strncpyz(h, HEADER_CONTENT_TRANSFER_ENCODING """": """", hlen);
+    PL_strcatn(h, hlen, enc);
+    PL_strcatn(h, hlen, MSG_LINEBREAK);
     status = MimeHeaders_parse_line(h, strlen(h), uty->open_hdrs);
     if (status < 0) goto FAIL;
   }
 
   if (desc)
   {
-    PL_strcpy(h, HEADER_CONTENT_DESCRIPTION """": """");
-    PL_strcat(h, desc);
-    PL_strcat(h, MSG_LINEBREAK);
+    PL_strncpyz(h, HEADER_CONTENT_DESCRIPTION """": """", hlen);
+    PL_strcatn(h, hlen, desc);
+    PL_strcatn(h, hlen, MSG_LINEBREAK);
     status = MimeHeaders_parse_line(h, strlen(h), uty->open_hdrs);
     if (status < 0) goto FAIL;
   }
   if (name)
   {
-    PL_strcpy(h, HEADER_CONTENT_DISPOSITION """": inline; filename=\"""""""");
-    PL_strcat(h, name);
-    PL_strcat(h, """"\"""""""" MSG_LINEBREAK);
+    PL_strncpyz(h, HEADER_CONTENT_DISPOSITION """": inline; filename=\"""""""", hlen);
+    PL_strcatn(h, hlen, name);
+    PL_strcatn(h, hlen, """"\"""""""" MSG_LINEBREAK);
     status = MimeHeaders_parse_line(h, strlen(h), uty->open_hdrs);
     if (status < 0) goto FAIL;
   }
 
   /* push out a blank line. */
-  PL_strcpy(h, MSG_LINEBREAK);
+  PL_strncpyz(h, MSG_LINEBREAK, hlen);
   status = MimeHeaders_parse_line(h, strlen(h), uty->open_hdrs);
   if (status < 0) goto FAIL;
 
diff --git a/mailnews/mime/src/nsMsgHeaderParser.cpp b/mailnews/mime/src/nsMsgHeaderParser.cpp
index 37aabc5..45c539c 100644
--- a/mailnews/mime/src/nsMsgHeaderParser.cpp
+++ b/mailnews/mime/src/nsMsgHeaderParser.cpp
@@ -1422,6 +1422,7 @@ msg_remove_duplicate_addresses(const char *addrs, const char *other_addrs,
   char **a_array1 = 0, **a_array2 = 0, **a_array3 = 0;
   char **n_array1 = 0,                 **n_array3 = 0;
   int i, j;
+  PRUint32 addedlen = 0;
 
   count1 = msg_parse_Header_addresses(addrs, &names1, &addrs1);
   if (count1 < 0) goto FAIL;
@@ -1531,8 +1532,9 @@ msg_remove_duplicate_addresses(const char *addrs, const char *other_addrs,
       if (count3 > count1) break;
     }
   }
-
-  output = (char *)PR_Malloc(size3 + 1);
+  
+  PRUint32 outlen = size3 + 1;
+  output = (char *)PR_Malloc(outlen);
   if (!output) goto FAIL;
 
   *output = 0;
@@ -1540,15 +1542,19 @@ msg_remove_duplicate_addresses(const char *addrs, const char *other_addrs,
   s2 = output;
   for (i = 0; i < count3; i++)
   {
-    PL_strcpy(out, a_array3[i]);
-    out += strlen(out);
+    PL_strncpyz(out, a_array3[i], outlen);
+    addedlen = strlen(out);
+    outlen -= addedlen;
+    out += addedlen;
     *out++ = 0;
   }
   s1 = out;
   for (i = 0; i < count3; i++)
   {
-    PL_strcpy(out, n_array3[i]);
-    out += strlen(out);
+    PL_strncpyz(out, n_array3[i], outlen);
+    addedlen = strlen(out);
+    outlen -= addedlen;
+    out += addedlen;
     *out++ = 0;
   }
   result = msg_format_Header_addresses(s1, s2, count3, PR_FALSE);
@@ -1580,26 +1586,34 @@ msg_make_full_address(const char* name, const char* addr)
   int nl = name ? strlen (name) : 0;
   int al = addr ? strlen (addr) : 0;
   char *buf, *s;
+  PRUint32 buflen, slen;
   int L;
   if (al == 0)
     return 0;
-  buf = (char *)PR_Malloc((nl * 2) + (al * 2) + 20);
+
+  buflen = (nl * 2) + (al * 2) + 25;
+  buf = (char *)PR_Malloc(buflen);
   if (!buf)
     return 0;
   if (nl > 0)
   {
-    PL_strcpy(buf, name);
+    PL_strncpyz(buf, name, buflen);
     L = msg_quote_phrase_or_addr(buf, nl, PR_FALSE);
     s = buf + L;
-    *s++ = ' ';
-    *s++ = '<';
+    slen = buflen - L;
+    if ( slen > 2 ) {
+        *s++ = ' ';
+        *s++ = '<';
+        slen -= 2; // for ' ' and '<'
+    }
   }
   else
   {
     s = buf;
+    slen = buflen;
   }
 
-  PL_strcpy(s, addr);
+  PL_strncpyz(s, addr, slen);
   L = msg_quote_phrase_or_addr(s, al, PR_TRUE);
   s += L;
   if (nl > 0)"""
c55d4fcc777dcd49416bf8ab8c6a2345924bbb2b,78208,425152,timeless%mozdev.org,"Bug 425152 Fix string length overflow in nsNNTPProtocol::DoCancel
patch by Pidgeot18@gmail.com r=bienvenu sr=bienvenu
",1208301534,"""diff --git a/mailnews/news/src/nsNNTPProtocol.cpp b/mailnews/news/src/nsNNTPProtocol.cpp
index a6f5c14..485ba18 100644
--- a/mailnews/news/src/nsNNTPProtocol.cpp
+++ b/mailnews/news/src/nsNNTPProtocol.cpp
@@ -4205,7 +4205,6 @@ PRInt32 nsNNTPProtocol::DoCancel()
     char *subject = nsnull;
     char *newsgroups = nsnull;
     char *distribution = nsnull;
-    char *other_random_headers = nsnull;
     char *body = nsnull;
     cancelInfoEntry cancelInfo;
     PRBool requireConfirmationForCancel = PR_TRUE;
@@ -4255,13 +4254,15 @@ PRInt32 nsNNTPProtocol::DoCancel()
   L = PL_strlen (id);
 
   subject = (char *) PR_Malloc (L + 20);
-  other_random_headers = (char *) PR_Malloc (L + 20);
   body = (char *) PR_Malloc (PL_strlen (XP_AppCodeName) + 100);
 
   nsString alertText;
   nsString confirmText;
   PRInt32 confirmCancelResult = 0;
 
+  // A little early to declare, but the goto causes problems
+  nsCAutoString otherHeaders;
+
   /* Make sure that this loser isn't cancelling someone else's posting.
      Yes, there are occasionally good reasons to do so.  Those people
      capable of making that decision (news admins) have other tools with
@@ -4326,7 +4327,7 @@ reported here */
       goto FAIL;
   }
 
-  if (!subject || !other_random_headers || !body)
+  if (!subject || !body)
   {
     status = MK_OUT_OF_MEMORY;
     failure = PR_TRUE;
@@ -4336,13 +4337,13 @@ reported here */
   PL_strcpy (subject, """"cancel """");
   PL_strcat (subject, id);
 
-  PL_strcpy (other_random_headers, """"Control: cancel """");
-  PL_strcat (other_random_headers, id);
-  PL_strcat (other_random_headers, CRLF);
+  otherHeaders.AppendLiteral(""""Control: cancel """");
+  otherHeaders += id;
+  otherHeaders.AppendLiteral(CRLF);
   if (distribution) {
-    PL_strcat (other_random_headers, """"Distribution: """");
-    PL_strcat (other_random_headers, distribution);
-    PL_strcat (other_random_headers, CRLF);
+    otherHeaders.AppendLiteral(""""Distribution: """");
+    otherHeaders += distribution;
+    otherHeaders.AppendLiteral(CRLF);
   }
 
   PL_strcpy (body, """"This message was cancelled from within """");
@@ -4360,12 +4361,12 @@ reported here */
                        """"Newsgroups: %s"""" CRLF
                        """"Subject: %s"""" CRLF
                        """"References: %s"""" CRLF
-                       """"%s"""" /* other_random_headers, already with CRLF */
+                       """"%s"""" /* otherHeaders, already with CRLF */
                        CRLF /* body separator */
                        """"%s"""" /* body, already with CRLF */
                        """"."""" CRLF, /* trailing message terminator """"."""" */
                        cancelInfo.from.get(), newsgroups, subject, id,
-                       other_random_headers, body);
+                       otherHeaders.get(), body);
 
     nsCOMPtr<nsIMsgMailNewsUrl> mailnewsurl = do_QueryInterface(m_runningURL);
     if (mailnewsurl)
@@ -4410,7 +4411,6 @@ FAIL:
   PR_Free (subject);
   PR_Free (newsgroups);
   PR_Free (distribution);
-  PR_Free (other_random_headers);
   PR_Free (body);
 
   return status;"""
fcd1eb2a334e414495fa8461e74feaf517d4aa86,79994,418356,jst%mozilla.org,"Followup fix for bug 418356. Re-enable loading file:// URIs using the subscript loader. r+sr=bzbarsky@mit.edu
",1206076045,"""diff --git a/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp b/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp
index 78540d3..632fe32 100644
--- a/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp
+++ b/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp
@@ -54,14 +54,17 @@
 #include """"nsDependentString.h""""
 #include """"nsAutoPtr.h""""
 #include """"nsNetUtil.h""""
+#include """"nsIProtocolHandler.h""""
+#include """"nsIFileURL.h""""
 
 #include """"jsapi.h""""
+#include """"jsdbgapi.h""""
 
 /* load() error msgs, XXX localize? */
 #define LOAD_ERROR_NOSERVICE """"Error creating IO Service.""""
 #define LOAD_ERROR_NOURI """"Error creating URI (invalid URL scheme?)""""
 #define LOAD_ERROR_NOSCHEME """"Failed to get URI scheme.  This is bad.""""
-#define LOAD_ERROR_URI_NOT_CHROME """"Trying to load a non-chrome URI.""""
+#define LOAD_ERROR_URI_NOT_LOCAL """"Trying to load a non-local URI.""""
 #define LOAD_ERROR_NOSTREAM  """"Error opening input stream (invalid filename?)""""
 #define LOAD_ERROR_NOCONTENT """"ContentLength not available (not a local URL?)""""
 #define LOAD_ERROR_BADREAD   """"File Read Error.""""
@@ -139,11 +142,10 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
         rv = secman->GetSystemPrincipal(getter_AddRefs(mSystemPrincipal));
         if (NS_FAILED(rv) || !mSystemPrincipal)
             return rv;
-
     }
 
     JSAutoRequest ar(cx);
-    
+
     char     *url;
     JSObject *target_obj = nsnull;
     ok = JS_ConvertArguments (cx, argc, argv, """"s / o"""", &url, &target_obj);
@@ -153,7 +155,7 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
         /* let the exception raised by JS_ConvertArguments show through */
         return NS_OK;
     }
-    
+
     if (!target_obj)
     {
         /* if the user didn't provide an object to eval onto, find the global
@@ -225,6 +227,25 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
     nsCAutoString uriStr;
     nsCAutoString scheme;
 
+    JSStackFrame* frame = nsnull;
+    JSScript* script = nsnull;
+
+    // Figure out who's calling us
+    do
+    {
+        frame = JS_FrameIterator(cx, &frame);
+
+        if (frame)
+            script = JS_GetFrameScript(cx, frame);
+    } while (frame && !script);
+
+    if (!script)
+    {
+        // No script means we don't know who's calling, bail.
+
+        return NS_ERROR_FAILURE;
+    }
+
     nsCOMPtr<nsIIOService> serv = do_GetService(NS_IOSERVICE_CONTRACTID);
     if (!serv)
     {
@@ -240,14 +261,36 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
         goto return_exception;
     }
 
-    rv = uri->GetScheme(scheme);
+    rv = uri->GetSpec(uriStr);
     if (NS_FAILED(rv)) {
+        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOSPEC);
+        goto return_exception;
+    }    
+
+    rv = uri->GetScheme(scheme);
+    if (NS_FAILED(rv))
+    {
         errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOSCHEME);
         goto return_exception;
     }
-    if (!scheme.EqualsLiteral(""""chrome"""")) {
-        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_URI_NOT_CHROME);
-        goto return_exception;
+
+    if (!scheme.EqualsLiteral(""""chrome""""))
+    {
+        // This might be a URI to a local file, though!
+        nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(uri);
+        if (!fileURL)
+        {
+            errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_URI_NOT_LOCAL);
+            goto return_exception;
+        }
+
+        // For file URIs prepend the filename with the filename of the
+        // calling script, and """" -> """". See bug 418356.
+        nsCAutoString tmp(JS_GetScriptFilename(cx, script));
+        tmp.AppendLiteral("""" -> """");
+        tmp.Append(uriStr);
+
+        uriStr = tmp;
     }        
         
     rv = NS_OpenURI(getter_AddRefs(instream), uri, serv,
@@ -296,12 +339,6 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
         goto return_exception;
     }
 
-    rv = uri->GetSpec(uriStr);
-    if (NS_FAILED(rv)) {
-        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOSPEC);
-        goto return_exception;
-    }    
-
     /* set our own error reporter so we can report any bad things as catchable
      * exceptions, including the source/line number */
     er = JS_SetErrorReporter (cx, mozJSLoaderErrorReporter);"""
6e435a985aa34d0a193e5f7ffadbd8db9d2dc3b8,80253,418356,bzbarsky%mit.edu,"Set the right url in the script and don't allow loading non-chrome scripts.
Bug 418356, r+sr=jst
",1205812013,"""diff --git a/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp b/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp
index 2c771e4..78540d3 100644
--- a/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp
+++ b/js/src/xpconnect/loader/mozJSSubScriptLoader.cpp
@@ -52,16 +52,22 @@
 #include """"nsIInputStream.h""""
 #include """"nsNetCID.h""""
 #include """"nsDependentString.h""""
+#include """"nsAutoPtr.h""""
+#include """"nsNetUtil.h""""
 
 #include """"jsapi.h""""
 
 /* load() error msgs, XXX localize? */
 #define LOAD_ERROR_NOSERVICE """"Error creating IO Service.""""
-#define LOAD_ERROR_NOCHANNEL """"Error creating channel (invalid URL scheme?)""""
+#define LOAD_ERROR_NOURI """"Error creating URI (invalid URL scheme?)""""
+#define LOAD_ERROR_NOSCHEME """"Failed to get URI scheme.  This is bad.""""
+#define LOAD_ERROR_URI_NOT_CHROME """"Trying to load a non-chrome URI.""""
 #define LOAD_ERROR_NOSTREAM  """"Error opening input stream (invalid filename?)""""
 #define LOAD_ERROR_NOCONTENT """"ContentLength not available (not a local URL?)""""
 #define LOAD_ERROR_BADREAD   """"File Read Error.""""
 #define LOAD_ERROR_READUNDERFLOW """"File Read Error (underflow.)""""
+#define LOAD_ERROR_NOPRINCIPALS """"Failed to get principals.""""
+#define LOAD_ERROR_NOSPEC """"Failed to get URI spec.  This is bad.""""
 
 // We just use the same reporter as the component loader
 extern void JS_DLL_CALLBACK
@@ -207,7 +213,7 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
     PRInt32   len = -1;
     PRUint32  readcount = 0;  // Total amount of data read
     PRUint32  lastReadCount = 0;  // Amount of data read in last Read() call
-    char     *buf = nsnull;
+    nsAutoArrayPtr<char> buf;
     
     JSString        *errmsg;
     JSErrorReporter  er;
@@ -215,6 +221,9 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
     
     nsCOMPtr<nsIChannel>     chan;
     nsCOMPtr<nsIInputStream> instream;
+    nsCOMPtr<nsIURI> uri;
+    nsCAutoString uriStr;
+    nsCAutoString scheme;
 
     nsCOMPtr<nsIIOService> serv = do_GetService(NS_IOSERVICE_CONTRACTID);
     if (!serv)
@@ -223,15 +232,27 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
         goto return_exception;
     }
 
-    rv = serv->NewChannel(nsDependentCString(url), nsnull, static_cast<nsIURI *>(nsnull),
-                          getter_AddRefs(chan));
-    if (NS_FAILED(rv))
-    {
-        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOCHANNEL);
+    // Make sure to explicitly create the URI, since we'll need the
+    // canonicalized spec.
+    rv = NS_NewURI(getter_AddRefs(uri), url, nsnull, serv);
+    if (NS_FAILED(rv)) {
+        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOURI);
         goto return_exception;
     }
 
-    rv = chan->Open (getter_AddRefs(instream));
+    rv = uri->GetScheme(scheme);
+    if (NS_FAILED(rv)) {
+        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOSCHEME);
+        goto return_exception;
+    }
+    if (!scheme.EqualsLiteral(""""chrome"""")) {
+        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_URI_NOT_CHROME);
+        goto return_exception;
+    }        
+        
+    rv = NS_OpenURI(getter_AddRefs(instream), uri, serv,
+                    nsnull, nsnull, nsIRequest::LOAD_NORMAL,
+                    getter_AddRefs(chan));
     if (NS_FAILED(rv))
     {
         errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOSTREAM);
@@ -271,34 +292,35 @@ mozJSSubScriptLoader::LoadSubScript (const PRUnichar * /*url*/
      * destructor */
     rv = mSystemPrincipal->GetJSPrincipals(cx, &jsPrincipals);
     if (NS_FAILED(rv) || !jsPrincipals) {
-        delete[] buf;
-        return rv;
+        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOPRINCIPALS);
+        goto return_exception;
     }
 
+    rv = uri->GetSpec(uriStr);
+    if (NS_FAILED(rv)) {
+        errmsg = JS_NewStringCopyZ (cx, LOAD_ERROR_NOSPEC);
+        goto return_exception;
+    }    
+
     /* set our own error reporter so we can report any bad things as catchable
      * exceptions, including the source/line number */
     er = JS_SetErrorReporter (cx, mozJSLoaderErrorReporter);
 
     ok = JS_EvaluateScriptForPrincipals (cx, target_obj, jsPrincipals,
-                                         buf, len, url, 1, rval);        
+                                         buf, len, uriStr.get(), 1, rval);        
     /* repent for our evil deeds */
     JS_SetErrorReporter (cx, er);
 
     cc->SetExceptionWasThrown (!ok);
     cc->SetReturnValueWasSet (ok);
 
-    delete[] buf;
     JSPRINCIPALS_DROP(cx, jsPrincipals);
     return NS_OK;
 
  return_exception:
-    if (buf)
-        delete[] buf;
-
     JS_SetPendingException (cx, STRING_TO_JSVAL(errmsg));
     cc->SetExceptionWasThrown (JS_TRUE);
     return NS_OK;
-
 }
 
 #endif /* NO_SUBSCRIPT_LOADER */"""
349b32626349c68b267854a9fe4542bc75b45483,80496,419846,jst%mozilla.org,"Fixing bug 419846. Only let chrome documents load scripts from the fastload files. r=enndeakin@gmail.com, sr=bzbarsky@mit.edu
",1205448585,"""diff --git a/content/xul/document/src/nsXULDocument.cpp b/content/xul/document/src/nsXULDocument.cpp
index 5f4f764..f526c5e 100644
--- a/content/xul/document/src/nsXULDocument.cpp
+++ b/content/xul/document/src/nsXULDocument.cpp
@@ -3200,7 +3200,9 @@ nsXULDocument::LoadScript(nsXULPrototypeScript* aScriptProto, PRBool* aBlock)
     // Load a transcluded script
     nsresult rv;
 
-    if (aScriptProto->mScriptObject.mObject) {
+    PRBool isChromeDoc = IsChromeURI(mDocumentURI);
+
+    if (isChromeDoc && aScriptProto->mScriptObject.mObject) {
         rv = ExecuteScript(aScriptProto);
 
         // Ignore return value from execution, and don't block
@@ -3213,7 +3215,7 @@ nsXULDocument::LoadScript(nsXULPrototypeScript* aScriptProto, PRBool* aBlock)
     // XXXbe the cache relies on aScriptProto's GC root!
     PRBool useXULCache = nsXULPrototypeCache::GetInstance()->IsEnabled();
 
-    if (useXULCache) {
+    if (isChromeDoc && useXULCache) {
         PRUint32 fetchedLang = nsIProgrammingLanguage::UNKNOWN;
         void *newScriptObject =
             nsXULPrototypeCache::GetInstance()->GetScript("""
6758f9b013a65262e8a0f7534b87b9bb12a3ed20,80970,419848,mrbkap%gmail.com,"Don't assume that chrome:// implies system principals. bug 419848, r=brendan sr=jst
",1204843978,"""diff --git a/dom/src/base/nsJSTimeoutHandler.cpp b/dom/src/base/nsJSTimeoutHandler.cpp
index ffa2579..03fe368 100644
--- a/dom/src/base/nsJSTimeoutHandler.cpp
+++ b/dom/src/base/nsJSTimeoutHandler.cpp
@@ -254,17 +254,12 @@ nsJSScriptTimeoutHandler::Init(nsGlobalWindow *aWindow, PRBool *aIsInterval,
     mExpr = expr;
 
     nsIPrincipal *prin = aWindow->GetPrincipal();
-    JSPrincipals *jsprins;
-    rv = prin->GetJSPrincipals(cx, &jsprins);
-    NS_ENSURE_SUCCESS(rv, rv);
 
     // Get the calling location.
     const char *filename;
-    if (nsJSUtils::GetCallingLocation(cx, &filename, &mLineNo, jsprins)) {
+    if (nsJSUtils::GetCallingLocation(cx, &filename, &mLineNo, prin)) {
       mFileName.Assign(filename);
     }
-
-    JSPRINCIPALS_DROP(cx, jsprins);
   } else if (funobj) {
     rv = NS_HOLD_JS_OBJECTS(this, nsJSScriptTimeoutHandler);
     NS_ENSURE_SUCCESS(rv, rv);
diff --git a/dom/src/base/nsJSUtils.cpp b/dom/src/base/nsJSUtils.cpp
index 7da71a8..068cf4c 100644
--- a/dom/src/base/nsJSUtils.cpp
+++ b/dom/src/base/nsJSUtils.cpp
@@ -62,7 +62,7 @@
 
 JSBool
 nsJSUtils::GetCallingLocation(JSContext* aContext, const char* *aFilename,
-                              PRUint32* aLineno, JSPrincipals* aPrincipals)
+                              PRUint32* aLineno, nsIPrincipal* aPrincipal)
 {
   // Get the current filename and line number
   JSStackFrame* frame = nsnull;
@@ -78,32 +78,24 @@ nsJSUtils::GetCallingLocation(JSContext* aContext, const char* *aFilename,
   if (script) {
     // If aPrincipals is non-null then our caller is asking us to ensure
     // that the filename we return does not have elevated privileges.
-    if (aPrincipals) {
-      // The principals might not be in the script, but we can always
-      // find the right principals in the frame's callee.
-      JSPrincipals* scriptPrins = JS_GetScriptPrincipals(aContext, script);
-      if (!scriptPrins) {
-        JSObject *callee = JS_GetFrameCalleeObject(aContext, frame);
-        nsCOMPtr<nsIPrincipal> prin;
+    if (aPrincipal) {
+      uint32 flags = JS_GetScriptFilenameFlags(script);
+
+      // Use the principal for the filename if it shouldn't be receiving
+      // implicit XPCNativeWrappers.
+      PRBool system;
+      if (flags & JSFILENAME_PROTECTED) {
         nsIScriptSecurityManager *ssm = nsContentUtils::GetSecurityManager();
-        if (NS_FAILED(ssm->GetObjectPrincipal(aContext, callee,
-                                              getter_AddRefs(prin))) ||
-            !prin) {
-          return JS_FALSE;
-        }
 
-        prin->GetJSPrincipals(aContext, &scriptPrins);
+        if (NS_FAILED(ssm->IsSystemPrincipal(aPrincipal, &system)) || !system) {
+          JSPrincipals* jsprins;
+          aPrincipal->GetJSPrincipals(aContext, &jsprins);
 
-        // The script has a reference to the principals.
-        JSPRINCIPALS_DROP(aContext, scriptPrins);
-      }
-
-      // Return the weaker of the two principals if they differ.
-      if (scriptPrins != aPrincipals &&
-          scriptPrins->subsume(scriptPrins, aPrincipals)) {
-        *aFilename = aPrincipals->codebase;
-        *aLineno = 0;
-        return JS_TRUE;
+          *aFilename = jsprins->codebase;
+          *aLineno = 0;
+          JSPRINCIPALS_DROP(aContext, jsprins);
+          return JS_TRUE;
+        }
       }
     }
 
diff --git a/dom/src/base/nsJSUtils.h b/dom/src/base/nsJSUtils.h
index faacd0e..9c3d990 100644
--- a/dom/src/base/nsJSUtils.h
+++ b/dom/src/base/nsJSUtils.h
@@ -52,12 +52,13 @@
 class nsIDOMEventListener;
 class nsIScriptContext;
 class nsIScriptGlobalObject;
+class nsIPrincipal;
 
 class nsJSUtils
 {
 public:
   static JSBool GetCallingLocation(JSContext* aContext, const char* *aFilename,
-                                   PRUint32* aLineno, JSPrincipals* aPrincipals);
+                                   PRUint32* aLineno, nsIPrincipal* aPrincipal);
 
   static jsval ConvertStringToJSVal(const nsString& aProp,
                                     JSContext* aContext);
diff --git a/js/src/jsfun.c b/js/src/jsfun.c
index a584e62..072aba0 100644
--- a/js/src/jsfun.c
+++ b/js/src/jsfun.c
@@ -1758,13 +1758,7 @@ Function(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
     caller = JS_GetScriptedCaller(cx, fp);
     if (caller) {
         principals = JS_EvalFramePrincipals(cx, fp, caller);
-        if (principals == caller->script->principals) {
-            filename = caller->script->filename;
-            lineno = js_PCToLineNumber(cx, caller->script, caller->pc);
-        } else {
-            filename = principals->codebase;
-            lineno = 0;
-        }
+        filename = js_ComputeFilename(cx, caller, principals, &lineno);
     } else {
         filename = NULL;
         lineno = 0;
diff --git a/js/src/jsobj.c b/js/src/jsobj.c
index 5909075..22ccb2f9 100644
--- a/js/src/jsobj.c
+++ b/js/src/jsobj.c
@@ -1133,6 +1133,23 @@ bad:
     return NULL;
 }
 
+const char *
+js_ComputeFilename(JSContext *cx, JSStackFrame *caller,
+                   JSPrincipals *principals, uintN *linenop)
+{
+    uint32 flags;
+
+    flags = JS_GetScriptFilenameFlags(caller->script);
+    if ((flags & JSFILENAME_PROTECTED) &&
+        strcmp(principals->codebase, """"[System Principal]"""")) {
+        *linenop = 0;
+        return principals->codebase;
+    }
+
+    *linenop = js_PCToLineNumber(cx, caller->script, caller->pc);
+    return caller->script->filename;
+}
+
 static JSBool
 obj_eval(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
@@ -1271,13 +1288,7 @@ obj_eval(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
     str = JSVAL_TO_STRING(argv[0]);
     if (caller) {
         principals = JS_EvalFramePrincipals(cx, fp, caller);
-        if (principals == caller->script->principals) {
-            file = caller->script->filename;
-            line = js_PCToLineNumber(cx, caller->script, caller->pc);
-        } else {
-            file = principals->codebase;
-            line = 0;
-        }
+        file = js_ComputeFilename(cx, caller, principals, &line);
     } else {
         file = NULL;
         line = 0;
diff --git a/js/src/jsobj.h b/js/src/jsobj.h
index ba7506e..c9d4113 100644
--- a/js/src/jsobj.h
+++ b/js/src/jsobj.h
@@ -699,6 +699,10 @@ js_CheckPrincipalsAccess(JSContext *cx, JSObject *scopeobj,
 extern JSObject *
 js_GetWrappedObject(JSContext *cx, JSObject *obj);
 
+/* NB: Infallible. */
+extern const char *
+js_ComputeFilename(JSContext *cx, JSStackFrame *caller,
+                   JSPrincipals *principals, uintN *linenop);
 JS_END_EXTERN_C
 
 #endif /* jsobj_h___ */
diff --git a/js/src/jsscript.c b/js/src/jsscript.c
index 7dc9dbc..54f0589 100644
--- a/js/src/jsscript.c
+++ b/js/src/jsscript.c
@@ -241,9 +241,8 @@ script_compile_sub(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
             fp->scopeChain = scopeobj;  /* for the compiler's benefit */
         }
 
-        file = caller->script->filename;
-        line = js_PCToLineNumber(cx, caller->script, caller->pc);
         principals = JS_EvalFramePrincipals(cx, fp, caller);
+        file = js_ComputeFilename(cx, caller, principals, &line);
     } else {
         file = NULL;
         line = 0;"""
498f173ac10c673b5a78eb3c7c484296359cae75,81193,419848,jst%mozilla.org,"Backing out fix for bug 419848 due to feed code breakage.
",1204609150,"""diff --git a/content/base/src/nsScriptLoader.cpp b/content/base/src/nsScriptLoader.cpp
index 2358ddf..f7caf28 100644
--- a/content/base/src/nsScriptLoader.cpp
+++ b/content/base/src/nsScriptLoader.cpp
@@ -427,7 +427,8 @@ nsScriptLoader::ProcessScriptElement(nsIScriptElement *aElement)
   if (scriptURI) {
     // Check that the containing page is allowed to load this URI.
     rv = nsContentUtils::GetSecurityManager()->
-      CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), scriptURI, 0);
+      CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), scriptURI,
+                                nsIScriptSecurityManager::ALLOW_CHROME);
 
     NS_ENSURE_SUCCESS(rv, rv);
 
diff --git a/content/xml/document/src/nsXMLContentSink.cpp b/content/xml/document/src/nsXMLContentSink.cpp
index 58d0dd5..dd058b5 100644
--- a/content/xml/document/src/nsXMLContentSink.cpp
+++ b/content/xml/document/src/nsXMLContentSink.cpp
@@ -767,7 +767,8 @@ nsXMLContentSink::ProcessStyleLink(nsIContent* aElement,
     // Do security check
     nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
     rv = secMan->
-      CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), url, 0);
+      CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), url,
+                                nsIScriptSecurityManager::ALLOW_CHROME);
     NS_ENSURE_SUCCESS(rv, NS_OK);
 
     // Do content policy check
diff --git a/content/xul/document/src/nsXULContentSink.cpp b/content/xul/document/src/nsXULContentSink.cpp
index dc7b0f7..48d257b 100644
--- a/content/xul/document/src/nsXULContentSink.cpp
+++ b/content/xul/document/src/nsXULContentSink.cpp
@@ -1158,7 +1158,8 @@ XULContentSinkImpl::OpenScript(const PRUnichar** aAttributes,
                   if (NS_SUCCEEDED(rv)) {
                       rv = mSecMan->
                           CheckLoadURIWithPrincipal(doc->NodePrincipal(),
-                                                    script->mSrcURI, 0);
+                                                    script->mSrcURI,
+                                                    nsIScriptSecurityManager::ALLOW_CHROME);
                   }
               }
           }"""
11752911ce35cbb5015ae7676f9f7903ae1a8752,81194,419848,jst%mozilla.org,"Fixing bug 419848. Tighten rules about what JS files content can load. r+sr=jonas@sicking.cc
",1204604254,"""diff --git a/content/base/src/nsScriptLoader.cpp b/content/base/src/nsScriptLoader.cpp
index f7caf28..2358ddf 100644
--- a/content/base/src/nsScriptLoader.cpp
+++ b/content/base/src/nsScriptLoader.cpp
@@ -427,8 +427,7 @@ nsScriptLoader::ProcessScriptElement(nsIScriptElement *aElement)
   if (scriptURI) {
     // Check that the containing page is allowed to load this URI.
     rv = nsContentUtils::GetSecurityManager()->
-      CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), scriptURI,
-                                nsIScriptSecurityManager::ALLOW_CHROME);
+      CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), scriptURI, 0);
 
     NS_ENSURE_SUCCESS(rv, rv);
 
diff --git a/content/xml/document/src/nsXMLContentSink.cpp b/content/xml/document/src/nsXMLContentSink.cpp
index dd058b5..58d0dd5 100644
--- a/content/xml/document/src/nsXMLContentSink.cpp
+++ b/content/xml/document/src/nsXMLContentSink.cpp
@@ -767,8 +767,7 @@ nsXMLContentSink::ProcessStyleLink(nsIContent* aElement,
     // Do security check
     nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
     rv = secMan->
-      CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), url,
-                                nsIScriptSecurityManager::ALLOW_CHROME);
+      CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), url, 0);
     NS_ENSURE_SUCCESS(rv, NS_OK);
 
     // Do content policy check
diff --git a/content/xul/document/src/nsXULContentSink.cpp b/content/xul/document/src/nsXULContentSink.cpp
index 48d257b..dc7b0f7 100644
--- a/content/xul/document/src/nsXULContentSink.cpp
+++ b/content/xul/document/src/nsXULContentSink.cpp
@@ -1158,8 +1158,7 @@ XULContentSinkImpl::OpenScript(const PRUnichar** aAttributes,
                   if (NS_SUCCEEDED(rv)) {
                       rv = mSecMan->
                           CheckLoadURIWithPrincipal(doc->NodePrincipal(),
-                                                    script->mSrcURI,
-                                                    nsIScriptSecurityManager::ALLOW_CHROME);
+                                                    script->mSrcURI, 0);
                   }
               }
           }"""
bb8b27aec5b74b3d6db317275a596f37f6b7b7a6,81946,415034,dveditz%cruzio.com,"bug 415034 prevent URIs with userinfo but no username. r=biesi, sr=bsmedberg, blocking1.9+
",1203557081,"""diff --git a/netwerk/base/src/nsStandardURL.cpp b/netwerk/base/src/nsStandardURL.cpp
index 0d1ccf9..e64bb52 100644
--- a/netwerk/base/src/nsStandardURL.cpp
+++ b/netwerk/base/src/nsStandardURL.cpp
@@ -1126,7 +1126,7 @@ nsStandardURL::SetUserPass(const nsACString &input)
 
     if (userpass.IsEmpty()) {
         // remove user:pass
-        if (mUsername.mLen >= 0) {
+        if (mUsername.mLen > 0) {
             if (mPassword.mLen > 0)
                 mUsername.mLen += (mPassword.mLen + 1);
             mUsername.mLen++;
@@ -1263,7 +1263,7 @@ nsStandardURL::SetPassword(const nsACString &input)
         NS_ERROR(""""cannot set password on no-auth url"""");
         return NS_ERROR_UNEXPECTED;
     }
-    if (mUsername.mLen < 0) {
+    if (mUsername.mLen <= 0) {
         NS_ERROR(""""cannot set password without existing username"""");
         return NS_ERROR_FAILURE;
     }
diff --git a/netwerk/base/src/nsURLParsers.cpp b/netwerk/base/src/nsURLParsers.cpp
index d099c49..4ed66ef 100644
--- a/netwerk/base/src/nsURLParsers.cpp
+++ b/netwerk/base/src/nsURLParsers.cpp
@@ -531,9 +531,16 @@ nsAuthURLParser::ParseUserInfo(const char *userinfo, PRInt32 userinfoLen,
     if (userinfoLen < 0)
         userinfoLen = strlen(userinfo);
 
+    if (userinfoLen == 0)
+        return NS_ERROR_MALFORMED_URI;
+
     const char *p = (const char *) memchr(userinfo, ':', userinfoLen);
     if (p) {
         // userinfo = <username:password>
+        if (p == userinfo) {
+            // must have a username!
+            return NS_ERROR_MALFORMED_URI;
+        }
         SET_RESULT(username, 0, p - userinfo);
         SET_RESULT(password, p - userinfo + 1, userinfoLen - (p - userinfo + 1));
     }"""
b5d790e9d0d848a42cad589f7d494a14a59abacd,83283,413250,dveditz%cruzio.com,"bug 413250 additional patch to catch double escaped chrome URIs too. r/sr=bsmedberg, a=beltzner
",1201831152,"""diff --git a/chrome/src/nsChromeRegistry.cpp b/chrome/src/nsChromeRegistry.cpp
index 8be54be..3dc16d5 100644
--- a/chrome/src/nsChromeRegistry.cpp
+++ b/chrome/src/nsChromeRegistry.cpp
@@ -679,14 +679,26 @@ nsChromeRegistry::Canonify(nsIURL* aChromeURL)
     aChromeURL->SetPath(path);
   }
   else {
-    nsCAutoString filePath;
-    rv = aChromeURL->GetFilePath(filePath);
-    NS_ENSURE_SUCCESS(rv, rv);
-    filePath.SetLength(nsUnescapeCount(filePath.BeginWriting()));
-
-    if (filePath.Find(NS_LITERAL_CSTRING("""".."""")) != kNotFound ||
-        filePath.FindChar(':') != kNotFound) {
-      return NS_ERROR_DOM_BAD_URI;
+    // prevent directory traversals ("""".."""")
+    // path is already unescaped once, but uris can get unescaped twice
+    const char* curChar = path.BeginReading();
+    const char* end = path.EndReading();
+    while (curChar < end) {
+      switch (*curChar) {
+        case ':':
+          return NS_ERROR_DOM_BAD_URI;
+        case '.':
+          if (*(curChar+1) == '.')
+            return NS_ERROR_DOM_BAD_URI;
+        case '%':
+          // chrome: URIs with double-escapes are trying to trick us.
+          // watch for %2e, and %25 in case someone triple unescapes
+          if (*(curChar+1) == '2' &&
+               ( *(curChar+2) == 'e' || *(curChar+2) == 'E' || 
+                 *(curChar+2) == '5' ))
+            return NS_ERROR_DOM_BAD_URI;
+      }
+      ++curChar;
     }
   }
 
@@ -744,7 +756,7 @@ nsChromeRegistry::ConvertChromeURL(nsIURI* aChromeURI, nsIURI* *aResult)
   else if (provider.EqualsLiteral(""""skin"""")) {
     baseURI = entry->skins.GetBase(mSelectedSkin, nsProviderArray::ANY);
   }
-  else {
+  else if (provider.EqualsLiteral(""""content"""")) {
     baseURI = entry->baseURI;
   }
 """
4cfe62d18df48489016e1b33678f1028f5c40c5d,83888,413250,dveditz%cruzio.com,"bug 413250 fix chrome: URI scheme traversal. r=Neil, sr=bsmedberg
",1201244272,"""diff --git a/chrome/src/nsChromeRegistry.cpp b/chrome/src/nsChromeRegistry.cpp
index 1efeace..8be54be 100644
--- a/chrome/src/nsChromeRegistry.cpp
+++ b/chrome/src/nsChromeRegistry.cpp
@@ -682,9 +682,10 @@ nsChromeRegistry::Canonify(nsIURL* aChromeURL)
     nsCAutoString filePath;
     rv = aChromeURL->GetFilePath(filePath);
     NS_ENSURE_SUCCESS(rv, rv);
+    filePath.SetLength(nsUnescapeCount(filePath.BeginWriting()));
 
-    if (filePath.Find(NS_LITERAL_CSTRING("""".."""")) != -1 ||
-        filePath.FindChar(':') != -1) {
+    if (filePath.Find(NS_LITERAL_CSTRING("""".."""")) != kNotFound ||
+        filePath.FindChar(':') != kNotFound) {
       return NS_ERROR_DOM_BAD_URI;
     }
   }
diff --git a/rdf/chrome/src/nsChromeRegistry.cpp b/rdf/chrome/src/nsChromeRegistry.cpp
index d960d2b..20a4437 100644
--- a/rdf/chrome/src/nsChromeRegistry.cpp
+++ b/rdf/chrome/src/nsChromeRegistry.cpp
@@ -81,6 +81,7 @@
 #include """"nsLayoutCID.h""""
 #include """"prio.h""""
 #include """"nsInt64.h""""
+#include """"nsEscape.h""""
 #include """"nsIDirectoryService.h""""
 #include """"nsILocalFile.h""""
 #include """"nsAppDirectoryServiceDefs.h""""
@@ -388,26 +389,16 @@ SplitURL(nsIURI *aChromeURI, nsCString& aPackage, nsCString& aProvider, nsCStrin
   } else {
     // Protect against URIs containing .. that reach up out of the
     // chrome directory to grant chrome privileges to non-chrome files.
-    int depth = 0;
-    PRBool sawSlash = PR_TRUE;  // .. at the beginning is suspect as well as /..
-    for (const char* p=aFile.get(); *p; p++) {
-      if (sawSlash) {
-        if (p[0] == '.' && p[1] == '.'){
-          depth--;    // we have /.., decrement depth.
-        } else {
-          static const char escape[] = """"%2E%2E"""";
-          if (PL_strncasecmp(p, escape, sizeof(escape)-1) == 0)
-            depth--;   // we have the HTML-escaped form of /.., decrement depth.
-        }
-      } else if (p[0] != '/') {
-        depth++;        // we have /x for some x that is not /
-      }
-      sawSlash = (p[0] == '/');
-
-      if (depth < 0) {
-        return NS_ERROR_FAILURE;
-      }
+    PRInt32 origLen = aFile.Length();
+    PRInt32 newLen = nsUnescapeCount(aFile.BeginWriting());
+    if (origLen != newLen) {
+        aFile.SetLength(newLen);
+        nofile = PR_TRUE; // let caller know path is modified
     }
+
+    if (aFile.Find(NS_LITERAL_CSTRING("""".."""")) != kNotFound ||
+        aFile.FindChar(':') != kNotFound)
+      return NS_ERROR_FAILURE;
   }
   if (aModified)
     *aModified = nofile;"""
31e19b77d311a99d932a37d0e4d5037caf3a8e1f,87246,400556,bzbarsky%mit.edu,"Fix bug 400556 by tearing down editor a little earlier.  r+sr=peterv
",1196647636,"""diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
index 4ec7878..834bae7 100644
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -1004,6 +1004,12 @@ nsDocShell::FirePageHideNotification(PRBool aIsUnload)
         }
     }
 
+    // Now make sure our editor, if any, is torn down before we go
+    // any farther.
+    if (mEditorData) {
+        mEditorData->TearDownEditor();
+    }
+
     return NS_OK;
 }
 
diff --git a/docshell/base/nsDocShellEditorData.cpp b/docshell/base/nsDocShellEditorData.cpp
index a26d675..9b69dce 100644
--- a/docshell/base/nsDocShellEditorData.cpp
+++ b/docshell/base/nsDocShellEditorData.cpp
@@ -68,6 +68,12 @@ nsDocShellEditorData::nsDocShellEditorData(nsIDocShell* inOwningDocShell)
 ----------------------------------------------------------------------------*/
 nsDocShellEditorData::~nsDocShellEditorData()
 {
+  TearDownEditor();
+}
+
+void
+nsDocShellEditorData::TearDownEditor()
+{
   if (mEditingSession)
   {
     nsCOMPtr<nsIDOMWindow> domWindow = do_GetInterface(mDocShell);
diff --git a/docshell/base/nsDocShellEditorData.h b/docshell/base/nsDocShellEditorData.h
index b624b1a..8007796 100644
--- a/docshell/base/nsDocShellEditorData.h
+++ b/docshell/base/nsDocShellEditorData.h
@@ -66,7 +66,7 @@ public:
               ~nsDocShellEditorData();
               
 
-              // set a flag to say this frame should be editable when the next url loads
+  // set a flag to say this frame should be editable when the next url loads
   nsresult    MakeEditable(PRBool inWaitForUriLoad);
   
   PRBool      GetEditable();
@@ -84,6 +84,9 @@ public:
               // set the editor on this docShell
   nsresult    SetEditor(nsIEditor *inEditor);
 
+  // Tear down the editor on this docshell, if any.
+  void        TearDownEditor();
+
 protected:              
 
   nsresult    EnsureEditingSession();"""
11f842cd006d898044f3f0914f13095166ec13d5,87516,403331,dcamp%mozilla.com,"Bug 403331: update JAR channel URIs after a redirect.  r=bz, r=jwalden (mochitest changes), sr=dveditz
",1196138101,"""diff --git a/modules/libjar/nsIJARURI.idl b/modules/libjar/nsIJARURI.idl
index 0728027..2685c8f 100644
--- a/modules/libjar/nsIJARURI.idl
+++ b/modules/libjar/nsIJARURI.idl
@@ -47,7 +47,7 @@
  *
  * The nsIURL methods operate on the <jar-entry> part of the spec.
  */
-[scriptable, uuid(d2746619-1724-4f42-8ca8-dacaf1b269d6)]
+[scriptable, uuid(b0922a89-f87b-4cb5-8612-305a285fcca7)]
 interface nsIJARURI : nsIURL {
 
     /**
@@ -61,4 +61,10 @@ interface nsIJARURI : nsIURL {
      * value may contain %-escaped byte sequences.
      */
     attribute AUTF8String JAREntry;
+
+    /**
+     * Create a clone of the JAR URI with a new root URI (the URI for the
+     * actual JAR file).
+     */
+    nsIJARURI cloneWithJARFile(in nsIURI jarFile);
 };
diff --git a/modules/libjar/nsJARChannel.cpp b/modules/libjar/nsJARChannel.cpp
index afa122c..a4e1460 100644
--- a/modules/libjar/nsJARChannel.cpp
+++ b/modules/libjar/nsJARChannel.cpp
@@ -701,15 +701,40 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
                                  nsresult       status,
                                  nsIFile       *file)
 {
+    nsresult rv;
+
     // Grab the security info from our base channel
     nsCOMPtr<nsIChannel> channel(do_QueryInterface(request));
-    if (channel)
+    if (channel) {
         channel->GetSecurityInfo(getter_AddRefs(mSecurityInfo));
-    
+
+        PRUint32 loadFlags;
+        channel->GetLoadFlags(&loadFlags);
+        if (loadFlags & LOAD_REPLACE) {
+            mLoadFlags |= LOAD_REPLACE;
+
+            if (!mOriginalURI) {
+                SetOriginalURI(mJarURI);
+            }
+
+            nsCOMPtr<nsIURI> innerURI;
+            rv = channel->GetURI(getter_AddRefs(innerURI));
+            if (NS_SUCCEEDED(rv)) {
+                nsCOMPtr<nsIJARURI> newURI;
+                rv = mJarURI->CloneWithJARFile(innerURI,
+                                               getter_AddRefs(newURI));
+                if (NS_SUCCEEDED(rv)) {
+                    mJarURI = newURI;
+                }
+            }
+            status = rv;
+        }
+    }
+
     if (NS_SUCCEEDED(status)) {
         mJarFile = file;
     
-        nsresult rv = CreateJarInput(nsnull);
+        rv = CreateJarInput(nsnull);
         if (NS_SUCCEEDED(rv)) {
             // create input stream pump
             rv = NS_NewInputStreamPump(getter_AddRefs(mPump), mJarInput);
diff --git a/modules/libjar/nsJARURI.cpp b/modules/libjar/nsJARURI.cpp
index 3631745..064ef0a 100644
--- a/modules/libjar/nsJARURI.cpp
+++ b/modules/libjar/nsJARURI.cpp
@@ -499,31 +499,11 @@ nsJARURI::Clone(nsIURI **result)
 {
     nsresult rv;
 
-    nsCOMPtr<nsIURI> newJARFile;
-    rv = mJARFile->Clone(getter_AddRefs(newJARFile));
-    if (NS_FAILED(rv)) return rv;
-
-    NS_TryToSetImmutable(newJARFile);
-
-    nsCOMPtr<nsIURI> newJAREntryURI;
-    rv = mJAREntry->Clone(getter_AddRefs(newJAREntryURI));
+    nsCOMPtr<nsIJARURI> uri;
+    rv = CloneWithJARFile(mJARFile, getter_AddRefs(uri));
     if (NS_FAILED(rv)) return rv;
 
-    nsCOMPtr<nsIURL> newJAREntry(do_QueryInterface(newJAREntryURI));
-    NS_ASSERTION(newJAREntry, """"This had better QI to nsIURL!"""");
-    
-    nsJARURI* uri = new nsJARURI();
-    if (uri) {
-        NS_ADDREF(uri);
-        uri->mJARFile = newJARFile;
-        uri->mJAREntry = newJAREntry;
-        *result = uri;
-        rv = NS_OK;
-    } else {
-        rv = NS_ERROR_OUT_OF_MEMORY;
-    }
-
-    return rv;
+    return CallQueryInterface(uri, result);
 }
 
 NS_IMETHODIMP
@@ -785,6 +765,42 @@ nsJARURI::SetJAREntry(const nsACString &entryPath)
                           getter_AddRefs(mJAREntry));
 }
 
+NS_IMETHODIMP
+nsJARURI::CloneWithJARFile(nsIURI *jarFile, nsIJARURI **result)
+{
+    if (!jarFile) {
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    nsresult rv;
+
+    nsCOMPtr<nsIURI> newJARFile;
+    rv = jarFile->Clone(getter_AddRefs(newJARFile));
+    if (NS_FAILED(rv)) return rv;
+
+    NS_TryToSetImmutable(newJARFile);
+
+    nsCOMPtr<nsIURI> newJAREntryURI;
+    rv = mJAREntry->Clone(getter_AddRefs(newJAREntryURI));
+    if (NS_FAILED(rv)) return rv;
+
+    nsCOMPtr<nsIURL> newJAREntry(do_QueryInterface(newJAREntryURI));
+    NS_ASSERTION(newJAREntry, """"This had better QI to nsIURL!"""");
+    
+    nsJARURI* uri = new nsJARURI();
+    if (uri) {
+        NS_ADDREF(uri);
+        uri->mJARFile = newJARFile;
+        uri->mJAREntry = newJAREntry;
+        *result = uri;
+        rv = NS_OK;
+    } else {
+        rv = NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    return rv;
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 
 NS_IMETHODIMP
diff --git a/modules/libjar/test/Makefile.in b/modules/libjar/test/Makefile.in
index 346e090..5d8d391 100644
--- a/modules/libjar/test/Makefile.in
+++ b/modules/libjar/test/Makefile.in
@@ -47,4 +47,8 @@ MODULE		= test_libjar
 
 XPCSHELL_TESTS = unit
 
+ifdef MOZ_MOCHITEST
+DIRS		+= mochitest
+endif
+
 include $(topsrcdir)/config/rules.mk
diff --git a/modules/libjar/test/mochitest/Makefile.in b/modules/libjar/test/mochitest/Makefile.in
new file mode 100644
index 0000000..9f3cf83
--- /dev/null
+++ b/modules/libjar/test/mochitest/Makefile.in
@@ -0,0 +1,54 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the """"License""""); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an """"AS IS"""" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Mozilla Foundation.
+# Portions created by the Initial Developer are Copyright (C) 2007
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the """"GPL""""),
+# or the GNU Lesser General Public License Version 2.1 or later (the """"LGPL""""),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+relativesrcdir  = modules/libjar/test/mochitest
+
+include $(DEPTH)/config/autoconf.mk
+include $(topsrcdir)/config/rules.mk
+
+_TEST_FILES = \
+		test_bug403331.html    \
+		bug403331.zip          \
+		bug403331.zip^headers^ \
+		$(NULL)
+
+libs:: $(_TEST_FILES)
+	$(INSTALL) $(foreach f,$^,""""$f"""") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
diff --git a/modules/libjar/test/mochitest/bug403331.zip b/modules/libjar/test/mochitest/bug403331.zip
new file mode 100644
index 0000000..48ba268
Binary files /dev/null and b/modules/libjar/test/mochitest/bug403331.zip differ
diff --git a/modules/libjar/test/mochitest/bug403331.zip^headers^ b/modules/libjar/test/mochitest/bug403331.zip^headers^
new file mode 100644
index 0000000..28b8aa0
--- /dev/null
+++ b/modules/libjar/test/mochitest/bug403331.zip^headers^
@@ -0,0 +1 @@
+Content-Type: application/java-archive
diff --git a/modules/libjar/test/mochitest/test_bug403331.html b/modules/libjar/test/mochitest/test_bug403331.html
new file mode 100644
index 0000000..8b46ef9
--- /dev/null
+++ b/modules/libjar/test/mochitest/test_bug403331.html
@@ -0,0 +1,46 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=403331
+-->
+<head>
+  <title>Test for Bug 403331</title>
+  <script type=""""text/javascript"""" src=""""/MochiKit/MochiKit.js""""></script>
+  <script type=""""text/javascript"""" src=""""/tests/SimpleTest/SimpleTest.js""""></script>        
+  <link rel=""""stylesheet"""" type=""""text/css"""" href=""""/tests/SimpleTest/test.css"""" />
+</head>
+<body>
+
+<iframe id=""""testFrame""""></iframe>
+
+<pre id=""""test"""">
+<script class=""""testbody"""" type=""""text/javascript"""">
+
+/** Test for Bug 403331 **/
+
+SimpleTest.waitForExplicitFinish();
+
+function runTest() {
+  var testFrame = document.getElementById('testFrame');
+
+  // Try a redirected load from another domain to this one.
+
+  testFrame.onload = function() {
+    // If properly redirected, we'll be able to access elements in the loaded
+    // document.
+    var item = testFrame.contentDocument.getElementById('testitem');
+    is(item.textContent, """"testcontents"""", """"Should be able to access the child document"""");
+
+    SimpleTest.finish();
+  }
+
+  testFrame.src = """"jar:http://example.org:80/redirect?http://localhost:8888/tests/modules/libjar/test/mochitest/bug403331.zip!/test.html"""";
+}
+
+addLoadEvent(runTest);
+
+</script>
+</pre>
+
+</body>
+</html>
diff --git a/testing/mochitest/server.js b/testing/mochitest/server.js
index 6666714..0280e3c 100644
--- a/testing/mochitest/server.js
+++ b/testing/mochitest/server.js
@@ -140,6 +140,8 @@ function runServer()
   if (environment[""""CLOSE_WHEN_DONE""""])
     server.registerPathHandler(""""/server/shutdown"""", serverShutdown);
 
+  server.registerPathHandler(""""/redirect"""", redirect);
+
   server.setIndexHandler(defaultDirHandler);
   server.start(SERVER_PORT);
 
@@ -198,6 +200,12 @@ function serverShutdown(metadata, response)
   otherDomainServer.stop();
 }
 
+function redirect(metadata, response)
+{
+  response.setStatusLine(""""1.1"""", 301, """"Moved Permanently"""");
+  response.setHeader(""""Location"""", metadata.queryString);
+}
+
 //
 // DIRECTORY LISTINGS
 //"""
d867adecd5b74aa2f763672b460ac045aa7d8de4,88249,402649,bzbarsky%mit.edu,"Base our referrer on the URI of the principal executing the code, not on the
URI of the document currently loaded in the window associated to the context
we're running on.  Bug 402649, r+sr=jst
",1194808286,"""diff --git a/dom/src/base/nsGlobalWindow.h b/dom/src/base/nsGlobalWindow.h
index f11e600..397b9f5 100644
--- a/dom/src/base/nsGlobalWindow.h
+++ b/dom/src/base/nsGlobalWindow.h
@@ -847,7 +847,6 @@ protected:
   nsresult SetHrefWithContext(JSContext* cx, const nsAString& aHref,
                               PRBool aReplace);
 
-  nsresult GetSourceURL(JSContext* cx, nsIURI** sourceURL);
   nsresult GetSourceBaseURL(JSContext* cx, nsIURI** sourceURL);
   nsresult GetSourceDocument(JSContext* cx, nsIDocument** aDocument);
 
diff --git a/dom/src/base/nsLocation.cpp b/dom/src/base/nsLocation.cpp
index ad9d8c2..386c780 100644
--- a/dom/src/base/nsLocation.cpp
+++ b/dom/src/base/nsLocation.cpp
@@ -223,8 +223,7 @@ nsLocation::CheckURL(nsIURI* aURI, nsIDocShellLoadInfo** aLoadInfo)
         !principal)
       return NS_ERROR_FAILURE;
     owner = do_QueryInterface(principal);
-
-    GetSourceURL(cx, getter_AddRefs(sourceURI));
+    principal->GetURI(getter_AddRefs(sourceURI));
   }
 
   // Create load info
@@ -1028,17 +1027,3 @@ nsLocation::GetSourceBaseURL(JSContext* cx, nsIURI** sourceURL)
 
   return rv;
 }
-
-nsresult
-nsLocation::GetSourceURL(JSContext* cx, nsIURI** sourceURL)
-{
-  nsCOMPtr<nsIDocument> doc;
-  nsresult rv = GetSourceDocument(cx, getter_AddRefs(doc));
-  if (doc) {
-    NS_IF_ADDREF(*sourceURL = doc->GetDocumentURI());
-  } else {
-    *sourceURL = nsnull;
-  }
-
-  return rv;
-}"""
